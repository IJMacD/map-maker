{"version":3,"sources":["../webpack/bootstrap","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/get.js","../node_modules/@babel/runtime/helpers/esm/superPropBase.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","util.js","geometry.js","Style.js","matchPseudoClasses.js","getContent.js","MapRenderer.js","bbox.js","canvas-render/setStrokeFill.js","parseStrokeFill.js","canvas-render/renderText.js","canvas-render/transform.js","canvas-render/renderPoint.js","CollisionSystem.js","canvas-render/renderAreaLine.js","render-worker.js","canvas-render/index.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/@babel/runtime/helpers/esm/createSuper.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","length","descriptor","configurable","writable","_createClass","protoProps","staticProps","_getPrototypeOf","setPrototypeOf","getPrototypeOf","__proto__","receiver","Reflect","base","desc","getOwnPropertyDescriptor","_isNativeReflectConstruct","construct","sham","Proxy","Date","toString","e","_typeof","obj","iterator","constructor","_possibleConstructorReturn","self","ReferenceError","_setPrototypeOf","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","minLen","slice","from","test","_slicedToArray","isArray","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","err","_toConsumableArray","iter","_createForOfIteratorHelper","F","f","it","normalCompletion","didErr","step","_e2","mercatorProjection","centre","scale","width","height","cLon","cLat","tileCount","Math","pow","hPixelsPerDeg","vPixelsPerDeg","QUARTER_PI","PI","cX","cY","cLatPrime","log","tan","lon","lat","E","N","getAveragePoint","points","reduce","sum","map","x","getCentrePoint","boundingBox","getBoundingBox","getMidPoint","floor","minMax","point","min","max","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","rectToPoints","y","getCrossProductArea","getArea","abs","isAntiClockwise","isConvex","sign","a","b","isSelfClosing","getLength","dx","dy","sqrt","StyleSelector","type","tags","pseudoClasses","pseudoElement","this","entries","k","v","op","join","matchSelector","selector","element","inequalities","exec","cmp","COMPARE","substr","res","isNaN","localeCompare","makePredicate","match","left","operator","right","testPredicate","predicate","context","Function","parse","text","tagText","substring","trim","re2","m2","re3","m3","re","params","split","re4","m4","console","parseMultiple","filter","matchPseudoClasses","rule","nodes","includesPseudoClass","hasPseudoClasses","pc","elementContext","area","some","getContent","content","declarations","index","out","replace","MapRenderer","elements","nodeMap","forEach","id","wayMap","zoom","projection","globalSetup","renderPseudoElement","renderArea","current","coords","renderPoint","longitude","latitude","renderGridlines","el","renderLine","renderAreaLine","getPoint","centrePoint","midPoint","avgPoint","bounding","boundingPoints","bottom","top","NaN","baseline","line","size","measureText","ascending","descending","padding","parseFloat","boundPoints","decimatedPoints","vertical","find","horizontal","parts","dLon","dLat","toFixed","makeBBox","round","sigFigs","ceil","log10","xmin","xmax","ymin","ymax","j","setStrokeFill","ctx","lineWidth","fillStyle","strokeStyle","mutedStyle","ss","repeat","sm","parseStrokeFill","renderText","setFont","textWidth","strokeText","fillText","actualBoundingBoxAscent","actualBoundingBoxDescent","fontSize","fontWeight","fontFamily","font","applyTransform","trans","unit","transform","rotate","translate","valueY","save","beginPath","ellipse","fill","stroke","drawPath","urlRe","url","img","Image","src","w","h","addEventListener","drawImage","restore","pathSpec","first","prev","segs","x2","y2","x3","y3","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","CollisionSystem","sets","set","box","intersects","singleton","boxA","boxB","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","scaleFactor","collisionSystem","getCollisionSystem","add","policy","offsetX","offsetY","cp","canvas","renderer","CanvasRender","subClass","superClass","Derived","result","Super","NewTarget","arguments","apply","getContext","globalAlpha","onmessage","msg","data","method","fillRect","renderRule"],"mappings":"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","file":"static/js/render-worker.20ac31e5.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/map-maker/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import superPropBase from \"./superPropBase\";\nexport default function _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}","import getPrototypeOf from \"./getPrototypeOf\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"../../helpers/esm/typeof\";\nimport assertThisInitialized from \"./assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","/**\r\n * Promise based timeout\r\n * @param {number} duration\r\n */\r\nexport function timeout (duration) {\r\n    return new Promise(resolve => setTimeout(resolve, duration));\r\n}\r\n\r\n/**\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n * @param {number} minLon\r\n * @param {number} minLat\r\n * @param {number} maxLon\r\n * @param {number} maxLat\r\n * @param {number} width\r\n * @param {number} height\r\n */\r\nexport function flatProjection(minLon, minLat, maxLon, maxLat, width, height) {\r\n    const xScale = width / (maxLon - minLon);\r\n    const yScale = height / (maxLat - minLat);\r\n    const scale = Math.max(xScale, yScale);\r\n    return ((lon, lat) => [(lon - minLon) * scale, height - (lat - minLat) * scale]);\r\n}\r\n/**\r\n * @param {[number, number]} centre\r\n * @param {number} scale\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n */\r\nexport function mercatorProjection(centre, scale, width, height) {\r\n    const baseTileSize = 256;\r\n\r\n    const [cLon, cLat] = centre;\r\n\r\n    const tileCount = Math.pow(2, scale);\r\n    const degPerTileH = 180 / tileCount;\r\n    const degPerTileV = 180 / tileCount;\r\n\r\n    const hPixelsPerDeg = baseTileSize / degPerTileH;\r\n    const vPixelsPerDeg = baseTileSize / degPerTileV;\r\n\r\n    const QUARTER_PI = Math.PI / 4;\r\n\r\n    const cX = width / 2;\r\n    const cY = height / 2;\r\n\r\n    const cLatPrime = Math.log(Math.tan(QUARTER_PI + (cLat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n    return (lon, lat) => {\r\n        const E = lon;\r\n        const N = Math.log(Math.tan(QUARTER_PI + (lat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n        const dLon = E - cLon;\r\n        const dLat = N - cLatPrime;\r\n\r\n        const dX = dLon * hPixelsPerDeg;\r\n        const dY = dLat * vPixelsPerDeg;\r\n\r\n        return [cX + dX, cY - dY];\r\n    };\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n */\r\n\r\nexport function getAveragePoint(points) {\r\n    const sum = points.reduce((sum, p) => [sum[0] + p[0], sum[1] + p[1]], [0, 0]);\r\n    /** @type {[number, number]} */\r\n    const avg = (sum.map(x => x / points.length));\r\n    return avg;\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n * @returns {[number, number]}\r\n */\r\n\r\nexport function getCentrePoint(points) {\r\n    const boundingBox = getBoundingBox(points);\r\n\r\n    return [\r\n        boundingBox[0] + boundingBox[2] / 2,\r\n        boundingBox[1] + boundingBox[3] / 2,\r\n    ];\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n * @returns {[number, number]}\r\n */\r\n\r\nexport function getMidPoint(points) {\r\n    return points[Math.floor((points.length - 1) / 2)];\r\n}\r\n/**\r\n * @param {[number, number][]} points\r\n * @returns {[number, number, number, number]} (x, y, width, height)\r\n */\r\n\r\nexport function getBoundingBox(points) {\r\n    const minMax = points.reduce((minMax, point) => {\r\n        return [\r\n            Math.min(minMax[0], point[0]),\r\n            Math.min(minMax[1], point[1]),\r\n            Math.max(minMax[2], point[0]),\r\n            Math.max(minMax[3], point[1]),\r\n        ];\r\n    }, [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]);\r\n\r\n    return [\r\n        minMax[0],\r\n        minMax[1],\r\n        minMax[2] - minMax[0],\r\n        minMax[3] - minMax[1],\r\n    ];\r\n}\r\n","\r\n/**\r\n * \r\n * @param {number} x \r\n * @param {number} y \r\n * @param {number} width \r\n * @param {number} height \r\n * @returns {[number, number][]}\r\n */\r\nexport function rectToPoints(x, y, width, height) {\r\n    /** @type {[number, number][]} */\r\n    return [\r\n        [x, y],\r\n        [x, y + height],\r\n        [x + width, y + height],\r\n        [x + width, y],\r\n    ];\r\n}\r\n\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points \r\n */\r\nexport function getCrossProductArea (points) {\r\n    let sum = 0;\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n        sum += points[i][0] * points[i+1][1] - points[i+1][0] * points[i][1];\r\n    }\r\n    return sum / 2;\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getArea (points) {\r\n    return Math.abs(getCrossProductArea(points));\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isAntiClockwise (points) {\r\n    return getCrossProductArea(points) > 0;\r\n}\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points\r\n */\r\nexport function isConvex (points) {\r\n    const l = points.length;\r\n    if (l < 3) return;\r\n\r\n    let sign = 0;\r\n    for (let i = 1; i < l; i++) {\r\n        const a = points[i-1];\r\n        const b = points[i];\r\n        const c = points[(i+1) % l];\r\n        \r\n        const next = Math.sign((b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]));\r\n\r\n        if (sign === 0) sign = next;\r\n        else if (next !== 0 && sign !== next) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isSelfClosing (points) {\r\n    const f = points[0];\r\n    const l = points[points.length - 1]; \r\n    return f[0] === l[0] && f[1] === l[1];\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getLength (points) {\r\n    let sum = 0;\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n        const dx = points[i][0] - points[i-1][0];\r\n        const dy = points[i][1] - points[i-1][1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    return sum;\r\n}","/**\r\n * @typedef StyleRule\r\n * @property {\"rule\"} type\r\n * @property {StyleSelector} [selector]\r\n * @property {StyleSelector[]} [selectors]\r\n * @property {{ [key: string]: string }} declarations\r\n */\r\n\r\n/**\r\n * @typedef MediaQuery\r\n * @property {\"query\"} type\r\n * @property {Predicate} predicate\r\n * @property {StyleRule[]} rules\r\n */\r\n\r\n/**\r\n * @typedef Predicate\r\n * @property {string|number|Predicate} left\r\n * @property {string} operator\r\n * @property {string|number|Predicate} right\r\n */\r\n\r\nexport class StyleSelector {\r\n    /**\r\n     * @param {string} type\r\n     * @param {{ [key: string]: string }} tags\r\n     * @param {{ name: string, params: (string|Predicate)[] }[]} pseudoClasses\r\n     * @param {string} [pseudoElement]\r\n     */\r\n    constructor (type, tags, pseudoClasses=[], pseudoElement=null) {\r\n      this.type = type;\r\n      this.tags = tags;\r\n      this.pseudoClasses = pseudoClasses;\r\n      this.pseudoElement = pseudoElement;\r\n    }\r\n\r\n    toString () {\r\n      return `${this.type}${Object.entries(this.tags).map(([k,v]) => {\r\n        const op = /^[<=>]/.test(v) ? \"\" : \"=\";\r\n        return `[${k}${op}${v}]`;\r\n      }).join(\"\")}`;\r\n    }\r\n}\r\n\r\nStyleSelector.parse = /**\r\n * @param {string} text\r\n */\r\nfunction (text) {\r\n    const re = /^\\s*([a-z]+)/;\r\n    const m = re.exec(text);\r\n\r\n    if (!m) return null;\r\n\r\n    let type = m[1];\r\n\r\n    if (type === \"rel\") {\r\n      type = \"relation\";\r\n    }\r\n\r\n    /** @type {{ [key: string]: string }} */\r\n    const tags = {};\r\n\r\n    let tagText = text.substring(m[0].length).trim();\r\n\r\n    const re2 = /^\\[([a-z0-9_-]+)(=|<=|>=|<|>)([^[\\]]+)\\]/i;\r\n\r\n    while (true) {\r\n      const m2 = re2.exec(tagText);\r\n\r\n      if (!m2) break;\r\n\r\n      const op = m2[2] === \"=\" ? \"\" : m2[2];\r\n\r\n      tags[m2[1]] = op + m2[3];\r\n\r\n      tagText = tagText.substring(m2[0].length);\r\n    }\r\n\r\n    /** @type {{ name: string, params: (string|Predicate)[] }[]} */\r\n    const pseudoClasses = [];\r\n\r\n    const re3 = /^:([a-z-]+)(?:\\(([^)]+)\\))?/;\r\n\r\n    while (true) {\r\n      const m3 = re3.exec(tagText);\r\n\r\n      if (!m3) break;\r\n\r\n      const re = /^\\s*([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?/;\r\n      const params = m3[2] ? m3[2].split(\",\").map(s => re.test(s) ? makePredicate(re.exec(s)) : s) : [];\r\n      pseudoClasses.push({ name: m3[1], params });\r\n\r\n      tagText = tagText.substring(m3[0].length);\r\n    }\r\n\r\n    let pseudoElement = null;\r\n\r\n    const re4 = /^::([a-z-]+)?/;\r\n\r\n    if (re4.test(tagText)) {\r\n      const m4 = re4.exec(tagText);\r\n\r\n      pseudoElement = m4[1];\r\n\r\n      tagText = tagText.substring(m4[0].length);\r\n    }\r\n\r\n    if (tagText.length) {\r\n      console.log(`Invalid selector: ${text} unexpected part: '${tagText}'`);\r\n      return null;\r\n    }\r\n\r\n    return new StyleSelector(type, tags, pseudoClasses, pseudoElement);\r\n};\r\n\r\n/**\r\n *\r\n * @param {string} text\r\n */\r\nStyleSelector.parseMultiple = function (text) {\r\n    return text.split(\",\").map(StyleSelector.parse).filter(x => x);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{ rules: StyleRule[] }} style\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @returns {StyleRule}\r\n */\r\nexport function matchRule (style, element) {\r\n    for (const rule of style.rules) {\r\n      for (const selector of rule.selectors) {\r\n        if (matchSelector(selector, element))  return rule;\r\n      }\r\n    }\r\n}\r\n\r\n/**\r\n * @param {StyleSelector} selector\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n */\r\nexport function matchSelector (selector, element, inequalities=true) {\r\n  if (element.type !== selector.type && !(selector.type === \"area\" && element.type === \"way\")) return false;\r\n\r\n  const entries = Object.entries(selector.tags);\r\n  if (entries.length && typeof element.tags === \"undefined\") return false;\r\n\r\n  for (const [key, value] of entries) {\r\n    if (typeof element.tags[key] === \"undefined\") return false;\r\n\r\n    const m = /^[<=>]+/.exec(value);\r\n    if (m) {\r\n      // Only test if inequalities are enabled\r\n      if (inequalities) {\r\n        const op = m[0];\r\n        const cmp = COMPARE[op];\r\n        // Skip if invalid operator\r\n        if (!cmp) continue;\r\n        const v = value.substr(m[0].length);\r\n        // String compare or numeric compare\r\n        const res = isNaN(+v) ? cmp(element.tags[key].localeCompare(v), 0) : cmp(+element.tags[key], +v);\r\n\r\n        if (!res) return false;\r\n      }\r\n      // If inequalities are disabled then this tag gets a pass\r\n    }\r\n    else if (value !== \"*\" && element.tags[key] !== value) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * @param {string} styleText\r\n */\r\nexport function parseStyle (styleText) {\r\n  /** @type {{ rules: (StyleRule|MediaQuery)[] }} */\r\n  const out = { rules: [] };\r\n\r\n  let length = styleText.length;\r\n\r\n  while (length > 0) {\r\n\r\n    // Try parsing rule list\r\n    const rulesResult = parseRules(styleText);\r\n    out.rules.push(...rulesResult.rules);\r\n    styleText = styleText.substring(rulesResult.index).trim();\r\n\r\n    // Try parsing media query\r\n    const mediaResult = parseMedia(styleText);\r\n    out.rules.push(...mediaResult.mediaQueries);\r\n    styleText = styleText.substring(mediaResult.index).trim();\r\n\r\n    if (styleText.length === length) {\r\n      console.log(\"Got stuck parsing style at: \" + styleText);\r\n      break;\r\n    }\r\n\r\n    length = styleText.length;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * @param {string} mediaText\r\n */\r\nfunction parseMedia (mediaText) {\r\n  const re = /^\\s*@match\\s*\\(([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?\\)\\s*{/;\r\n  /** @type {{ mediaQueries: MediaQuery[], index: number }} */\r\n  const out = { mediaQueries: [], index: 0 };\r\n  let match;\r\n\r\n  const re2 = /^\\s*}/;\r\n  let match2;\r\n\r\n  while (match = re.exec(mediaText)) {\r\n    const predicate = makePredicate(match);\r\n\r\n    out.index += match[0].length;\r\n\r\n    mediaText = mediaText.substring(match[0].length);\r\n\r\n    const { rules, index } = parseRules(mediaText);\r\n\r\n    out.index += index;\r\n\r\n    mediaText = mediaText.substring(index);\r\n\r\n    match2 = re2.exec(mediaText);\r\n\r\n    if (match2) {\r\n      out.mediaQueries.push({\r\n        type: \"query\",\r\n        predicate,\r\n        rules,\r\n      });\r\n\r\n      out.index += match2[0].length;\r\n\r\n    } else {\r\n      console.log(\"Unterminated media query\");\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nfunction parseRules (ruleText) {\r\n  const re = /^\\s*([^{}]+)\\s*{([^{}]*)}/;\r\n  let match;\r\n  /** @type {{ rules: StyleRule[], index: number }} */\r\n  const out = { rules: [], index: 0 };\r\n\r\n  while(match = re.exec(ruleText)) {\r\n    /** @type {{ [key: string]: string }} */\r\n    const declarations = {};\r\n\r\n    match[2].split(\";\").map(s => s.trim()).filter(s => s).forEach(s => {\r\n      // s.split(\":\", 2) is not the same as PHP\r\n      const i = s.indexOf(\":\");\r\n      const property = s.substring(0,i).trim();\r\n      const value = s.substring(i+1).trim();\r\n      declarations[property] = value;\r\n    });\r\n\r\n    const selectors = StyleSelector.parseMultiple(match[1]);\r\n\r\n    if (selectors.length) {\r\n      out.rules.push({\r\n        type: \"rule\",\r\n        selectors,\r\n        declarations,\r\n      });\r\n    }\r\n\r\n    out.index += match[0].length;\r\n\r\n    ruleText = ruleText.substring(match[0].length);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n *\r\n * @param {(StyleRule|MediaQuery)[]} rules\r\n * @param {object} context\r\n * @returns {StyleRule[]}\r\n */\r\nexport function expandRules (rules, context) {\r\n  /** @type {StyleRule[]} */\r\n  const out = [];\r\n  for (const rule of rules) {\r\n    if (rule.type === \"rule\") {\r\n      const { declarations } = rule;\r\n      for (const selector of rule.selectors) {\r\n        out.push({ type: \"rule\", selector, declarations });\r\n      }\r\n    } else {\r\n      if (testPredicate(rule.predicate, context)) {\r\n        out.push(...expandRules(rule.rules, context));\r\n      }\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction makePredicate(match) {\r\n  let predicate;\r\n\r\n  if (match[4]) {\r\n    // MediaQueries4 syntax:\r\n    //  @match (10 < zoom <= 14)\r\n    predicate = {\r\n      left: { left: match[1], operator: match[2], right: match[3] },\r\n      operator: \"and\",\r\n      right: { left: match[3], operator: match[4], right: match[5] },\r\n    };\r\n  }\r\n  else {\r\n    // MediaQueries4 syntax:\r\n    //  @match (zoom <= 14)\r\n    // MediaQueries3 syntax:\r\n    //  @match (max-zoom: 14) [TODO - it's parsed just not handled correctly]\r\n    predicate = {\r\n      left: match[1],\r\n      operator: match[2],\r\n      right: match[3],\r\n    };\r\n  }\r\n  return predicate;\r\n}\r\n\r\n/**\r\n *\r\n * @param {Predicate} predicate\r\n * @param {object} [context]\r\n * @returns {boolean}\r\n */\r\nexport function testPredicate (predicate, context={}) {\r\n  let left = typeof predicate.left === \"string\" || typeof predicate.left === \"number\" ?\r\n    predicate.left : testPredicate(predicate.left, context);\r\n  let right = typeof predicate.right === \"string\" || typeof predicate.right === \"number\"  ?\r\n    predicate.right : testPredicate(predicate.right, context);\r\n\r\n  if (typeof left === \"string\" && left in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[left] instanceof Function)\r\n      context[left] = context[left]();\r\n\r\n    left = context[left];\r\n  }\r\n\r\n  if (typeof right === \"string\" && right in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[right] instanceof Function)\r\n      context[right] = context[right]();\r\n\r\n    right = context[right];\r\n  }\r\n\r\n  const op = COMPARE[predicate.operator];\r\n\r\n  if (!op) return false;\r\n\r\n  return op(left, right);\r\n}\r\n\r\nconst COMPARE = {\r\n  \":\": (a,b) => a == b,\r\n  \"=\": (a,b) => a == b,\r\n  \">\": (a,b) => a > b,\r\n  \"<\": (a,b) => a < b,\r\n  \">=\": (a,b) => a >= b,\r\n  \"<=\": (a,b) => a <= b,\r\n  \"and\": (a,b) => a && b,\r\n  \"or\": (a,b) => a || b,\r\n}","import { getArea, isConvex, isAntiClockwise, getLength } from \"./geometry\";\r\nimport { testPredicate } from \"./Style\";\r\nimport { getBoundingBox } from \"./util\";\r\n\r\n/** @typedef {import(\"./Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"./Overpass\").OverpassElement} OverpassElement */\r\n\r\n\r\n/**\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @param {import(\"./Overpass\").OverpassElement[]} nodes\r\n */\r\nexport function matchPseudoClasses(rule, points, element=null, nodes = null) {\r\n    const { selector } = rule;\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"convex\")) {\r\n        if (!isConvex(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"concave\")) {\r\n        if (isConvex(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"clockwise\")) {\r\n        if (isAntiClockwise(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"anti-clockwise\")) {\r\n        if (!isAntiClockwise(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"self-closing\")) {\r\n        if (nodes[0] !== nodes[points.length - 1])\r\n            return false;\r\n    }\r\n\r\n    const hasPseudoClasses = selector.pseudoClasses.filter(c => c.name === \"has\");\r\n\r\n    for (const pc of hasPseudoClasses) {\r\n        if (typeof pc.params[0] === \"string\")\r\n            return false;\r\n\r\n        const predicate = pc.params[0];\r\n\r\n        // Functions for lazy evaluation\r\n        const elementContext = {\r\n            area: () => getArea(points),\r\n            length: () => getLength(points),\r\n            width: () => getBoundingBox(points)[2],\r\n            height: () => getBoundingBox(points)[3],\r\n        };\r\n\r\n        const match = testPredicate(predicate, elementContext);\r\n\r\n        if (!match) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * @todo Add support for more than one paramater\r\n * @param {import(\"./Overpass\").StyleSelector} selector\r\n * @param {string} name\r\n * @param  {...string} params\r\n */\r\nfunction includesPseudoClass (selector, name, ...params) {\r\n    return selector.pseudoClasses.some(c => c.name === name && c.params[0] === params[0]);\r\n}","/**\r\n * @param {import(\"./Style\").StyleRule} rule\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @param {import(\"./MapRenderer\").MapContext} context\r\n */\r\n\r\nexport function getContent(rule, element, context) {\r\n    let content = rule.declarations[\"content\"];\r\n\r\n    if (!content)\r\n        return \"\";\r\n\r\n    let index = 0;\r\n    /** @type {string[]} */\r\n    const out = [];\r\n\r\n    while (index < content.length) {\r\n        const c = content.substr(index);\r\n\r\n        let m = /^\\s+/.exec(c);\r\n        if (m) {\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        m = /^\"(.*?[^\\\\])\"/.exec(c);\r\n        if (m) {\r\n            out.push(m[1].replace(/\\\\\"/g, `\"`).replace(/\\\\n/g, `\\n`));\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        m = /^tag\\(([^)]+)\\)/.exec(c);\r\n        if (m) {\r\n            out.push(element.tags[m[1]] || \"\");\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        m = /^debug\\(([^)]+)\\)/.exec(c);\r\n        if (m) {\r\n            if (m[1] === \"type\") out.push(element.type);\r\n            else if (m[1] === \"tags\") out.push(Object.entries(element.tags).map(([key, value]) => `[${key}=${value}]`).join(\"\\n\"));\r\n            else if (m[1] === \"location\" && element.type === \"node\") out.push(`(${element.lon},${element.lat})`);\r\n            else if (m[1] === \"node_count\" && (element.type === \"way\" || element.type === \"area\")) out.push(element.nodes.length.toString());\r\n            // else if (m[1] === \"length\" && (element.type === \"way\" || element.type === \"area\")) out.push(getLength(element.).toString())\r\n            // else if (m[1] === \"area\" && (element.type === \"way\" || element.type === \"area\")) out.push(getArea(element.).toString())\r\n            else if (m[1] === \"scale\") out.push(context.scale.toString());\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        // Shouldn't get here\r\n        return \"?\";\r\n    }\r\n\r\n    return out.join(\"\");\r\n}\r\n","import { mercatorProjection, getCentrePoint, getMidPoint, getAveragePoint, getBoundingBox } from \"./util\";\r\nimport { rectToPoints, isSelfClosing } from \"./geometry\";\r\nimport { matchPseudoClasses } from \"./matchPseudoClasses\";\r\nimport { getContent } from \"./getContent\";\r\nimport { makeBBox } from \"./bbox\";\r\nimport { matchSelector } from \"./Style\";\r\n\r\n/** @typedef {{ centre: [number, number], zoom: number, current?: { longitude: number, latitude: number }, width: number, height: number, scale: number }} MapContext */\r\n\r\nexport default class MapRenderer {\r\n\r\n    /**\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {import(\"./Overpass\").OverpassElement[]} elements\r\n     */\r\n    renderRule (context, rule, elements=[]) {\r\n        // Prepare node map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n        const nodeMap = {};\r\n        elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n        // Prepare way map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n        const wayMap = {};\r\n        elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n        const { centre, zoom, width, height } = context;\r\n\r\n        /** @type {(lon: number, lat: number) => [number, number]} */\r\n        const projection = mercatorProjection(centre, zoom, width, height);\r\n\r\n        // Set up global context options\r\n        this.globalSetup(context, rule);\r\n\r\n        const { type } = rule.selector;\r\n\r\n        // Non-Overpass Types first\r\n        switch (type) {\r\n            case \"map\": {\r\n                const points = rectToPoints(0, 0, width, height);\r\n                if (rule.selector.pseudoElement)\r\n                    this.renderPseudoElement(context, rule, points, null, null);\r\n                else\r\n                    this.renderArea(context, rule, points, null);\r\n                break;\r\n            }\r\n            case \"current\": {\r\n                if (context.current) {\r\n                    const coords = context.current;\r\n                    this.renderPoint(context, rule, projection(coords.longitude, coords.latitude));\r\n                }\r\n                break;\r\n            }\r\n            case \"gridlines\": {\r\n                this.renderGridlines(context, rule, projection);\r\n                break;\r\n            }\r\n            case \"dummy\": {\r\n                this.renderPoint(context, rule, [0, 0]);\r\n                break;\r\n            }\r\n            default:\r\n                // Then iterate all elements\r\n                for (const el of elements) {\r\n                    if (!matchSelector(rule.selector, el)) continue;\r\n\r\n                    switch (type) {\r\n                        case \"node\": {\r\n                            if (el.type !== \"node\") continue;\r\n\r\n                            const point = projection(el.lon, el.lat);\r\n\r\n                            if (rule.selector.pseudoElement) {\r\n                                this.renderPseudoElement(context, rule, [point], el, [el]);\r\n                            }\r\n                            else {\r\n                                this.renderPoint(context, rule, point, el);\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"way\":\r\n                        case \"area\": {\r\n                            if (el.type !== \"way\") continue;\r\n\r\n                            /** @type {import(\"./Overpass\").OverpassNodeElement[]} */\r\n                            const nodes = el.nodes.map(id => nodeMap[id]);\r\n                            const points = nodes.map(n => projection(n.lon, n.lat));\r\n\r\n                            if (!matchPseudoClasses(rule, points, el, nodes)) continue;\r\n\r\n                            if (rule.selector.pseudoElement) {\r\n                                this.renderPseudoElement(context, rule, points, el, nodes);\r\n                            }\r\n                            else {\r\n                                // Render actual way/area\r\n                                if (type === \"area\") {\r\n                                    this.renderArea(context, rule, points, el);\r\n                                } else {\r\n                                    this.renderLine(context, rule, points, el);\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"relation\": {\r\n                            if (el.type !== \"relation\") continue;\r\n\r\n                            // this.renderRelation(rule, el, wayMap, nodeMap, projection, context);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n        }\r\n    }\r\n\r\n    renderPoint (context, rule, point, element=null) {}\r\n\r\n    renderLine (context, rule, points, element=null) {\r\n        this.renderAreaLine(context, rule, points, getMidPoint, element);\r\n    }\r\n\r\n    renderArea (context, rule, points, element=null) {\r\n        if (points.length === 0)\r\n            return;\r\n\r\n        if (!isSelfClosing(points)) {\r\n            points = [ ...points, points[0] ];\r\n        }\r\n\r\n        this.renderAreaLine(context, rule, points, getCentrePoint, element);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {}\r\n\r\n    /**\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {[number, number][]} points\r\n     * @param {import(\"./Overpass\").OverpassElement} [element]\r\n     * @param {import(\"./Overpass\").OverpassNodeElement[]} [nodes]\r\n     */\r\n    renderPseudoElement(context, rule, points, element=null, nodes=null) {\r\n        switch (rule.selector.pseudoElement) {\r\n            case \"centre\":\r\n            case \"center\": {\r\n                // Centre of bounding box\r\n                const centrePoint = getCentrePoint(points);\r\n                this.renderPoint(context, rule, centrePoint, element);\r\n                break;\r\n            }\r\n            case \"mid-point\": {\r\n                // N/2th point (median point)\r\n                const midPoint = getMidPoint(points);\r\n                this.renderPoint(context, rule, midPoint, element);\r\n                break;\r\n            }\r\n            case \"average-point\": {\r\n                // Average of all points\r\n                const avgPoint = getAveragePoint(points);\r\n                this.renderPoint(rule, avgPoint, element, context);\r\n                break;\r\n            }\r\n            case \"start\": {\r\n                // First point\r\n                this.renderPoint(context, rule, points[0], element);\r\n                break;\r\n            }\r\n            case \"end\": {\r\n                // Last point\r\n                this.renderPoint(context, rule, points[points.length - 1], element);\r\n                break;\r\n            }\r\n            case \"centre-of-mass\": {\r\n                // TODO: calculate centre-of-mass\r\n                // const avgPoint = getCOMPoint(points);\r\n                // renderPoint(ctx, rule, avgPoint, element);\r\n                break;\r\n            }\r\n            case \"bounding-box\": {\r\n                const bounding = getBoundingBox(points);\r\n\r\n                const boundingPoints = rectToPoints(...bounding);\r\n\r\n                this.renderArea(context, rule, boundingPoints, element);\r\n                break;\r\n            }\r\n            case \"content-box\": {\r\n                const { scale } = context;\r\n                let [ x, y ] = points[0];\r\n\r\n                const content = getContent(rule, element, context);\r\n\r\n                if (!content) return;\r\n\r\n                let width = Number.NEGATIVE_INFINITY;;\r\n                let top = Number.NaN;\r\n                let bottom;\r\n                let baseline = y;\r\n                for (const line of content.split(\"\\n\")) {\r\n                    const size = this.measureText(context, rule, line);\r\n\r\n                    width = Math.max(width, size.width);\r\n\r\n                    if (isNaN(top)) top = y - size.ascending;\r\n\r\n                    bottom = baseline + size.descending;\r\n\r\n                    baseline += size.height;\r\n                }\r\n\r\n                const padding = rule.declarations[\"padding\"] ? parseFloat(rule.declarations[\"padding\"]) * scale : 0;\r\n\r\n                if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n                    x -= width / 2;\r\n                }\r\n                else if (rule.declarations[\"text-align\"] === \"right\") {\r\n                    x -= width;\r\n                }\r\n\r\n                /** @type {[number, number][]} */\r\n                const boundPoints = [\r\n                    [ x - padding,           top - padding ],     // Top Left\r\n                    [ x - padding,           bottom + padding ],    // Bottom left\r\n                    [ x + width + padding,   bottom + padding ],    // Bottom right\r\n                    [ x + width + padding,   top - padding ],     // Top Right\r\n                ];\r\n\r\n                // Close self\r\n                boundPoints.push(boundPoints[0]);\r\n\r\n                this.renderAreaLine(context, rule, boundPoints, () => points[0], element);\r\n                break;\r\n            }\r\n            case \"decimate\": {\r\n                if (rule.selector.type === \"way\") {\r\n                    const l = points.length - 1;\r\n                    const decimatedPoints = points.filter((p, i) => i % 10 === 0 || i === l);\r\n                    this.renderLine(context, rule, decimatedPoints, element);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    renderGridlines (context, rule, projection) {\r\n        const vertical = rule.selector.pseudoClasses.find(p => p.name === \"vertical\");\r\n        const horizontal = rule.selector.pseudoClasses.find(p => p.name === \"horizontal\");\r\n\r\n        const { width, height, centre, zoom } = context;\r\n\r\n        const bbox = makeBBox(centre, zoom, [width, height]);\r\n        const parts = bbox.split(\",\");\r\n\r\n        if (vertical) {\r\n            const step = parseFloat(vertical.params[0]);\r\n\r\n            const round = 1 / step;\r\n\r\n            const sigFigs = Math.ceil(Math.log10(round));\r\n\r\n            const xmin = Math.floor(+parts[0] * round) / round;\r\n            const xmax = Math.ceil(+parts[2] * round) / round;\r\n            const ymin = Math.floor(+parts[1] * round) / round;\r\n            const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n            for (let i = xmin; i <= xmax; i += step) {\r\n                const points = [ projection(i, ymin),  projection(i, (ymin + ymax) / 2), projection(i, ymax) ];\r\n                this.renderLine(context, rule, points, { type: \"way\", id: 0, nodes: [], tags: { name: i.toFixed(sigFigs) }});\r\n            }\r\n        }\r\n\r\n        if (horizontal) {\r\n            const step = parseFloat(horizontal.params[0]);\r\n\r\n            const round = 1 / step;\r\n\r\n            const sigFigs = Math.ceil(Math.log10(round));\r\n\r\n            const xmin = Math.floor(+parts[0] * round) / round;\r\n            const xmax = Math.ceil(+parts[2] * round) / round;\r\n            const ymin = Math.floor(+parts[1] * round) / round;\r\n            const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n            for (let j = ymin; j <= ymax; j += step) {\r\n                const points = [ projection(xmin, j), projection((xmin + xmax) / 2, j), projection(xmax, j) ];\r\n                this.renderLine(context, rule, points, { type: \"way\", id: 0, nodes: [], tags: { name: j.toFixed(sigFigs) }});\r\n            }\r\n        }\r\n    }\r\n\r\n    clear (context) {}\r\n\r\n    globalSetup (context, rule) { }\r\n\r\n    /**\r\n     *\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {string} text\r\n     * @return {{ width: number, ascending: number, descending: number, height: number }}\r\n     */\r\n    measureText (context, rule, text) {\r\n        return { width: 0, ascending: 0, descending: 0, height: 0 };\r\n    }\r\n}","\r\n/**\r\n * Can the string be considered a valid bbox?\r\n * - Are there four parts?\r\n * - Are they all numberic?\r\n * - Are they in the correct order?\r\n * @param {string} bbox\r\n */\r\nexport function isValid (bbox) {\r\n    const parts = bbox.split(\",\");\r\n\r\n    if (parts.length !== 4) return false;\r\n\r\n    if (parts.some(p => isNaN(+p))) return false;\r\n\r\n    return +parts[0] < +parts[2] && +parts[1] < +parts[3];\r\n}\r\n\r\n/**\r\n * Determines whether or not areaB is entirely contained\r\n * within areaA\r\n * @param {string} areaA\r\n * @param {string} areaB\r\n * @returns {boolean}\r\n */\r\nexport function contains (areaA, areaB) {\r\n    const [Ax1,Ay1,Ax2,Ay2] = areaA.split(\",\");\r\n    const [Bx1,By1,Bx2,By2] = areaB.split(\",\");\r\n\r\n    return (Bx1 >= Ax1 && By1 >= Ay1 && Bx2 <= Ax2 && By2 <= Ay2);\r\n}\r\n\r\n/**\r\n * Compute simple area\r\n * @param {string} bbox\r\n */\r\nexport function getArea (bbox) {\r\n    const parts = bbox.split(\",\");\r\n    return (+parts[2] - +parts[0]) * (+parts[3] - +parts[1]);\r\n}\r\n\r\n/**\r\n *\r\n * @param {[number, number]} centre\r\n * @param {number} zoom\r\n * @param {[number, number]} size\r\n */\r\nexport function makeBBox (centre, zoom, size) {\r\n    const baseTileSize = 256;\r\n\r\n    const [ lon, lat ] = centre;\r\n    const [ width, height ] = size;\r\n\r\n    const tileCount = Math.pow(2, zoom)\r\n    const xSpan = 180 / tileCount;\r\n    const ySpan = 180 / tileCount;\r\n\r\n    const hTileCount = width / baseTileSize;\r\n    const vTileCount = height / baseTileSize;\r\n\r\n    const dLon = xSpan * hTileCount;\r\n    const dLat = ySpan * vTileCount;\r\n\r\n    return [ lon - dLon, lat - dLat, lon + dLon, lat + dLat ].map(p => p.toFixed(3)).join(\",\");\r\n}","import { parseStrokeFill } from '../parseStrokeFill';\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {import(\"../Style\").StyleRule} rule\r\n */\r\nexport function setStrokeFill (ctx, rule, scale) {\r\n    const { fillStyle, strokeStyle, lineWidth } = parseStrokeFill(rule, scale);\r\n\r\n    ctx.fillStyle = fillStyle;\r\n    ctx.strokeStyle = strokeStyle;\r\n    ctx.lineWidth = lineWidth;\r\n}","export function parseStrokeFill(rule, scale) {\r\n    const fillStyle = rule.declarations[\"fill\"];\r\n    let strokeStyle = rule.declarations[\"stroke\"];\r\n    let lineWidth;\r\n\r\n    if (strokeStyle) {\r\n        // Numbers in e.g. rgba(128,64,0,0.2) confuse it\r\n        let mutedStyle = strokeStyle.replace(/\\([^)]*\\)/g, ss => \" \".repeat(ss.length));\r\n\r\n        // So would hex colour strings\r\n        mutedStyle = mutedStyle.replace(/#[0-9a-f]{3}/i, \"    \");\r\n        mutedStyle = mutedStyle.replace(/#[0-9a-f]{6}/i, \"       \");\r\n\r\n        /**\r\n         * @todo A better parser would probably be nice\r\n         */\r\n        const swRe = /(\\d+(?:\\.\\d+)?)\\s*(?:px)?/;\r\n        const sm = swRe.exec(mutedStyle);\r\n        if (sm) {\r\n            lineWidth = +sm[1] * scale;\r\n            strokeStyle = strokeStyle.replace(sm[0], \"\");\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"stroke-width\"]) {\r\n        lineWidth = +rule.declarations[\"stroke-width\"] * scale;\r\n    }\r\n\r\n    return {\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth,\r\n    };\r\n}","/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\nimport { setStrokeFill } from \"./setStrokeFill\";\r\nimport { getContent } from \"../getContent\";\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} param2\r\n * @param {OverpassElement} [element]\r\n */\r\nexport function renderText(ctx, rule, [x, y], element = null, context) {\r\n    setStrokeFill(ctx, rule, context.scale);\r\n\r\n    let content = getContent(rule, element, context);\r\n\r\n    setFont(ctx, rule, context.scale);\r\n\r\n    for (const line of content.split(\"\\n\")) {\r\n        y += renderLine(ctx, rule, line, x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {string} content\r\n * @param {number} x\r\n * @param {number} y\r\n */\r\nfunction renderLine(ctx, rule, content, x, y) {\r\n    const size = ctx.measureText(content);\r\n\r\n    if (rule.declarations[\"text-align\"]) {\r\n        const textWidth = size.width;\r\n\r\n        if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n            x -= textWidth / 2;\r\n        }\r\n        else if (rule.declarations[\"text-align\"] === \"right\") {\r\n            x -= textWidth;\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"text-stroke\"]) {\r\n        ctx.strokeStyle = rule.declarations[\"text-stroke\"];\r\n        ctx.strokeText(content, x, y);\r\n    }\r\n\r\n    if (rule.declarations[\"text-color\"] || !rule.declarations[\"text-stroke\"]) {\r\n        ctx.fillStyle = rule.declarations[\"text-color\"];\r\n        ctx.fillText(content, x, y);\r\n    }\r\n\r\n    const height = size.actualBoundingBoxAscent + size.actualBoundingBoxDescent;\r\n    return height;\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {number} scale\r\n */\r\nexport function setFont(ctx, rule, scale) {\r\n    let fontSize = `${10 * scale}px`;\r\n    let fontWeight = \"normal\";\r\n    let fontFamily = \"sans-serif\";\r\n\r\n    if (rule.declarations[\"font\"]) {\r\n        // It would be nice for the specific properties to override the\r\n        // shorthand, but it would complicate things a bit.\r\n        ctx.font = rule.declarations[\"font\"].replace(/\\d+(?:\\.\\d+)?/, s => `${+s * scale}`);\r\n    }\r\n    else {\r\n        if (rule.declarations[\"font-size\"]) {\r\n            fontSize = rule.declarations[\"font-size\"].replace(/^\\d[\\d.]*/, m => `${+m * scale}`);\r\n        }\r\n\r\n        if (rule.declarations[\"font-weight\"]) {\r\n            fontWeight = rule.declarations[\"font-weight\"];\r\n        }\r\n\r\n        if (rule.declarations[\"font-family\"]) {\r\n            fontFamily = rule.declarations[\"font-family\"];\r\n        }\r\n\r\n        ctx.font = `${fontWeight} ${fontSize} ${fontFamily}`;\r\n    }\r\n}\r\n","/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n */\r\nexport function applyTransform(ctx, rule, scale) {\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        const r = /\\s*([a-z]+)\\(([^)]*)\\)\\s*/g;\r\n        const t = rule.declarations[\"transform\"];\r\n        let m;\r\n        while (m = r.exec(t)) {\r\n            const trans = m[1];\r\n            const params = m[2].split(\",\").map(s => ({ value: parseFloat(s) * scale, unit: s.replace(/[-\\d.\\s]/g, \"\") }));\r\n            switch (trans) {\r\n                case \"matrix\":\r\n                    // @ts-ignore\r\n                    ctx.transform(...params.map(p => p.value));\r\n                    break;\r\n                case \"rotate\": {\r\n                    let { value, unit } = params[0];\r\n\r\n                    if (unit === \"deg\") {\r\n                        value *= Math.PI / 180;\r\n                    } else if (unit === \"turn\") {\r\n                        value *= Math.PI * 2;\r\n                    }\r\n\r\n                    ctx.rotate(value);\r\n                    break;\r\n                }\r\n                case \"scale\":\r\n                    const x = params[0].value;\r\n                    const y = params[1] ? params[1].value : x;\r\n                    ctx.scale(x, y);\r\n                    break;\r\n                case \"translate\":\r\n                    // @ts-ignore\r\n                    ctx.translate(...params.map(p => p.value));\r\n                    break;\r\n                case \"skew\":\r\n                    let { value, unit } = params[0];\r\n\r\n                    if (unit === \"rad\")\r\n                        value = Math.tan(value);\r\n                    else if (unit === \"deg\")\r\n                        value = Math.tan(value * Math.PI / 180);\r\n\r\n                    let valueY = 0;\r\n\r\n                    if (params[1]) {\r\n                        let { value, unit } = params[1];\r\n\r\n                        if (unit === \"rad\")\r\n                            value = Math.tan(value);\r\n                        else if (unit === \"deg\")\r\n                            value = Math.tan(value * Math.PI / 180);\r\n\r\n                        valueY = value;\r\n                    }\r\n\r\n                    ctx.transform(1, valueY, value, 1, 0, 0);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { renderText } from \"./renderText\";\r\nimport { applyTransform } from \"./transform\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} position\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderPoint(ctx, rule, [x, y], element = null, context = {}) {\r\n    ctx.save();\r\n\r\n    const { scale } = context;\r\n\r\n    ctx.fillStyle = rule.declarations[\"fill\"];\r\n    ctx.strokeStyle = rule.declarations[\"stroke\"];\r\n    ctx.lineWidth = +rule.declarations[\"stroke-width\"] * scale;\r\n\r\n    if (rule.declarations[\"position\"] === \"absolute\") {\r\n        x = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n        y = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n    }\r\n    ctx.translate(x, y);\r\n\r\n    applyTransform(ctx, rule, scale);\r\n\r\n    if (rule.declarations[\"size\"]) {\r\n        ctx.beginPath();\r\n\r\n        const r = +rule.declarations[\"size\"] * scale;\r\n\r\n        ctx.ellipse(0, 0, r, r, 0, 0, Math.PI * 2);\r\n\r\n        rule.declarations[\"fill\"] && ctx.fill();\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    if (rule.declarations[\"path\"]) {\r\n        ctx.beginPath();\r\n\r\n        drawPath(ctx, rule.declarations[\"path\"], scale);\r\n\r\n        rule.declarations[\"fill\"] && ctx.fill();\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    // Syntax:\r\n    //  url(<URL>) [<width> [<height>]]\r\n    //  url(https://ijmacd.github.io/map-maker/logo192.png) 90px 120px;\r\n    const urlRe = /url\\(([^)]+)\\)(?:\\s+([^\\s]+)(?:\\s+([^\\s]+))?)?/;\r\n    if (urlRe.test(rule.declarations[\"icon\"])) {\r\n        const m = urlRe.exec(rule.declarations[\"icon\"]);\r\n        const url = m[1];\r\n        const img = new Image();\r\n        img.src = url;\r\n        const w = parseFloat(m[2]);\r\n        const h = parseFloat(m[3]);\r\n\r\n\r\n        img.addEventListener(\"load\", () => {\r\n            // The image is drawn in a callback so the render context state is lost\r\n            ctx.save();\r\n            // globalSetup(ctx, rule);\r\n\r\n            ctx.translate(x, y);\r\n\r\n            // applyTransform(ctx, rule);\r\n\r\n            if (w) {\r\n                const height = !isNaN(h) ? h : img.height * (w / img.width);\r\n                ctx.drawImage(img, 0, 0, w * scale, height * scale);\r\n            }\r\n            else {\r\n                ctx.drawImage(img, 0, 0);\r\n            }\r\n\r\n            ctx.restore();\r\n        });\r\n    }\r\n\r\n    if (rule.declarations[\"content\"]) {\r\n        renderText(ctx, rule, [0, 0], element, context);\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {string} pathSpec\r\n */\r\nfunction drawPath (ctx, pathSpec, scale) {\r\n    const segs = /([MLQCVHZ])\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?/ig;\r\n    let match;\r\n    /** @type {[number, number]} */\r\n    let first;\r\n    /** @type {[number, number]} */\r\n    let prev;\r\n\r\n    while (match = segs.exec(pathSpec)) {\r\n        const x = parseFloat(match[2]) * scale;\r\n        const y = parseFloat(match[3]) * scale;\r\n        const x2 = parseFloat(match[4]) * scale;\r\n        const y2 = parseFloat(match[5]) * scale;\r\n        const x3 = parseFloat(match[6]) * scale;\r\n        const y3 = parseFloat(match[7]) * scale;\r\n\r\n        if (!first) first = [x,y];\r\n\r\n        if (match[1] === \"M\") {\r\n            prev = [x,y];\r\n            ctx.moveTo(x, y);\r\n        }\r\n        else if (match[1] === \"L\") {\r\n            prev = [x,y];\r\n            ctx.lineTo(x, y);\r\n        }\r\n        else if (match[1] === \"Q\") {\r\n            prev = [x2,y2];\r\n            ctx.quadraticCurveTo(x, y, x2, y2);\r\n        }\r\n        else if (match[1] === \"C\") {\r\n            prev = [x3,y3];\r\n            ctx.bezierCurveTo(x, y, x2, y2, x3, y3);\r\n        }\r\n        else if (match[1] === \"Z\") {\r\n            prev = first;\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"V\") {\r\n            prev = [prev[0], x];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"H\") {\r\n            prev = [x, prev[1]];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"m\") {\r\n            prev = [prev[0] + x, prev[1] + y];\r\n            ctx.moveTo(...prev);\r\n        }\r\n        else if (match[1] === \"l\") {\r\n            prev = [prev[0] + x, prev[1] + y];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"q\") {\r\n            ctx.quadraticCurveTo(prev[0] + x, prev[1] + y, prev[0] + x2, prev[1] + y2);\r\n            prev = [prev[0] + x2, prev[1] + y2];\r\n        }\r\n        else if (match[1] === \"c\") {\r\n            prev = [x3,y3];\r\n            ctx.bezierCurveTo(prev[0] + x, prev[1] + y, prev[0] + x2, prev[1] + y2, prev[0] + x3, prev[1] + y3);\r\n            prev = [prev[0] + x3, prev[1] + y3];\r\n        }\r\n        else if (match[1] === \"z\") {\r\n            prev = first;\r\n            ctx.lineTo(...first);\r\n        }\r\n        else if (match[1] === \"v\") {\r\n            prev = [prev[0], prev[1] + x];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"h\") {\r\n            prev = [prev[0] + x, prev[1]];\r\n            ctx.lineTo(...prev);\r\n        }\r\n    }\r\n}","export default class CollisionSystem {\r\n    /** @type {CollisionSystem} */\r\n    static singleton;\r\n\r\n    constructor () {\r\n        /** @type {{ [name: string]: [number, number, number, number][] }} */\r\n        this.sets = {}\r\n    }\r\n\r\n    clear () {\r\n        this.sets = {};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} set\r\n     * @param {[number, number, number, number]} box\r\n     */\r\n    add (set, box) {\r\n        if (!this.sets[set]) this.sets[set] = [];\r\n\r\n        for (const other of this.sets[set]) {\r\n            if (intersects(box, other)) return false;\r\n        }\r\n\r\n        this.sets[set].push(box);\r\n\r\n        return true;\r\n    }\r\n\r\n    static getCollisionSystem () {\r\n        if (!this.singleton) {\r\n            this.singleton = new CollisionSystem();\r\n        }\r\n\r\n        return this.singleton;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * [x , y, width, height]\r\n * @param {[number, number, number, number]} boxA\r\n * @param {[number, number, number, number]} boxB\r\n */\r\nfunction intersects (boxA, boxB) {\r\n    const ax1 = boxA[0];\r\n    const ay1 = boxA[1];\r\n    const ax2 = boxA[0] + boxA[2];\r\n    const ay2 = boxA[1] + boxA[3];\r\n    const bx1 = boxB[0];\r\n    const by1 = boxB[1];\r\n    const bx2 = boxB[0] + boxB[2];\r\n    const by2 = boxB[1] + boxB[3];\r\n    return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;\r\n}","import { renderPoint } from \"./renderPoint\";\r\nimport { applyTransform } from \"./transform\";\r\nimport { setStrokeFill } from \"./setStrokeFill\";\r\nimport { getBoundingBox } from \"../util\";\r\nimport CollisionSystem from \"../CollisionSystem\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {(points: [number, number][]) => [number, number]} getPoint\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderAreaLine(ctx, rule, points, getPoint, element = null, context = {}) {\r\n    if (points.length === 0)\r\n        return;\r\n\r\n\r\n    if (rule.declarations[\"collision-set\"]) {\r\n        const box = getBoundingBox(points);\r\n\r\n        if (rule.declarations[\"collision-size\"]) {\r\n            const s = /(\\d+\\.?\\d*)%/.exec(rule.declarations[\"collision-size\"]);\r\n\r\n            const scaleFactor = +s[1] / 100;\r\n            const w = box[2];\r\n            const h = box[3];\r\n\r\n            box[0] += (1 - scaleFactor) * w / 2;\r\n            box[1] += (1 - scaleFactor) * h / 2;\r\n            box[2] = w * scaleFactor;\r\n            box[3] = h * scaleFactor;\r\n        }\r\n\r\n        const collisionSystem = CollisionSystem.getCollisionSystem();\r\n\r\n        if (!collisionSystem.add(rule.declarations[\"collision-set\"], box)) {\r\n            const policy = rule.declarations[\"collision-policy\"] || \"hide\";\r\n\r\n            if (policy === \"hide\") {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    ctx.save();\r\n\r\n    setStrokeFill(ctx, rule, context.scale);\r\n\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        // Extra work required if we're transforming\r\n\r\n        // First get transform origin;\r\n        const cp = getPoint(points);\r\n\r\n        // Set offset to adjust all points later\r\n        offsetX = cp[0];\r\n        offsetY = cp[1];\r\n\r\n        // Translate the canvas\r\n        ctx.translate(offsetX, offsetY);\r\n\r\n        // Apply the transformation\r\n        applyTransform(ctx, rule, context.scale);\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(points[0][0] - offsetX, points[0][1] - offsetY);\r\n    for (let i = 1; i < points.length; i++) {\r\n        ctx.lineTo(points[i][0] - offsetX, points[i][1] - offsetY);\r\n    }\r\n\r\n    rule.declarations[\"fill\"] && ctx.fill();\r\n    rule.declarations[\"stroke\"] && ctx.stroke();\r\n\r\n    ctx.restore();\r\n\r\n    // Text Handling, Icons etc.\r\n    if (rule.declarations[\"content\"] || rule.declarations[\"size\"] || rule.declarations[\"path\"] || rule.declarations[\"icon\"]) {\r\n        ctx.save();\r\n        renderPoint(ctx, rule, getPoint(points), element, context);\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\n\r\n","import CanvasRender from './canvas-render';\r\n\r\n/** @type {OffscreenCanvas} */\r\nlet canvas;\r\n/** @type {import('./MapRenderer').default} */\r\nlet renderer;\r\n\r\nonmessage = (msg) => {\r\n    if (msg.data.canvas) {\r\n        canvas = msg.data.canvas;\r\n        renderer = new CanvasRender(canvas);\r\n    }\r\n\r\n    if (msg.data.method === \"clear\") {\r\n        const { context: { width, height } } = msg.data;\r\n\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        canvas.getContext(\"2d\").fillRect(0, 0, width, height);\r\n    }\r\n\r\n    if (msg.data.method === \"renderRule\") {\r\n        const { context, rule, elements } = msg.data;\r\n\r\n        renderer.renderRule(context, rule, elements);\r\n    }\r\n};","import MapRenderer from \"../MapRenderer\";\r\nimport { renderPoint } from \"./renderPoint\";\r\nimport { setFont } from \"./renderText\";\r\nimport { renderAreaLine } from \"./renderAreaLine\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n\r\nexport default class CanvasRender extends MapRenderer {\r\n\r\n    /**\r\n     * @param {HTMLCanvasElement|OffscreenCanvas} canvas\r\n     */\r\n    constructor (canvas) {\r\n        super();\r\n        this.canvas = canvas;\r\n    }\r\n\r\n    clear (context) {\r\n        const { width, height } = context;\r\n\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n    }\r\n\r\n    renderRule (context, rule, elements=[]) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        ctx.save();\r\n        super.renderRule(context, rule, elements);\r\n        ctx.restore();\r\n    }\r\n\r\n    globalSetup({ scale }, rule) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n\r\n        if (rule.declarations[\"opacity\"])\r\n            ctx.globalAlpha = +rule.declarations[\"opacity\"];\r\n\r\n        if (rule.declarations[\"position\"] === \"relative\") {\r\n            const top = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n            const left = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n\r\n            ctx.translate(left, top);\r\n        }\r\n    }\r\n\r\n    renderPoint (context, rule, point, element=null) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        renderPoint(ctx, rule, point, element, context);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        renderAreaLine(ctx, rule, points, getPoint, element, context);\r\n    }\r\n\r\n    measureText (context, rule, text) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        const { scale } = context;\r\n        setFont(ctx, rule, scale);\r\n        const size = ctx.measureText(text);\r\n        const { width, actualBoundingBoxDescent: descending, actualBoundingBoxAscent: ascending } = size;\r\n\r\n        return {\r\n            width,\r\n            ascending,\r\n            descending,\r\n            height: ascending + descending,\r\n        };\r\n    }\r\n}\r\n\r\n","import setPrototypeOf from \"./setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","import getPrototypeOf from \"./getPrototypeOf\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn\";\nexport default function _createSuper(Derived) {\n  return function () {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (isNativeReflectConstruct()) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}"],"sourceRoot":""}