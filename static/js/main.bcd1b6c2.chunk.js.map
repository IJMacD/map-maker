{"version":3,"sources":["const.js","useSavedState.js","Style.js","util.js","geometry.js","matchPseudoClasses.js","canvas-render/getContent.js","bbox.js","MapRenderer.js","parseStrokeFill.js","canvas-render/setStrokeFill.js","canvas-render/renderText.js","canvas-render/transform.js","canvas-render/renderPoint.js","CollisionSystem.js","canvas-render/renderAreaLine.js","canvas-render/index.js","svg-render/renderAreaLine.js","svg-render/index.js","database.idb.js","Overpass.js","useDebounce.js","Textarea.js","App.js","useGeolocation.js","serviceWorker.js","index.js"],"names":["API_ROOT","useSavedState","key","initalState","React","useState","saved","localStorage","getItem","JSON","parse","e","state","setState","newState","setItem","stringify","StyleSelector","type","tags","pseudoClasses","pseudoElement","this","Object","entries","map","k","v","join","matchSelector","selector","element","match","value","parseMedia","mediaText","match2","re","out","mediaQueries","index","re2","exec","predicate","makePredicate","length","parseRules","substring","rules","push","console","log","ruleText","declarations","split","s","trim","filter","forEach","i","indexOf","property","selectors","parseMultiple","expandRules","context","rule","testPredicate","left","operator","right","Function","op","COMPARE","text","m","tagText","m2","re3","m3","params","test","name","re4","m4","x","a","b","timeout","duration","Promise","resolve","setTimeout","mercatorProjection","centre","scale","width","height","cLon","cLat","tileCount","Math","pow","hPixelsPerDeg","vPixelsPerDeg","QUARTER_PI","PI","cX","cY","cLatPrime","tan","lon","lat","E","N","getAveragePoint","points","reduce","sum","p","getCentrePoint","boundingBox","getBoundingBox","getMidPoint","floor","minMax","point","min","max","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","rectToPoints","y","getCrossProductArea","getArea","abs","isAntiClockwise","isConvex","l","sign","c","next","isSelfClosing","f","getLength","dx","dy","sqrt","matchPseudoClasses","nodes","includesPseudoClass","hasPseudoClasses","pc","elementContext","area","some","getContent","content","replace","contains","areaA","areaB","Ax1","Ay1","Ax2","Ay2","Bx1","By1","Bx2","By2","bbox","parts","makeBBox","zoom","size","dLon","dLat","toFixed","MapRenderer","elements","nodeMap","n","id","wayMap","projection","globalSetup","renderPseudoElement","renderArea","current","coords","renderPoint","longitude","latitude","renderGridlines","el","renderLine","renderAreaLine","getPoint","centrePoint","midPoint","avgPoint","bounding","boundingPoints","measureText","ascending","descending","padding","parseFloat","boundPoints","decimatedPoints","vertical","find","horizontal","step","round","sigFigs","ceil","log10","xmin","xmax","ymin","ymax","j","parseStrokeFill","lineWidth","fillStyle","strokeStyle","mutedStyle","ss","repeat","sm","setStrokeFill","ctx","renderText","setFont","textWidth","strokeText","fillText","fontSize","fontWeight","fontFamily","font","applyTransform","r","t","trans","unit","transform","rotate","translate","valueY","save","beginPath","ellipse","fill","stroke","drawPath","urlRe","url","img","Image","src","w","h","addEventListener","isNaN","drawImage","restore","pathSpec","first","prev","segs","x2","y2","x3","y3","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","CollisionSystem","sets","set","box","intersects","singleton","boxA","boxB","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","collisionSystem","getCollisionSystem","add","policy","offsetX","offsetY","cp","CanvasRender","canvas","getContext","globalAlpha","top","actualBoundingBoxDescent","actualBoundingBoxAscent","layer","path","d","SVGRender","layers","currentLayer","colours","layerSetup","getTextParts","Blob","attr","attributes","opacity","IDBElementDatabase","request","indexedDB","open","ev","db","target","result","createObjectStore","keyPath","createIndex","unique","reject","store","transaction","objectStore","put","get","ids","all","getNode","makeKey","getElementsByKey","range","IDBKeyRange","bound","MAX_VALUE","openKeyCursor","count","bboxOversizeArea","cursor","primaryKey","keyBBox","keyArea","debug","toString","continue","record","bkey","require","overpassRe","recurRe","Overpass","Map","database","fetchMap","currentJob","clear","jobs","mapSelector","keys","has","searchElements","then","els","tryQuery","values","rels","slice","ways","refs","members","ref","way","saveElements","cached","Date","now","Error","sMap","mapSelectorForQuery","query","clamp","clampBBox","fetch","ok","json","status","finally","tries","catch","getElements","dbResult","dbSearchResult","delete","fn","recur","useDebounce","delay","debouncedValue","setDebouncedValue","useEffect","handler","clearTimeout","Textarea","onChange","otherProps","onKeyDown","event","currentTarget","shiftKey","preventDefault","selectionStart","lineStart","lastIndexOf","substr","newValue","setSelectionRange","addIndent","newPos","App","style","setStyle","setCentre","setZoom","loc","setLoc","navigator","geolocation","getCurrentPosition","watchPosition","clearWatch","useGeolocation","canvasRef","useRef","overpassRef","setStatus","error","setError","downloading","setDownloading","progress","setProgress","clientWidth","clientHeight","devicePixelRatio","debouncedCentre","debouncedZoom","useMemo","debouncedStyle","parsedStyle","styleText","rulesResult","mediaResult","parseStyle","setBBox","move","dX","dY","bb","stepSizeX","stepSizeY","newCentre","cleanup","handleDownload","cb","callback","toBlob","blob","blobDownload","downloadPNG","downloadSVG","useDeepCompareEffect","currentEffect","preLoadElements","promise","renderer","item","prefix","renderRule","run","className","onClick","disabled","flex","spellCheck","color","overpass","svgRender","filename","URL","createObjectURL","document","createElement","download","href","body","appendChild","click","removeChild","revokeObjectURL","Boolean","window","location","hostname","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.bcd1b6c2.chunk.js","sourcesContent":["\r\nexport const API_ROOT = \"https://lz4.overpass-api.de/api/interpreter\";","import React from 'react';\r\n\r\n/**\r\n * @template T\r\n * @param {string} key \r\n * @param {T} initalState \r\n * @returns {[ T, (newState: T) => void ]}\r\n */\r\nexport default function useSavedState (key, initalState) {\r\n    const [ state, setState ] = React.useState(() => {\r\n        const saved = localStorage.getItem(key);\r\n    \r\n        if (saved) {\r\n            try {\r\n                initalState = JSON.parse(saved);\r\n            } catch (e) {}\r\n        }\r\n\r\n        return initalState;\r\n    });\r\n\r\n    return [\r\n        state,\r\n        newState => {\r\n            localStorage.setItem(key, JSON.stringify(newState));\r\n            setState(newState);\r\n        }\r\n    ]\r\n}","/**\r\n * @typedef StyleRule\r\n * @property {\"rule\"} type\r\n * @property {StyleSelector} [selector]\r\n * @property {StyleSelector[]} [selectors]\r\n * @property {{ [key: string]: string }} declarations\r\n */\r\n\r\n/**\r\n * @typedef MediaQuery\r\n * @property {\"query\"} type\r\n * @property {Predicate} predicate\r\n * @property {StyleRule[]} rules\r\n */\r\n\r\n/**\r\n * @typedef Predicate\r\n * @property {string|number|Predicate} left\r\n * @property {string} operator\r\n * @property {string|number|Predicate} right\r\n */\r\n\r\nexport class StyleSelector {\r\n    /**\r\n     * @param {string} type\r\n     * @param {{ [key: string]: string }} tags\r\n     * @param {{ name: string, params: (string|Predicate)[] }[]} pseudoClasses\r\n     * @param {string} [pseudoElement]\r\n     */\r\n    constructor (type, tags, pseudoClasses=[], pseudoElement=null) {\r\n      this.type = type;\r\n      this.tags = tags;\r\n      this.pseudoClasses = pseudoClasses;\r\n      this.pseudoElement = pseudoElement;\r\n    }\r\n\r\n    toString () {\r\n      return `${this.type}${Object.entries(this.tags).map(([k,v]) => `[${k}=${v}]`).join(\"\")}`;\r\n    }\r\n}\r\n\r\nStyleSelector.parse = /**\r\n * @param {string} text\r\n */\r\nfunction (text) {\r\n    const re = /^\\s*([a-z]+)/;\r\n    const m = re.exec(text);\r\n\r\n    if (!m) return null;\r\n\r\n    let type = m[1];\r\n\r\n    if (type === \"rel\") {\r\n      type = \"relation\";\r\n    }\r\n\r\n    /** @type {{ [key: string]: string }} */\r\n    const tags = {};\r\n\r\n    let tagText = text.substring(m[0].length).trim();\r\n\r\n    const re2 = /^\\[([^[\\]=]+)=([^[\\]=]+)\\]/;\r\n\r\n    while (true) {\r\n      const m2 = re2.exec(tagText);\r\n\r\n      if (!m2) break;\r\n\r\n      tags[m2[1]] = m2[2];\r\n\r\n      tagText = tagText.substring(m2[0].length);\r\n    }\r\n\r\n    /** @type {{ name: string, params: (string|Predicate)[] }[]} */\r\n    const pseudoClasses = [];\r\n\r\n    const re3 = /^:([a-z-]+)(?:\\(([^)]+)\\))?/;\r\n\r\n    while (true) {\r\n      const m3 = re3.exec(tagText);\r\n\r\n      if (!m3) break;\r\n\r\n      const re = /^\\s*([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?/;\r\n      const params = m3[2] ? m3[2].split(\",\").map(s => re.test(s) ? makePredicate(re.exec(s)) : s) : [];\r\n      pseudoClasses.push({ name: m3[1], params });\r\n\r\n      tagText = tagText.substring(m3[0].length);\r\n    }\r\n\r\n    let pseudoElement = null;\r\n\r\n    const re4 = /^::([a-z-]+)?/;\r\n\r\n    if (re4.test(tagText)) {\r\n      const m4 = re4.exec(tagText);\r\n\r\n      pseudoElement = m4[1];\r\n\r\n      tagText = tagText.substring(m4[0].length);\r\n    }\r\n\r\n    if (tagText.length) {\r\n      console.log(`Invalid selector: ${text} unexpected part: '${tagText}'`);\r\n      return null;\r\n    }\r\n\r\n    return new StyleSelector(type, tags, pseudoClasses, pseudoElement);\r\n};\r\n\r\n/**\r\n *\r\n * @param {string} text\r\n */\r\nStyleSelector.parseMultiple = function (text) {\r\n    return text.split(\",\").map(StyleSelector.parse).filter(x => x);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{ rules: StyleRule[] }} style\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @returns {StyleRule}\r\n */\r\nexport function matchRule (style, element) {\r\n    for (const rule of style.rules) {\r\n      for (const selector of rule.selectors) {\r\n        if (matchSelector(selector, element))  return rule;\r\n      }\r\n    }\r\n}\r\n\r\n/**\r\n * @param {StyleSelector} selector\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n */\r\nexport function matchSelector (selector, element) {\r\n  if (element.type !== selector.type && !(selector.type === \"area\" && element.type === \"way\")) return false;\r\n\r\n  let match = true;\r\n\r\n  for (const [key, value] of Object.entries(selector.tags)) {\r\n    if (!element.tags || element.tags[key] !== value) {\r\n      match = false;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return match;\r\n}\r\n\r\n/**\r\n * @param {string} styleText\r\n */\r\nexport function parseStyle (styleText) {\r\n  /** @type {{ rules: (StyleRule|MediaQuery)[] }} */\r\n  const out = { rules: [] };\r\n\r\n  let length = styleText.length;\r\n\r\n  while (length > 0) {\r\n\r\n    // Try parsing rule list\r\n    const rulesResult = parseRules(styleText);\r\n    out.rules.push(...rulesResult.rules);\r\n    styleText = styleText.substring(rulesResult.index).trim();\r\n\r\n    // Try parsing media query\r\n    const mediaResult = parseMedia(styleText);\r\n    out.rules.push(...mediaResult.mediaQueries);\r\n    styleText = styleText.substring(mediaResult.index).trim();\r\n\r\n    if (styleText.length === length) {\r\n      console.log(\"Got stuck parsing style at: \" + styleText);\r\n      break;\r\n    }\r\n\r\n    length = styleText.length;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * @param {string} mediaText\r\n */\r\nfunction parseMedia (mediaText) {\r\n  const re = /^\\s*@match\\s*\\(([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?\\)\\s*{/;\r\n  /** @type {{ mediaQueries: MediaQuery[], index: number }} */\r\n  const out = { mediaQueries: [], index: 0 };\r\n  let match;\r\n\r\n  const re2 = /^\\s*}/;\r\n  let match2;\r\n\r\n  while (match = re.exec(mediaText)) {\r\n    const predicate = makePredicate(match);\r\n\r\n    out.index += match[0].length;\r\n\r\n    mediaText = mediaText.substring(match[0].length);\r\n\r\n    const { rules, index } = parseRules(mediaText);\r\n\r\n    out.index += index;\r\n\r\n    mediaText = mediaText.substring(index);\r\n\r\n    match2 = re2.exec(mediaText);\r\n\r\n    if (match2) {\r\n      out.mediaQueries.push({\r\n        type: \"query\",\r\n        predicate,\r\n        rules,\r\n      });\r\n\r\n      out.index += match2[0].length;\r\n\r\n    } else {\r\n      console.log(\"Unterminated media query\");\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nfunction parseRules (ruleText) {\r\n  const re = /^\\s*([^{}]+)\\s*{([^{}]*)}/;\r\n  let match;\r\n  /** @type {{ rules: StyleRule[], index: number }} */\r\n  const out = { rules: [], index: 0 };\r\n\r\n  while(match = re.exec(ruleText)) {\r\n    /** @type {{ [key: string]: string }} */\r\n    const declarations = {};\r\n\r\n    match[2].split(\";\").map(s => s.trim()).filter(s => s).forEach(s => {\r\n      // s.split(\":\", 2) is not the same as PHP\r\n      const i = s.indexOf(\":\");\r\n      const property = s.substring(0,i).trim();\r\n      const value = s.substring(i+1).trim();\r\n      declarations[property] = value;\r\n    });\r\n\r\n    const selectors = StyleSelector.parseMultiple(match[1]);\r\n\r\n    if (selectors.length) {\r\n      out.rules.push({\r\n        type: \"rule\",\r\n        selectors,\r\n        declarations,\r\n      });\r\n    }\r\n\r\n    out.index += match[0].length;\r\n\r\n    ruleText = ruleText.substring(match[0].length);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n *\r\n * @param {(StyleRule|MediaQuery)[]} rules\r\n * @param {object} context\r\n * @returns {StyleRule[]}\r\n */\r\nexport function expandRules (rules, context) {\r\n  /** @type {StyleRule[]} */\r\n  const out = [];\r\n  for (const rule of rules) {\r\n    if (rule.type === \"rule\") {\r\n      const { declarations } = rule;\r\n      for (const selector of rule.selectors) {\r\n        out.push({ type: \"rule\", selector, declarations });\r\n      }\r\n    } else {\r\n      if (testPredicate(rule.predicate, context)) {\r\n        out.push(...expandRules(rule.rules, context));\r\n      }\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction makePredicate(match) {\r\n  let predicate;\r\n\r\n  if (match[4]) {\r\n    // MediaQueries4 syntax:\r\n    //  @match (10 < zoom <= 14)\r\n    predicate = {\r\n      left: { left: match[1], operator: match[2], right: match[3] },\r\n      operator: \"and\",\r\n      right: { left: match[3], operator: match[4], right: match[5] },\r\n    };\r\n  }\r\n  else {\r\n    // MediaQueries4 syntax:\r\n    //  @match (zoom <= 14)\r\n    // MediaQueries3 syntax:\r\n    //  @match (max-zoom: 14) [TODO - it's parsed just not handled correctly]\r\n    predicate = {\r\n      left: match[1],\r\n      operator: match[2],\r\n      right: match[3],\r\n    };\r\n  }\r\n  return predicate;\r\n}\r\n\r\n/**\r\n *\r\n * @param {Predicate} predicate\r\n * @param {object} [context]\r\n * @returns {boolean}\r\n */\r\nexport function testPredicate (predicate, context={}) {\r\n  let left = typeof predicate.left === \"string\" || typeof predicate.left === \"number\" ?\r\n    predicate.left : testPredicate(predicate.left, context);\r\n  let right = typeof predicate.right === \"string\" || typeof predicate.right === \"number\"  ?\r\n    predicate.right : testPredicate(predicate.right, context);\r\n\r\n  if (typeof left === \"string\" && left in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[left] instanceof Function)\r\n      context[left] = context[left]();\r\n\r\n    left = context[left];\r\n  }\r\n\r\n  if (typeof right === \"string\" && right in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[right] instanceof Function)\r\n      context[right] = context[right]();\r\n\r\n    right = context[right];\r\n  }\r\n\r\n  const op = COMPARE[predicate.operator];\r\n\r\n  if (!op) return false;\r\n\r\n  return op(left, right);\r\n}\r\n\r\nconst COMPARE = {\r\n  \":\": (a,b) => a == b,\r\n  \"=\": (a,b) => a == b,\r\n  \">\": (a,b) => a > b,\r\n  \"<\": (a,b) => a < b,\r\n  \">=\": (a,b) => a >= b,\r\n  \"<=\": (a,b) => a <= b,\r\n  \"and\": (a,b) => a && b,\r\n  \"or\": (a,b) => a || b,\r\n}","/**\r\n * Promise based timeout\r\n * @param {number} duration\r\n */\r\nexport function timeout (duration) {\r\n    return new Promise(resolve => setTimeout(resolve, duration));\r\n}\r\n\r\n/**\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n * @param {number} minLon\r\n * @param {number} minLat\r\n * @param {number} maxLon\r\n * @param {number} maxLat\r\n * @param {number} width\r\n * @param {number} height\r\n */\r\nexport function flatProjection(minLon, minLat, maxLon, maxLat, width, height) {\r\n    const xScale = width / (maxLon - minLon);\r\n    const yScale = height / (maxLat - minLat);\r\n    const scale = Math.max(xScale, yScale);\r\n    return ((lon, lat) => [(lon - minLon) * scale, height - (lat - minLat) * scale]);\r\n}\r\n/**\r\n * @param {[number, number]} centre\r\n * @param {number} scale\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n */\r\nexport function mercatorProjection(centre, scale, width, height) {\r\n    const baseTileSize = 256;\r\n\r\n    const [cLon, cLat] = centre;\r\n\r\n    const tileCount = Math.pow(2, scale);\r\n    const degPerTileH = 180 / tileCount;\r\n    const degPerTileV = 180 / tileCount;\r\n\r\n    const hPixelsPerDeg = baseTileSize / degPerTileH;\r\n    const vPixelsPerDeg = baseTileSize / degPerTileV;\r\n\r\n    const QUARTER_PI = Math.PI / 4;\r\n\r\n    const cX = width / 2;\r\n    const cY = height / 2;\r\n\r\n    const cLatPrime = Math.log(Math.tan(QUARTER_PI + (cLat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n    return (lon, lat) => {\r\n        const E = lon;\r\n        const N = Math.log(Math.tan(QUARTER_PI + (lat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n        const dLon = E - cLon;\r\n        const dLat = N - cLatPrime;\r\n\r\n        const dX = dLon * hPixelsPerDeg;\r\n        const dY = dLat * vPixelsPerDeg;\r\n\r\n        return [cX + dX, cY - dY];\r\n    };\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n */\r\n\r\nexport function getAveragePoint(points) {\r\n    const sum = points.reduce((sum, p) => [sum[0] + p[0], sum[1] + p[1]], [0, 0]);\r\n    /** @type {[number, number]} */\r\n    const avg = (sum.map(x => x / points.length));\r\n    return avg;\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n * @returns {[number, number]}\r\n */\r\n\r\nexport function getCentrePoint(points) {\r\n    const boundingBox = getBoundingBox(points);\r\n\r\n    return [\r\n        boundingBox[0] + boundingBox[2] / 2,\r\n        boundingBox[1] + boundingBox[3] / 2,\r\n    ];\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n * @returns {[number, number]}\r\n */\r\n\r\nexport function getMidPoint(points) {\r\n    return points[Math.floor((points.length - 1) / 2)];\r\n}\r\n/**\r\n * @param {[number, number][]} points\r\n * @returns {[number, number, number, number]} (x, y, width, height)\r\n */\r\n\r\nexport function getBoundingBox(points) {\r\n    const minMax = points.reduce((minMax, point) => {\r\n        return [\r\n            Math.min(minMax[0], point[0]),\r\n            Math.min(minMax[1], point[1]),\r\n            Math.max(minMax[2], point[0]),\r\n            Math.max(minMax[3], point[1]),\r\n        ];\r\n    }, [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]);\r\n\r\n    return [\r\n        minMax[0],\r\n        minMax[1],\r\n        minMax[2] - minMax[0],\r\n        minMax[3] - minMax[1],\r\n    ];\r\n}\r\n","\r\n/**\r\n * \r\n * @param {number} x \r\n * @param {number} y \r\n * @param {number} width \r\n * @param {number} height \r\n * @returns {[number, number][]}\r\n */\r\nexport function rectToPoints(x, y, width, height) {\r\n    /** @type {[number, number][]} */\r\n    return [\r\n        [x, y],\r\n        [x, y + height],\r\n        [x + width, y + height],\r\n        [x + width, y],\r\n    ];\r\n}\r\n\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points \r\n */\r\nexport function getCrossProductArea (points) {\r\n    let sum = 0;\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n        sum += points[i][0] * points[i+1][1] - points[i+1][0] * points[i][1];\r\n    }\r\n    return sum / 2;\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getArea (points) {\r\n    return Math.abs(getCrossProductArea(points));\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isAntiClockwise (points) {\r\n    return getCrossProductArea(points) > 0;\r\n}\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points\r\n */\r\nexport function isConvex (points) {\r\n    const l = points.length;\r\n    if (l < 3) return;\r\n\r\n    let sign = 0;\r\n    for (let i = 1; i < l; i++) {\r\n        const a = points[i-1];\r\n        const b = points[i];\r\n        const c = points[(i+1) % l];\r\n        \r\n        const next = Math.sign((b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]));\r\n\r\n        if (sign === 0) sign = next;\r\n        else if (next !== 0 && sign !== next) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isSelfClosing (points) {\r\n    const f = points[0];\r\n    const l = points[points.length - 1]; \r\n    return f[0] === l[0] && f[1] === l[1];\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getLength (points) {\r\n    let sum = 0;\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n        const dx = points[i][0] - points[i-1][0];\r\n        const dy = points[i][1] - points[i-1][1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    return sum;\r\n}","import { getArea, isConvex, isAntiClockwise, getLength } from \"./geometry\";\r\nimport { testPredicate } from \"./Style\";\r\nimport { getBoundingBox } from \"./util\";\r\n\r\n/** @typedef {import(\"./Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"./Overpass\").OverpassElement} OverpassElement */\r\n\r\n\r\n/**\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @param {import(\"./Overpass\").OverpassElement[]} nodes\r\n */\r\nexport function matchPseudoClasses(rule, points, element=null, nodes = null) {\r\n    const { selector } = rule;\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"convex\")) {\r\n        if (!isConvex(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"concave\")) {\r\n        if (isConvex(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"clockwise\")) {\r\n        if (isAntiClockwise(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"anti-clockwise\")) {\r\n        if (!isAntiClockwise(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"self-closing\")) {\r\n        if (nodes[0] !== nodes[points.length - 1])\r\n            return false;\r\n    }\r\n\r\n    const hasPseudoClasses = selector.pseudoClasses.filter(c => c.name === \"has\");\r\n\r\n    for (const pc of hasPseudoClasses) {\r\n        if (typeof pc.params[0] === \"string\")\r\n            return false;\r\n\r\n        const predicate = pc.params[0];\r\n\r\n        // Functions for lazy evaluation\r\n        const elementContext = {\r\n            area: () => getArea(points),\r\n            length: () => getLength(points),\r\n            width: () => getBoundingBox(points)[2],\r\n            height: () => getBoundingBox(points)[3],\r\n        };\r\n\r\n        const match = testPredicate(predicate, elementContext);\r\n\r\n        if (!match) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * @todo Add support for more than one paramater\r\n * @param {import(\"./Overpass\").StyleSelector} selector\r\n * @param {string} name\r\n * @param  {...string} params\r\n */\r\nfunction includesPseudoClass (selector, name, ...params) {\r\n    return selector.pseudoClasses.some(c => c.name === name && c.params[0] === params[0]);\r\n}","/**\r\n * @param {import(\"../Style\").StyleRule} rule\r\n * @param {import(\"../Overpass\").OverpassElement} element\r\n */\r\n\r\nexport function getContent(rule, element) {\r\n    let content = rule.declarations[\"content\"];\r\n\r\n    if (!content)\r\n        return \"\";\r\n\r\n    if (content.match(/^\".*\"$/g)) {\r\n        content = content.replace(/^\"|\"$/g, \"\");\r\n    }\r\n    else if (content.match(/tag\\(([^)]+)\\)/)) {\r\n        const m = content.match(/tag\\(([^)]+)\\)/);\r\n        content = element.tags[m[1]] || \"\";\r\n    }\r\n    else {\r\n        content = \"?\";\r\n    }\r\n    return content;\r\n}\r\n","\r\n/**\r\n * Can the string be considered a valid bbox?\r\n * - Are there four parts?\r\n * - Are they all numberic?\r\n * - Are they in the correct order?\r\n * @param {string} bbox\r\n */\r\nexport function isValid (bbox) {\r\n    const parts = bbox.split(\",\");\r\n\r\n    if (parts.length !== 4) return false;\r\n\r\n    if (parts.some(p => isNaN(+p))) return false;\r\n\r\n    return +parts[0] < +parts[2] && +parts[1] < +parts[3];\r\n}\r\n\r\n/**\r\n * Determines whether or not areaB is entirely contained\r\n * within areaA\r\n * @param {string} areaA\r\n * @param {string} areaB\r\n * @returns {boolean}\r\n */\r\nexport function contains (areaA, areaB) {\r\n    const [Ax1,Ay1,Ax2,Ay2] = areaA.split(\",\");\r\n    const [Bx1,By1,Bx2,By2] = areaB.split(\",\");\r\n\r\n    return (Bx1 >= Ax1 && By1 >= Ay1 && Bx2 <= Ax2 && By2 <= Ay2);\r\n}\r\n\r\n/**\r\n * Compute simple area\r\n * @param {string} bbox\r\n */\r\nexport function getArea (bbox) {\r\n    const parts = bbox.split(\",\");\r\n    return (+parts[2] - +parts[0]) * (+parts[3] - +parts[1]);\r\n}\r\n\r\n/**\r\n *\r\n * @param {[number, number]} centre\r\n * @param {number} zoom\r\n * @param {[number, number]} size\r\n */\r\nexport function makeBBox (centre, zoom, size) {\r\n    const baseTileSize = 256;\r\n\r\n    const [ lon, lat ] = centre;\r\n    const [ width, height ] = size;\r\n\r\n    const tileCount = Math.pow(2, zoom)\r\n    const xSpan = 180 / tileCount;\r\n    const ySpan = 180 / tileCount;\r\n\r\n    const hTileCount = width / baseTileSize;\r\n    const vTileCount = height / baseTileSize;\r\n\r\n    const dLon = xSpan * hTileCount;\r\n    const dLat = ySpan * vTileCount;\r\n\r\n    return [ lon - dLon, lat - dLat, lon + dLon, lat + dLat ].map(p => p.toFixed(3)).join(\",\");\r\n}","import { mercatorProjection, getCentrePoint, getMidPoint, getAveragePoint, getBoundingBox } from \"./util\";\r\nimport { rectToPoints, isSelfClosing } from \"./geometry\";\r\nimport { matchPseudoClasses } from \"./matchPseudoClasses\";\r\nimport { getContent } from \"./canvas-render/getContent\";\r\nimport { makeBBox } from \"./bbox\";\r\n\r\n/** @typedef {{ centre: [number, number], zoom: number, current: Position, width: number, height: number, scale: number }} MapContext */\r\n\r\nexport default class MapRenderer {\r\n\r\n    /**\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {import(\"./Overpass\").OverpassElement[]} elements\r\n     */\r\n    renderRule (context, rule, elements=[]) {\r\n        // Prepare node map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n        const nodeMap = {};\r\n        elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n        // Prepare way map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n        const wayMap = {};\r\n        elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n        const { centre, zoom, width, height } = context;\r\n\r\n        /** @type {(lon: number, lat: number) => [number, number]} */\r\n        const projection = mercatorProjection(centre, zoom, width, height);\r\n\r\n        // Set up global context options\r\n        this.globalSetup(rule);\r\n\r\n        const { type } = rule.selector;\r\n\r\n        // Non-Overpass Types first\r\n        switch (type) {\r\n            case \"map\": {\r\n                const points = rectToPoints(0, 0, width, height);\r\n                if (rule.selector.pseudoElement)\r\n                    this.renderPseudoElement(context, rule, points, null, null);\r\n                else\r\n                    this.renderArea(context, rule, points, null);\r\n                break;\r\n            }\r\n            case \"current\": {\r\n                if (context.current) {\r\n                    const { coords } = context.current;\r\n                    this.renderPoint(context, rule, projection(coords.longitude, coords.latitude));\r\n                }\r\n                break;\r\n            }\r\n            case \"gridlines\": {\r\n                this.renderGridlines(context, rule, projection);\r\n                break;\r\n            }\r\n            case \"dummy\": {\r\n                this.renderPoint(context, rule, [0, 0]);\r\n                break;\r\n            }\r\n            default:\r\n                // Then iterate all elements\r\n                for (const el of elements) {\r\n                    switch (type) {\r\n                        case \"node\": {\r\n                            if (el.type !== \"node\") continue;\r\n\r\n                            const point = projection(el.lon, el.lat);\r\n\r\n                            if (rule.selector.pseudoElement) {\r\n                                this.renderPseudoElement(context, rule, [point], el, [el]);\r\n                            }\r\n                            else {\r\n                                this.renderPoint(context, rule, point, el);\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"way\":\r\n                        case \"area\": {\r\n                            if (el.type !== \"way\") continue;\r\n\r\n                            /** @type {import(\"./Overpass\").OverpassNodeElement[]} */\r\n                            const nodes = el.nodes.map(id => nodeMap[id]);\r\n                            const points = nodes.map(n => projection(n.lon, n.lat));\r\n\r\n                            if (!matchPseudoClasses(rule, points, el, nodes)) continue;\r\n\r\n                            if (rule.selector.pseudoElement) {\r\n                                this.renderPseudoElement(context, rule, points, el, nodes);\r\n                            }\r\n                            else {\r\n                                // Render actual way/area\r\n                                if (type === \"area\") {\r\n                                    this.renderArea(context, rule, points, el);\r\n                                } else {\r\n                                    this.renderLine(context, rule, points, el);\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"relation\": {\r\n                            if (el.type !== \"relation\") continue;\r\n\r\n                            // this.renderRelation(rule, el, wayMap, nodeMap, projection, context);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n        }\r\n    }\r\n\r\n    renderPoint (context, rule, point, element=null) {}\r\n\r\n    renderLine (context, rule, points, element=null) {\r\n        this.renderAreaLine(context, rule, points, getMidPoint, element);\r\n    }\r\n\r\n    renderArea (context, rule, points, element=null) {\r\n        if (points.length === 0)\r\n            return;\r\n\r\n        if (!isSelfClosing(points)) {\r\n            points = [ ...points, points[0] ];\r\n        }\r\n\r\n        this.renderAreaLine(context, rule, points, getCentrePoint, element);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {}\r\n\r\n    /**\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {[number, number][]} points\r\n     * @param {import(\"./Overpass\").OverpassElement} [element]\r\n     * @param {import(\"./Overpass\").OverpassNodeElement[]} [nodes]\r\n     */\r\n    renderPseudoElement(context, rule, points, element=null, nodes=null) {\r\n        switch (rule.selector.pseudoElement) {\r\n            case \"centre\":\r\n            case \"center\": {\r\n                // Centre of bounding box\r\n                const centrePoint = getCentrePoint(points);\r\n                this.renderPoint(context, rule, centrePoint, element);\r\n                break;\r\n            }\r\n            case \"mid-point\": {\r\n                // N/2th point (median point)\r\n                const midPoint = getMidPoint(points);\r\n                this.renderPoint(context, rule, midPoint, element);\r\n                break;\r\n            }\r\n            case \"average-point\": {\r\n                // Average of all points\r\n                const avgPoint = getAveragePoint(points);\r\n                this.renderPoint(rule, avgPoint, element, context);\r\n                break;\r\n            }\r\n            case \"start\": {\r\n                // First point\r\n                this.renderPoint(context, rule, points[0], element);\r\n                break;\r\n            }\r\n            case \"end\": {\r\n                // Last point\r\n                this.renderPoint(context, rule, points[points.length - 1], element);\r\n                break;\r\n            }\r\n            case \"centre-of-mass\": {\r\n                // TODO: calculate centre-of-mass\r\n                // const avgPoint = getCOMPoint(points);\r\n                // renderPoint(ctx, rule, avgPoint, element);\r\n                break;\r\n            }\r\n            case \"bounding-box\": {\r\n                const bounding = getBoundingBox(points);\r\n\r\n                const boundingPoints = rectToPoints(...bounding);\r\n\r\n                this.renderArea(context, rule, boundingPoints, element);\r\n                break;\r\n            }\r\n            case \"content-box\": {\r\n                const { scale } = context;\r\n                const content = getContent(rule, element);\r\n                const size = this.measureText(context, rule, content);\r\n                let [ x, y ] = points[0];\r\n                const { width, ascending, descending } = size;\r\n                const padding = rule.declarations[\"padding\"] ? parseFloat(rule.declarations[\"padding\"]) * scale : 0;\r\n\r\n                if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n                    x -= width / 2;\r\n                }\r\n                else if (rule.declarations[\"text-align\"] === \"right\") {\r\n                    x -= width;\r\n                }\r\n\r\n                /** @type {[number, number][]} */\r\n                const boundPoints = [\r\n                    [ x - padding,           y - ascending - padding ],     // Top Left\r\n                    [ x - padding,           y + descending + padding ],    // Bottom left\r\n                    [ x + width + padding,   y + descending + padding ],    // Bottom right\r\n                    [ x + width + padding,   y - ascending - padding ],     // Top Right\r\n                ];\r\n\r\n                // Close self\r\n                boundPoints.push(boundPoints[0]);\r\n\r\n                this.renderAreaLine(context, rule, boundPoints, () => points[0], element);\r\n                break;\r\n            }\r\n            case \"decimate\": {\r\n                if (rule.selector.type === \"way\") {\r\n                    const l = points.length - 1;\r\n                    const decimatedPoints = points.filter((p, i) => i % 10 === 0 || i === l);\r\n                    this.renderLine(context, rule, decimatedPoints, element);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    renderGridlines (context, rule, projection) {\r\n        const vertical = rule.selector.pseudoClasses.find(p => p.name === \"vertical\");\r\n        const horizontal = rule.selector.pseudoClasses.find(p => p.name === \"horizontal\");\r\n\r\n        const { width, height, centre, zoom } = context;\r\n\r\n        const bbox = makeBBox(centre, zoom, [width, height]);\r\n        const parts = bbox.split(\",\");\r\n\r\n        if (vertical) {\r\n            const step = parseFloat(vertical.params[0]);\r\n\r\n            const round = 1 / step;\r\n\r\n            const sigFigs = Math.ceil(Math.log10(round));\r\n\r\n            const xmin = Math.floor(+parts[0] * round) / round;\r\n            const xmax = Math.ceil(+parts[2] * round) / round;\r\n            const ymin = Math.floor(+parts[1] * round) / round;\r\n            const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n            for (let i = xmin; i <= xmax; i += step) {\r\n                const points = [ projection(i, ymin),  projection(i, (ymin + ymax) / 2), projection(i, ymax) ];\r\n                this.renderLine(context, rule, points, { type: \"way\", id: 0, nodes: [], tags: { name: i.toFixed(sigFigs) }});\r\n            }\r\n        }\r\n\r\n        if (horizontal) {\r\n            const step = parseFloat(horizontal.params[0]);\r\n\r\n            const round = 1 / step;\r\n\r\n            const sigFigs = Math.ceil(Math.log10(round));\r\n\r\n            const xmin = Math.floor(+parts[0] * round) / round;\r\n            const xmax = Math.ceil(+parts[2] * round) / round;\r\n            const ymin = Math.floor(+parts[1] * round) / round;\r\n            const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n            for (let j = ymin; j <= ymax; j += step) {\r\n                const points = [ projection(xmin, j), projection((xmin + xmax) / 2, j), projection(xmax, j) ];\r\n                this.renderLine(context, rule, points, { type: \"way\", id: 0, nodes: [], tags: { name: j.toFixed(sigFigs) }});\r\n            }\r\n        }\r\n    }\r\n\r\n    globalSetup (rule) { }\r\n\r\n    /**\r\n     *\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {string} text\r\n     * @return {{ width: number, ascending: number, descending: number, height: number }}\r\n     */\r\n    measureText (context, rule, text) {\r\n        return { width: 0, ascending: 0, descending: 0, height: 0 };\r\n    }\r\n}","export function parseStrokeFill(rule, scale) {\r\n    const fillStyle = rule.declarations[\"fill\"];\r\n    let strokeStyle = rule.declarations[\"stroke\"];\r\n    let lineWidth;\r\n\r\n    if (strokeStyle) {\r\n        // Numbers in e.g. rgba(128,64,0,0.2) confuse it\r\n        let mutedStyle = strokeStyle.replace(/\\([^)]*\\)/g, ss => \" \".repeat(ss.length));\r\n\r\n        // So would hex colour strings\r\n        mutedStyle = mutedStyle.replace(/#[0-9a-f]{3}/i, \"    \");\r\n        mutedStyle = mutedStyle.replace(/#[0-9a-f]{6}/i, \"       \");\r\n\r\n        /**\r\n         * @todo A better parser would probably be nice\r\n         */\r\n        const swRe = /(\\d+(?:\\.\\d+)?)\\s*(?:px)?/;\r\n        const sm = swRe.exec(mutedStyle);\r\n        if (sm) {\r\n            lineWidth = +sm[1] * scale;\r\n            strokeStyle = strokeStyle.replace(sm[0], \"\");\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"stroke-width\"]) {\r\n        lineWidth = +rule.declarations[\"stroke-width\"] * scale;\r\n    }\r\n\r\n    return {\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth,\r\n    };\r\n}","import { parseStrokeFill } from '../parseStrokeFill';\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {import(\"../Style\").StyleRule} rule\r\n */\r\nexport function setStrokeFill (ctx, rule, scale) {\r\n    const { fillStyle, strokeStyle, lineWidth } = parseStrokeFill(rule, scale);\r\n\r\n    ctx.fillStyle = fillStyle;\r\n    ctx.strokeStyle = strokeStyle;\r\n    ctx.lineWidth = lineWidth;\r\n}","/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\nimport { setStrokeFill } from \"./setStrokeFill\";\r\nimport { getContent } from \"./getContent\";\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} param2\r\n * @param {OverpassElement} [element]\r\n */\r\nexport function renderText(ctx, rule, [x, y], element = null, context) {\r\n    setStrokeFill(ctx, rule, context.scale);\r\n\r\n    let content = getContent(rule, element);\r\n\r\n    setFont(ctx, rule, context.scale);\r\n\r\n    if (rule.declarations[\"text-align\"]) {\r\n        const textWidth = ctx.measureText(content).width;\r\n\r\n        if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n            x -= textWidth / 2;\r\n        }\r\n        else if (rule.declarations[\"text-align\"] === \"right\") {\r\n            x -= textWidth;\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"text-stroke\"]) {\r\n        ctx.strokeStyle = rule.declarations[\"text-stroke\"];\r\n        ctx.strokeText(content, x, y);\r\n    }\r\n\r\n    if (rule.declarations[\"text-color\"]) {\r\n        ctx.fillStyle = rule.declarations[\"text-color\"];\r\n        ctx.fillText(content, x, y);\r\n    }\r\n    else {\r\n        if (rule.declarations[\"stroke\"])\r\n            ctx.strokeText(content, x, y);\r\n        if (rule.declarations[\"fill\"] || !rule.declarations[\"stroke\"])\r\n            ctx.fillText(content, x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {number} scale\r\n */\r\nexport function setFont(ctx, rule, scale) {\r\n    let fontSize = `${10 * scale}px`;\r\n    let fontWeight = \"normal\";\r\n    let fontFamily = \"sans-serif\";\r\n\r\n    if (rule.declarations[\"font-size\"]) {\r\n        fontSize = rule.declarations[\"font-size\"].replace(/^\\d[\\d.]*/, m => `${+m * scale}`);\r\n    }\r\n\r\n    if (rule.declarations[\"font-weight\"]) {\r\n        fontWeight = rule.declarations[\"font-weight\"];\r\n    }\r\n\r\n    if (rule.declarations[\"font-family\"]) {\r\n        fontFamily = rule.declarations[\"font-family\"];\r\n    }\r\n\r\n    ctx.font = rule.declarations[\"font\"] || `${fontWeight} ${fontSize} ${fontFamily}`;\r\n}\r\n","/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n */\r\nexport function applyTransform(ctx, rule, scale) {\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        const r = /\\s*([a-z]+)\\(([^)]*)\\)\\s*/g;\r\n        const t = rule.declarations[\"transform\"];\r\n        let m;\r\n        while (m = r.exec(t)) {\r\n            const trans = m[1];\r\n            const params = m[2].split(\",\").map(s => ({ value: parseFloat(s) * scale, unit: s.replace(/[-\\d.\\s]/g, \"\") }));\r\n            switch (trans) {\r\n                case \"matrix\":\r\n                    // @ts-ignore\r\n                    ctx.transform(...params.map(p => p.value));\r\n                    break;\r\n                case \"rotate\": {\r\n                    let { value, unit } = params[0];\r\n\r\n                    if (unit === \"deg\") {\r\n                        value *= Math.PI / 180;\r\n                    } else if (unit === \"turn\") {\r\n                        value *= Math.PI * 2;\r\n                    }\r\n\r\n                    ctx.rotate(value);\r\n                    break;\r\n                }\r\n                case \"scale\":\r\n                    const x = params[0].value;\r\n                    const y = params[1] ? params[1].value : x;\r\n                    ctx.scale(x, y);\r\n                    break;\r\n                case \"translate\":\r\n                    // @ts-ignore\r\n                    ctx.translate(...params.map(p => p.value));\r\n                    break;\r\n                case \"skew\":\r\n                    let { value, unit } = params[0];\r\n\r\n                    if (unit === \"rad\")\r\n                        value = Math.tan(value);\r\n                    else if (unit === \"deg\")\r\n                        value = Math.tan(value * Math.PI / 180);\r\n\r\n                    let valueY = 0;\r\n\r\n                    if (params[1]) {\r\n                        let { value, unit } = params[1];\r\n\r\n                        if (unit === \"rad\")\r\n                            value = Math.tan(value);\r\n                        else if (unit === \"deg\")\r\n                            value = Math.tan(value * Math.PI / 180);\r\n\r\n                        valueY = value;\r\n                    }\r\n\r\n                    ctx.transform(1, valueY, value, 1, 0, 0);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { renderText } from \"./renderText\";\r\nimport { applyTransform } from \"./transform\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} position\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderPoint(ctx, rule, [x, y], element = null, context = {}) {\r\n    ctx.save();\r\n\r\n    const { scale } = context;\r\n\r\n    ctx.fillStyle = rule.declarations[\"fill\"];\r\n    ctx.strokeStyle = rule.declarations[\"stroke\"];\r\n    ctx.lineWidth = +rule.declarations[\"stroke-width\"] * scale;\r\n\r\n    if (rule.declarations[\"position\"] === \"absolute\") {\r\n        x = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n        y = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n    }\r\n    ctx.translate(x, y);\r\n\r\n    applyTransform(ctx, rule, scale);\r\n\r\n    if (rule.declarations[\"size\"]) {\r\n        ctx.beginPath();\r\n\r\n        const r = +rule.declarations[\"size\"] * scale;\r\n\r\n        ctx.ellipse(0, 0, r, r, 0, 0, Math.PI * 2);\r\n\r\n        rule.declarations[\"fill\"] && ctx.fill();\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    if (rule.declarations[\"path\"]) {\r\n        ctx.beginPath();\r\n\r\n        drawPath(ctx, rule.declarations[\"path\"], scale);\r\n\r\n        rule.declarations[\"fill\"] && ctx.fill();\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    // Syntax:\r\n    //  url(<URL>) [<width> [<height>]]\r\n    //  url(https://ijmacd.github.io/map-maker/logo192.png) 90px 120px;\r\n    const urlRe = /url\\(([^)]+)\\)(?:\\s+([^\\s]+)(?:\\s+([^\\s]+))?)?/;\r\n    if (urlRe.test(rule.declarations[\"icon\"])) {\r\n        const m = urlRe.exec(rule.declarations[\"icon\"]);\r\n        const url = m[1];\r\n        const img = new Image();\r\n        img.src = url;\r\n        const w = parseFloat(m[2]);\r\n        const h = parseFloat(m[3]);\r\n\r\n\r\n        img.addEventListener(\"load\", () => {\r\n            // The image is drawn in a callback so the render context state is lost\r\n            ctx.save();\r\n            // globalSetup(ctx, rule);\r\n\r\n            ctx.translate(x, y);\r\n\r\n            // applyTransform(ctx, rule);\r\n\r\n            if (w) {\r\n                const height = !isNaN(h) ? h : img.height * (w / img.width);\r\n                ctx.drawImage(img, 0, 0, w * scale, height * scale);\r\n            }\r\n            else {\r\n                ctx.drawImage(img, 0, 0);\r\n            }\r\n\r\n            ctx.restore();\r\n        });\r\n    }\r\n\r\n    if (rule.declarations[\"content\"]) {\r\n        renderText(ctx, rule, [0, 0], element, context);\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {string} pathSpec\r\n */\r\nfunction drawPath (ctx, pathSpec, scale) {\r\n    const segs = /([MLQCVHZ])\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?/ig;\r\n    let match;\r\n    /** @type {[number, number]} */\r\n    let first;\r\n    /** @type {[number, number]} */\r\n    let prev;\r\n\r\n    while (match = segs.exec(pathSpec)) {\r\n        const x = parseFloat(match[2]) * scale;\r\n        const y = parseFloat(match[3]) * scale;\r\n        const x2 = parseFloat(match[4]) * scale;\r\n        const y2 = parseFloat(match[5]) * scale;\r\n        const x3 = parseFloat(match[6]) * scale;\r\n        const y3 = parseFloat(match[7]) * scale;\r\n\r\n        if (!first) first = [x,y];\r\n\r\n        if (match[1] === \"M\") {\r\n            prev = [x,y];\r\n            ctx.moveTo(x, y);\r\n        }\r\n        else if (match[1] === \"L\") {\r\n            prev = [x,y];\r\n            ctx.lineTo(x, y);\r\n        }\r\n        else if (match[1] === \"Q\") {\r\n            prev = [x2,y2];\r\n            ctx.quadraticCurveTo(x, y, x2, y2);\r\n        }\r\n        else if (match[1] === \"C\") {\r\n            prev = [x3,y3];\r\n            ctx.bezierCurveTo(x, y, x2, y2, x3, y3);\r\n        }\r\n        else if (match[1] === \"Z\") {\r\n            prev = first;\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"V\") {\r\n            prev = [prev[0], x];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"H\") {\r\n            prev = [x, prev[1]];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"m\") {\r\n            prev = [prev[0] + x, prev[1] + y];\r\n            ctx.moveTo(...prev);\r\n        }\r\n        else if (match[1] === \"l\") {\r\n            prev = [prev[0] + x, prev[1] + y];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"q\") {\r\n            ctx.quadraticCurveTo(prev[0] + x, prev[1] + y, prev[0] + x2, prev[1] + y2);\r\n            prev = [prev[0] + x2, prev[1] + y2];\r\n        }\r\n        else if (match[1] === \"c\") {\r\n            prev = [x3,y3];\r\n            ctx.bezierCurveTo(prev[0] + x, prev[1] + y, prev[0] + x2, prev[1] + y2, prev[0] + x3, prev[1] + y3);\r\n            prev = [prev[0] + x3, prev[1] + y3];\r\n        }\r\n        else if (match[1] === \"z\") {\r\n            prev = first;\r\n            ctx.lineTo(...first);\r\n        }\r\n        else if (match[1] === \"v\") {\r\n            prev = [prev[0], prev[1] + x];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"h\") {\r\n            prev = [prev[0] + x, prev[1]];\r\n            ctx.lineTo(...prev);\r\n        }\r\n    }\r\n}","export default class CollisionSystem {\r\n    /** @type {CollisionSystem} */\r\n    static singleton;\r\n\r\n    constructor () {\r\n        /** @type {{ [name: string]: [number, number, number, number][] }} */\r\n        this.sets = {}\r\n    }\r\n\r\n    clear () {\r\n        this.sets = {};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} set\r\n     * @param {[number, number, number, number]} box\r\n     */\r\n    add (set, box) {\r\n        if (!this.sets[set]) this.sets[set] = [];\r\n\r\n        for (const other of this.sets[set]) {\r\n            if (intersects(box, other)) return false;\r\n        }\r\n\r\n        this.sets[set].push(box);\r\n\r\n        return true;\r\n    }\r\n\r\n    static getCollisionSystem () {\r\n        if (!this.singleton) {\r\n            this.singleton = new CollisionSystem();\r\n        }\r\n\r\n        return this.singleton;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * [x , y, width, height]\r\n * @param {[number, number, number, number]} boxA\r\n * @param {[number, number, number, number]} boxB\r\n */\r\nfunction intersects (boxA, boxB) {\r\n    const ax1 = boxA[0];\r\n    const ay1 = boxA[1];\r\n    const ax2 = boxA[0] + boxA[2];\r\n    const ay2 = boxA[1] + boxA[3];\r\n    const bx1 = boxB[0];\r\n    const by1 = boxB[1];\r\n    const bx2 = boxB[0] + boxB[2];\r\n    const by2 = boxB[1] + boxB[3];\r\n    return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;\r\n}","import { renderPoint } from \"./renderPoint\";\r\nimport { applyTransform } from \"./transform\";\r\nimport { setStrokeFill } from \"./setStrokeFill\";\r\nimport { getBoundingBox } from \"../util\";\r\nimport CollisionSystem from \"../CollisionSystem\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {(points: [number, number][]) => [number, number]} getPoint\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderAreaLine(ctx, rule, points, getPoint, element = null, context = {}) {\r\n    if (points.length === 0)\r\n        return;\r\n\r\n\r\n    if (rule.declarations[\"collision-set\"]) {\r\n        const box = getBoundingBox(points);\r\n\r\n        const collisionSystem = CollisionSystem.getCollisionSystem();\r\n\r\n        if (!collisionSystem.add(rule.declarations[\"collision-set\"], box)) {\r\n            const policy = rule.declarations[\"collision-policy\"] || \"hide\";\r\n\r\n            if (policy === \"hide\") {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    ctx.save();\r\n\r\n    setStrokeFill(ctx, rule, context.scale);\r\n\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        // Extra work required if we're transforming\r\n\r\n        // First get transform origin;\r\n        const cp = getPoint(points);\r\n\r\n        // Set offset to adjust all points later\r\n        offsetX = cp[0];\r\n        offsetY = cp[1];\r\n\r\n        // Translate the canvas\r\n        ctx.translate(offsetX, offsetY);\r\n\r\n        // Apply the transformation\r\n        applyTransform(ctx, rule, context.scale);\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(points[0][0] - offsetX, points[0][1] - offsetY);\r\n    for (let i = 1; i < points.length; i++) {\r\n        ctx.lineTo(points[i][0] - offsetX, points[i][1] - offsetY);\r\n    }\r\n\r\n    rule.declarations[\"fill\"] && ctx.fill();\r\n    rule.declarations[\"stroke\"] && ctx.stroke();\r\n\r\n    ctx.restore();\r\n\r\n    // Text Handling, Icons etc.\r\n    if (rule.declarations[\"content\"] || rule.declarations[\"size\"] || rule.declarations[\"path\"] || rule.declarations[\"icon\"]) {\r\n        ctx.save();\r\n        renderPoint(ctx, rule, getPoint(points), element, context);\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\n\r\n","import MapRenderer from \"../MapRenderer\";\r\nimport { renderPoint } from \"./renderPoint\";\r\nimport { setFont } from \"./renderText\";\r\nimport { renderAreaLine } from \"./renderAreaLine\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n\r\nexport default class CanvasRender extends MapRenderer {\r\n\r\n    /**\r\n     * @param {HTMLCanvasElement} canvas\r\n     */\r\n    constructor (canvas) {\r\n        super();\r\n        this.canvas = canvas;\r\n    }\r\n\r\n    clear (context) {\r\n        const { width, height } = context;\r\n\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n    }\r\n\r\n    renderRule (context, rule, elements=[]) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        ctx.save();\r\n        super.renderRule(context, rule, elements);\r\n        ctx.restore();\r\n    }\r\n\r\n    globalSetup(rule, scale) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n\r\n        if (rule.declarations[\"opacity\"])\r\n            ctx.globalAlpha = +rule.declarations[\"opacity\"];\r\n\r\n        if (rule.declarations[\"position\"] === \"relative\") {\r\n            const top = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n            const left = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n\r\n            ctx.translate(left, top);\r\n        }\r\n    }\r\n\r\n    renderPoint (context, rule, point, element=null) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        renderPoint(ctx, rule, point, element, context);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        renderAreaLine(ctx, rule, points, getPoint, element, context);\r\n    }\r\n\r\n    measureText (context, rule, text) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        const { scale } = context;\r\n        setFont(ctx, rule, scale);\r\n        const size = ctx.measureText(text);\r\n        const { width, actualBoundingBoxDescent: descending, actualBoundingBoxAscent: ascending } = size;\r\n\r\n        return {\r\n            width,\r\n            ascending,\r\n            descending,\r\n            height: ascending + descending,\r\n        };\r\n    }\r\n}\r\n\r\n","// import { renderPoint } from \"./renderPoint\";\r\n// import { applyTransform } from \"./transform\";\r\nimport { parseStrokeFill } from \"../parseStrokeFill\";\r\nimport { getBoundingBox } from \"../util\";\r\nimport CollisionSystem from \"../CollisionSystem\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {{ elements: { type: string, [key: string]: string }[] }} layer\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {(points: [number, number][]) => [number, number]} getPoint\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderAreaLine(layer, rule, points, getPoint, element = null, context = {}) {\r\n    if (points.length === 0)\r\n        return;\r\n\r\n\r\n    if (rule.declarations[\"collision-set\"]) {\r\n        const box = getBoundingBox(points);\r\n\r\n        const collisionSystem = CollisionSystem.getCollisionSystem();\r\n\r\n        if (!collisionSystem.add(rule.declarations[\"collision-set\"], box)) {\r\n            const policy = rule.declarations[\"collision-policy\"] || \"hide\";\r\n\r\n            if (policy === \"hide\") {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    const path = { type: \"path\" };\r\n\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        // Extra work required if we're transforming\r\n\r\n        // First get transform origin;\r\n        const cp = getPoint(points);\r\n\r\n        // Set offset to adjust all points later\r\n        offsetX = cp[0];\r\n        offsetY = cp[1];\r\n\r\n        // Translate the canvas\r\n        // ctx.translate(offsetX, offsetY);\r\n\r\n        // Apply the transformation\r\n        // applyTransform(path, rule);\r\n\r\n        path.transform = rule.declarations[\"transform\"];\r\n    }\r\n\r\n    const d = [];\r\n\r\n    d.push(`M ${(points[0][0] - offsetX).toFixed(2)} ${(points[0][1] - offsetY).toFixed(2)}`);\r\n    for (let i = 1; i < points.length; i++) {\r\n        d.push(`L ${(points[i][0] - offsetX).toFixed(2)} ${(points[i][1] - offsetY).toFixed(2)}`);\r\n    }\r\n\r\n    path.d = d.join(\" \");\r\n\r\n    layer.elements.push(path);\r\n\r\n    // Text Handling, Icons etc.\r\n    if (rule.declarations[\"content\"] || rule.declarations[\"size\"] || rule.declarations[\"path\"] || rule.declarations[\"icon\"]) {\r\n        // this.renderPoint(context, rule, getPoint(points), element);\r\n    }\r\n}\r\n\r\n\r\n","import MapRenderer from \"../MapRenderer\";\r\nimport { renderAreaLine } from \"./renderAreaLine\";\r\nimport { parseStrokeFill } from \"../parseStrokeFill\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\nexport default class SVGRender extends MapRenderer {\r\n    /**\r\n     * @param {number} width\r\n     * @param {number} height\r\n     */\r\n    constructor (width, height) {\r\n        super();\r\n        this.layers = [];\r\n        this.width = width;\r\n        this.height = height;\r\n        this.currentLayer = null;\r\n    }\r\n\r\n    clear () {\r\n        this.layers.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @param {import(\"../MapRenderer\").MapContext} context\r\n     * @param {import(\"../Style\").StyleRule} rule\r\n     * @param {import(\"../Overpass\").OverpassElement[]} elements\r\n     */\r\n    renderRule (context, rule, elements=[]) {\r\n        this.currentLayer = { elements: [] };\r\n\r\n        const colours = parseStrokeFill(rule);\r\n\r\n        this.currentLayer.stroke = colours.strokeStyle;\r\n        this.currentLayer.fill = colours.fillStyle || \"none\";\r\n\r\n        // Set up global context options\r\n        layerSetup(this.currentLayer, rule, context.scale);\r\n\r\n        super.renderRule(context, rule, elements);\r\n\r\n        this.layers.push(this.currentLayer);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {\r\n        renderAreaLine(this.currentLayer, rule, points, getPoint, element, context);\r\n    }\r\n\r\n    toString () {\r\n        return this.getTextParts().join(\"\");\r\n    }\r\n\r\n    toBlob () {\r\n        return new Blob(this.getTextParts());\r\n    }\r\n\r\n    getTextParts() {\r\n        const parts = [];\r\n\r\n        parts.push(`<svg version=\"1.1\" viewBox=\"0 0 ${this.width} ${this.height}\" width=\"${this.width}\" height=\"${this.height}\" xmlns=\"http://www.w3.org/2000/svg\">\\n`);\r\n\r\n        for (const layer of this.layers) {\r\n            const { elements, ...attr } = layer;\r\n\r\n            parts.push(`<g ${attributes(attr)}>\\n`);\r\n\r\n            for (const element of elements) {\r\n                const { type, ...attr } = element;\r\n                parts.push(`<${type} ${attributes(attr)} />\\n`);\r\n            }\r\n\r\n            parts.push(`</g>\\n`);\r\n        }\r\n\r\n        parts.push(`</svg>`);\r\n        return parts;\r\n    }\r\n}\r\n\r\nfunction attributes(attr) {\r\n    return Object.entries(attr).filter(([key, value]) => typeof value !== \"undefined\").map(([key, value]) => `${key}=\"${value}\"`).join(\" \");\r\n}\r\n\r\nexport function layerSetup(layer, rule, scale) {\r\n    if (rule.declarations[\"opacity\"])\r\n        layer.opacity = +rule.declarations[\"opacity\"];\r\n\r\n    if (rule.declarations[\"position\"] === \"relative\") {\r\n        const top = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n        const left = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n\r\n        layer.translate = [left, top];\r\n    }\r\n}\r\n","import { contains, getArea } from \"./bbox\";\r\n\r\nexport default class IDBElementDatabase {\r\n    constructor (name=\"OverpassElements\") {\r\n        const request = indexedDB.open(name);\r\n\r\n        request.addEventListener(\"upgradeneeded\", ev => {\r\n            /** @type {IDBOpenDBRequest} */\r\n            const request = (ev.target);\r\n            const db = request.result;\r\n            db.createObjectStore(\"nodes\", { keyPath: \"id\" });\r\n\r\n            const store = db.createObjectStore(\"elements\");\r\n            store.createIndex(\"selectorIndex\", [\"selector\", \"area\", \"bbox\"], { unique: false });\r\n        });\r\n\r\n        /** @type {Promise<IDBDatabase>} */\r\n        this.db = new Promise((resolve, reject) => {\r\n            request.addEventListener(\"success\", ev => {\r\n                /** @type {IDBOpenDBRequest} */\r\n                const request = (ev.target);\r\n                resolve(request.result);\r\n            });\r\n\r\n            request.addEventListener(\"error\", reject);\r\n        })\r\n\r\n    }\r\n\r\n    async saveNodes (nodes) {\r\n        const db = await this.db;\r\n        const store = db.transaction(\"nodes\", \"readwrite\").objectStore(\"nodes\");\r\n        for (const n of nodes) {\r\n            store.put(n);\r\n        }\r\n    }\r\n\r\n    async getNode (id) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const store = db.transaction(\"nodes\", \"readonly\").objectStore(\"nodes\");\r\n            const request = store.get(id);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", e => reject(e));\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number[]} ids\r\n     */\r\n    getNodes (ids) {\r\n        return Promise.all(ids.map(id => this.getNode(id)));\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} bbox\r\n     * @param {string} selector\r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    getElements (bbox, selector) {\r\n        const key = makeKey(bbox, selector);\r\n        return this.getElementsByKey(key);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} key\r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    async getElementsByKey (key) {\r\n        const db = await this.db;\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const request = objectStore.get(key);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} bbox\r\n     * @param {string} selector\r\n     * @returns {Promise<string>}\r\n     */\r\n    async searchElements (bbox, selector) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const index = objectStore.index(\"selectorIndex\");\r\n            const range = IDBKeyRange.bound([selector,0,\"0\"], [selector,Number.MAX_VALUE,\"999999999999999999\"]);\r\n            const request = index.openKeyCursor(range);\r\n            let count = 0;\r\n            const bboxOversizeArea = getArea(bbox) * 9;\r\n            request.addEventListener(\"success\", e => {\r\n                const cursor = request.result;\r\n\r\n                if (cursor) {\r\n                    const { key, primaryKey } = cursor;\r\n                    const keyBBox = key[2];\r\n                    const keyArea = key[1];\r\n                    count++;\r\n                    console.debug(`Checking index #${count} for ${selector}`);\r\n                    if (contains(keyBBox, bbox) && keyArea < bboxOversizeArea) {\r\n                        console.debug(`${selector} found after checking ${count} records`);\r\n                        resolve(primaryKey.toString());\r\n                        return;\r\n                    }\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    console.debug(`${selector} not found after checking ${count} records`);\r\n                    resolve(null);\r\n                }\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} bbox\r\n     * @param {string} selector\r\n     * @param {{ elements: import(\"./Overpass\").OverpassElement[], cached: number }} record\r\n     */\r\n    async saveElements (bbox, selector, record) {\r\n        const db = await this.db;\r\n        const key = makeKey(bbox, selector);\r\n        const area = getArea(bbox);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readwrite\").objectStore(\"elements\");\r\n            const request = objectStore.put({ selector, bbox, area, ...record }, key);\r\n            request.addEventListener(\"success\", () => {\r\n                console.debug(`Saved ${selector}/${bbox} to database with ${record.elements.length} elements`);\r\n                resolve();\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n}\r\n\r\nfunction makeKey (bbox, selector) {\r\n    const bkey = bbox.split(\",\").map(p => (+p).toFixed(3)).join(\",\");\r\n    return `${selector}/${bkey}`;\r\n}\r\n","import IDBElementDatabase from \"./database.idb\";\r\nimport { contains } from \"./bbox\";\r\nimport { matchSelector } from \"./Style\";\r\nimport { timeout } from './util';\r\n\r\n/** @typedef {import(\"./Style\").StyleSelector} StyleSelector */\r\n\r\nconst API_ROOT = require(\"./const\").API_ROOT;\r\n\r\nconst overpassRe = /^(node|way|rel(?:ation)?|area)/;\r\nconst recurRe = /^(way|rel(?:ation)?|area)/;\r\n\r\nexport class Overpass {\r\n    constructor (bbox) {\r\n        /** @type {Map<string, Promise<OverpassElement[]>>} */\r\n        this.elements = new Map();\r\n        this.bbox = bbox;\r\n        this.database = new IDBElementDatabase();\r\n        /** @type {{ [url: string]: Promise<OverpassElement[]> }} */\r\n        this.fetchMap = {};\r\n        /** @type {Promise<any>} */\r\n        this.currentJob = Promise.resolve();\r\n    }\r\n\r\n    setBBox (bbox) {\r\n        // If the new bbox is completely contained within the\r\n        // old one then we don't need to clear our cache\r\n        if (!contains(this.bbox, bbox)) {\r\n            this.elements.clear();\r\n        }\r\n        this.bbox = bbox;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     */\r\n    async preLoadElements (selectors) {\r\n        return this.jobs(async () => {\r\n            const { bbox } = this;\r\n\r\n            // Create set of selectors\r\n            /** @type {{ [key: string]: StyleSelector }} */\r\n            const set = {};\r\n            selectors.forEach(s => set[mapSelector(s)] = s);\r\n\r\n            console.debug(`Preloading Elements: ${selectors.length} requested (${Object.keys(set).length} unique)`);\r\n\r\n            // Remove non-overpass selectors\r\n            for (const [key, selector] of Object.entries(set)) {\r\n                if (!overpassRe.test(selector.type)) delete set[key];\r\n            }\r\n            console.debug(`Preloading Elements: ${Object.keys(set).length} are Overpass Elements`);\r\n\r\n            // Remove selectors found in local hash map cache\r\n            for (const key of Object.keys(set)) {\r\n                if (this.elements.has(key)) delete set[key];\r\n            }\r\n            console.debug(`Preloading Elements: ${Object.keys(set).length} not in HashMap`);\r\n\r\n            // Remove selectors which were found in database\r\n            await Promise.all(Object.keys(set).map(s => {\r\n                return this.database.searchElements(bbox, s)\r\n                    .then(els => {\r\n                        if (els) delete set[s];\r\n                    });\r\n            }));\r\n            console.debug(`Preloading Elements: ${Object.keys(set).length} not in Database`);\r\n\r\n            if (Object.keys(set).length === 0) return 0;\r\n\r\n            const elements = await this.tryQuery(Object.values(set));\r\n\r\n            console.log(`Preloading Elements: Fetched ${elements.length} elements from Server`);\r\n\r\n            // Prepare node map\r\n            /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n            const nodeMap = {};\r\n            elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n            // Prepare way map\r\n            /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n            const wayMap = {};\r\n            elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n            await Promise.all(Object.values(set).map(selector => {\r\n                const out = elements.filter(el => matchSelector(selector, el));\r\n\r\n                if (selector.type === \"relation\") {\r\n                    /** @type {OverpassRelElement[]} */\r\n                    const rels = (out.slice());\r\n\r\n                    /** @type {OverpassWayElement[]} */\r\n                    const ways = [];\r\n\r\n                    for (const rel of rels) {\r\n                        const refs = rel.members.map(m => m.ref);\r\n                        ways.push(...refs.map(id => wayMap[id]));\r\n                    }\r\n\r\n                    out.push(...ways);\r\n\r\n                    for (const way of ways) {\r\n                        out.push(...way.nodes.map(id => nodeMap[id]));\r\n                    }\r\n\r\n                } else if (selector.type === \"way\" || selector.type === \"area\") {\r\n                    /** @type {OverpassWayElement[]} */\r\n                    const ways = (out.slice());\r\n\r\n                    for (const way of ways) {\r\n                        out.push(...way.nodes.map(id => nodeMap[id]));\r\n                    }\r\n                }\r\n\r\n                this.elements.set(mapSelector(selector), Promise.resolve(out));\r\n                return this.database.saveElements(bbox, mapSelector(selector), { elements: out, cached: Date.now() });\r\n            }));\r\n\r\n            return elements.length;\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    query (selectors) {\r\n        if (this.bbox.split(\",\").map(p => +p).some(isNaN)) throw Error(\"Invalid BBox\");\r\n\r\n        const sMap = selectors.map(mapSelectorForQuery);\r\n        const query = `[out:json][bbox];\\n(${sMap.join(\"\")}\\n);\\nout;`\r\n        const url = `${API_ROOT}?data=${query.replace(/\\s/,\"\")}&bbox=${clampBBox(this.bbox)}`;\r\n\r\n        if (!this.fetchMap[url]) {;\r\n            this.fetchMap[url] = fetch(url.toString()).then(r => r.ok ? r.json() : Promise.reject(r.status)).then(r => r.elements);\r\n\r\n            this.fetchMap[url].finally(() => delete this.fetchMap[url]);\r\n        }\r\n\r\n        return this.fetchMap[url];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     * @param {number} tries\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    tryQuery (selectors, tries=10) {\r\n        return this.query(selectors).catch(e => {\r\n            if (e !== 429) throw Error(\"Bad Response\");\r\n\r\n            if (tries > 0) {\r\n                return timeout(10000).then(() => this.tryQuery(selectors, tries - 1))\r\n            }\r\n\r\n            throw Error(\"Too many retries fetching data\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {import(\"./Style\").StyleSelector} selector\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    async getElements (selector) {\r\n        if (!overpassRe.test(selector.type)) return;\r\n\r\n        const s = mapSelector(selector);\r\n        if (this.elements.has(s)) return this.elements.get(s);\r\n\r\n        const dbResult = await this.database.getElements(this.bbox, s);\r\n\r\n        if (dbResult) {\r\n            const { elements } = dbResult;\r\n            this.elements.set(s, Promise.resolve(elements));\r\n            return elements;\r\n        }\r\n\r\n        const dbSearchResult = await this.database.searchElements(this.bbox, s);\r\n\r\n        if (dbSearchResult) {\r\n            const elements = this.database.getElementsByKey(dbSearchResult).then(r => r.elements);\r\n            this.elements.set(s, elements);\r\n            return elements;\r\n        }\r\n\r\n        const p = this.tryQuery([selector]);\r\n\r\n        this.elements.set(s, p);\r\n\r\n        p.catch(() => this.elements.delete(s));\r\n\r\n        p.then(elements => {\r\n            this.database.saveElements(this.bbox, s, { elements, cached: Date.now() });\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    jobs (fn) {\r\n        this.currentJob = this.currentJob.then(() => fn());\r\n\r\n        return this.currentJob;\r\n    }\r\n}\r\n\r\n/** @param {StyleSelector} selector */\r\nfunction mapSelectorForQuery (selector) {\r\n    const recur = recurRe.test(selector.type) ? \">;\" : \"\";\r\n    return `${mapSelector(selector)};${recur}`;\r\n}\r\n\r\n/** @param {StyleSelector} selector */\r\nfunction mapSelector (selector) {\r\n    const type = selector.type === \"area\" ? \"way\" : selector.type;\r\n    const tags = Object.entries(selector.tags).map(([k,v]) => `[${k}=${v}]`);\r\n    return `${type}${tags.join(\"\")}`;\r\n}\r\n\r\n/** @typedef {import('./Style.js').StyleRule} StyleRule */\r\n\r\n/**\r\n * @typedef {OverpassNodeElement|OverpassWayElement|OverpassAreaElement|OverpassRelElement} OverpassElement\r\n */\r\n\r\n/**\r\n * @typedef OverpassNodeElement\r\n * @property {number} id\r\n * @property {\"node\"} type\r\n * @property {number} lon\r\n * @property {number} lat\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassWayElement\r\n * @property {number} id\r\n * @property {\"way\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassAreaElement\r\n * @property {number} id\r\n * @property {\"area\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassRelElement\r\n * @property {number} id\r\n * @property {\"relation\"} type\r\n * @property {{ ref: number, role: \"inner\"|\"outer\", type: \"node\"|\"way\"|\"relation\" }[]} members\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\nfunction clampBBox (bbox) {\r\n    const p = bbox.split(\",\").map(p => +p);\r\n    return `${clamp(p[0], -180, 180)},${clamp(p[1], -90, 90)},${clamp(p[2], -180, 180)},${clamp(p[3], -90, 90)}`;\r\n}\r\n\r\nfunction clamp (v, min, max) {\r\n    return Math.max(min, Math.min(v, max));\r\n}","import { useState, useEffect } from 'react';\r\n\r\n/**\r\n * @link https://usehooks.com/useDebounce/\r\n * @param {any} value \r\n * @param {number} delay \r\n */\r\nexport function useDebounce(value, delay) {\r\n    // State and setters for debounced value\r\n    const [debouncedValue, setDebouncedValue] = useState(value);\r\n  \r\n    useEffect(\r\n      () => {\r\n        // Update debounced value after delay\r\n        const handler = setTimeout(() => {\r\n          setDebouncedValue(value);\r\n        }, delay);\r\n  \r\n        // Cancel the timeout if value changes (also on delay change or unmount)\r\n        // This is how we prevent debounced value from updating if value is changed ...\r\n        // .. within the delay period. Timeout gets cleared and restarted.\r\n        return () => {\r\n          clearTimeout(handler);\r\n        };\r\n      },\r\n      [value, delay] // Only re-call effect if value or delay changes\r\n    );\r\n  \r\n    return debouncedValue;\r\n  }","import React from 'react';\r\n\r\n/**\r\n * \r\n * @param {{ value: string, onChange: (event) => void, [key: string]: any }} param0 \r\n */\r\nexport default function Textarea ({ value, onChange, ...otherProps }) {\r\n    /**\r\n     * @param {React.KeyboardEvent<HTMLTextAreaElement>} event\r\n     */\r\n    function handleKeyDown (event) {\r\n        const { key, currentTarget, shiftKey } = event;\r\n    \r\n        if (key === \"Tab\") {\r\n            event.preventDefault();\r\n    \r\n            const i = currentTarget.selectionStart;\r\n            const lineStart = value.lastIndexOf(\"\\n\", i-1) + 1;\r\n\r\n            if (shiftKey) {\r\n                if (value.substr(lineStart, 4) === \"    \") {\r\n                    const newValue = value.substring(0,lineStart) + value.substring(lineStart + 4);\r\n                    onChange(newValue);\r\n                    \r\n                    setTimeout(() => currentTarget.setSelectionRange(i - 4, i - 4), 10);\r\n                }\r\n            } else {\r\n                const linePos = i - lineStart;\r\n                const x = 4 - linePos % 4;\r\n\r\n                const newValue = value.substring(0,i) + \"    \".substring(0,x) + value.substring(i);\r\n                onChange(newValue);\r\n                \r\n                setTimeout(() => currentTarget.setSelectionRange(i + x, i + x), 10);\r\n            }\r\n        }\r\n    \r\n        else if (key === \"Enter\") {\r\n            event.preventDefault();\r\n\r\n            const i = currentTarget.selectionStart;\r\n            const addIndent = value[i-1] === \"{\";\r\n            const lineStart = value.lastIndexOf(\"\\n\", i-1) + 1;\r\n            const match = value.substring(lineStart, i).match(/^ */);\r\n            const newPos = i + match[0].length + 1 + (addIndent ? 4 : 0);\r\n\r\n            const newValue = value.substring(0,i) + \"\\n\" + (addIndent ? \"    \" : \"\") + match[0] + value.substring(i);\r\n            onChange(newValue);\r\n\r\n            setTimeout(() => currentTarget.setSelectionRange(newPos, newPos), 10);\r\n        }\r\n    }\r\n\r\n    return <textarea value={value} onChange={e => onChange(e.target.value)} onKeyDown={handleKeyDown} {...otherProps} />;\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport useSavedState from './useSavedState';\r\nimport { parseStyle, expandRules } from './Style';\r\nimport CanvasRender from './canvas-render';\r\nimport SVGRender from './svg-render';\r\nimport { Overpass } from './Overpass';\r\nimport { useDebounce } from './useDebounce';\r\nimport { makeBBox } from './bbox';\r\nimport useGeolocation from './useGeolocation';\r\nimport Textarea from './Textarea';\r\nimport useDeepCompareEffect from 'use-deep-compare-effect';\r\nimport CollisionSystem from './CollisionSystem';\r\n\r\nfunction App() {\r\n  const [ style, setStyle ] = useSavedState(\"USER_STYLE\", \"node[amenity=post_box] {\\n\\tfill: black;\\n\\tsize: 2;\\n}\");\r\n  const [ centre, setCentre ] = useSavedState(\"USER_CENTRE\", \"7.1,50.7\");\r\n  const [ zoom, setZoom ] = useSavedState(\"USER_SCALE\", 14);\r\n  const current = useGeolocation();\r\n  /** @type {React.MutableRefObject<HTMLCanvasElement>} */\r\n  const canvasRef = React.useRef();\r\n  /** @type {React.MutableRefObject<Overpass>} */\r\n  const overpassRef = React.useRef();\r\n  /** @type {[ string, (string) => void ]} */\r\n  const [ status, setStatus ] = React.useState(null);\r\n  const [ error, setError ] = React.useState(\"\");\r\n  const [ downloading, setDownloading ] = React.useState(false);\r\n  const [ progress, setProgress ] = React.useState(0);\r\n\r\n  const { clientWidth, clientHeight } = canvasRef.current || { clientWidth: 1000, clientHeight: 1000 };\r\n\r\n  const width = clientWidth * devicePixelRatio;\r\n  const height = clientHeight * devicePixelRatio;\r\n\r\n  const debouncedCentre = useDebounce(centre, 500);\r\n  const debouncedZoom = useDebounce(zoom, 500);\r\n\r\n  const bbox = React.useMemo(() => makeBBox(debouncedCentre.split(\",\").map(p => +p), debouncedZoom, [clientWidth, clientHeight]), [debouncedCentre, debouncedZoom, clientWidth, clientHeight]);\r\n\r\n  if (!overpassRef.current) {\r\n    overpassRef.current = new Overpass(bbox);\r\n  }\r\n\r\n  const debouncedStyle = useDebounce(style, 500);\r\n\r\n  const parsedStyle = React.useMemo(() => parseStyle(debouncedStyle), [debouncedStyle]);\r\n\r\n  React.useEffect(() => overpassRef.current.setBBox(bbox), [bbox]);\r\n\r\n  /** @type {[number, number]} */\r\n  const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\r\n\r\n  const context = { centre: centrePoint, zoom: debouncedZoom, scale: devicePixelRatio, width, height };\r\n  const rules = expandRules(parsedStyle.rules, context);\r\n\r\n  if (rules.some(r => r.selector.type === \"current\")) {\r\n    context.current = current;\r\n  }\r\n\r\n  // Refetch/Render map when bbox, or style change\r\n  useDeepCompareEffect(() => {\r\n    let currentEffect = true;\r\n\r\n    async function run () {\r\n      setStatus(\"Fetching...\");\r\n      setError(\"\");\r\n\r\n      try {\r\n        const count = await overpassRef.current.preLoadElements(rules.map(r => r.selector));\r\n\r\n        if (!currentEffect) return;\r\n\r\n        // Check if we're already preloading something\r\n        if (count < 0) return;\r\n\r\n        if (count === 0)\r\n          setStatus(`Rendering...`);\r\n        else\r\n          setStatus(`Rendering ${count} elements...`);\r\n\r\n        const map = rules.map(rule => {\r\n          return {\r\n            rule,\r\n            promise: overpassRef.current.getElements(rule.selector),\r\n          }\r\n        });\r\n\r\n        CollisionSystem.getCollisionSystem().clear();\r\n\r\n        if (canvasRef.current) {\r\n          if (!currentEffect) return;\r\n\r\n          const renderer = new CanvasRender(canvasRef.current);\r\n\r\n          renderer.clear(context);\r\n\r\n          let count = 0;\r\n\r\n          for (const item of map) {\r\n            const prefix = `${count++}/${map.length}`;\r\n            setProgress(count/map.length);\r\n\r\n            console.debug(`${prefix} Loading elements for ${item.rule.selector}`);\r\n            const elements = await item.promise;\r\n\r\n            if (!currentEffect) return;\r\n\r\n            console.debug(`${prefix} Rendering ${item.rule.selector}`);\r\n\r\n            renderer.renderRule(context, item.rule, elements);\r\n          }\r\n          setProgress(0);\r\n\r\n          console.debug(`Rendered!`);\r\n        }\r\n\r\n        setStatus(null);\r\n      } catch (e) {\r\n        setError(\"Error Fetching\");\r\n        setStatus(null);\r\n        console.log(e);\r\n      }\r\n    }\r\n\r\n    run();\r\n\r\n    return () => { currentEffect = false; };\r\n  }, [debouncedCentre, debouncedZoom, rules, context]);\r\n\r\n  function move (dX, dY) {\r\n    /** @type {[number, number]} */\r\n    const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\r\n    const bb = bbox.split(\",\").map(p => +p);\r\n    const stepSizeX = (bb[2] - bb[0]) / 2;\r\n    const stepSizeY = (bb[3] - bb[1]) / 2;\r\n    const newCentre = [ cleanup(centrePoint[0] + dX * stepSizeX), cleanup(centrePoint[1] + dY * stepSizeY) ];\r\n    setCentre(newCentre.join(\",\"));\r\n  }\r\n\r\n  function handleDownload (type) {\r\n    if (!downloading) {\r\n      setDownloading(true);\r\n      const cb = () => setDownloading(false);\r\n      if (type === \"png\") {\r\n        downloadPNG(canvasRef.current, cb);\r\n      } else {\r\n        downloadSVG(context, parsedStyle, overpassRef.current, cb);\r\n      }\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"sidebar\">\r\n        <div className=\"controls\">\r\n          <button onClick={() => move(-1,0)}></button>\r\n          <button onClick={() => move(1,0)}></button>\r\n          <button onClick={() => move(0,1)}></button>\r\n          <button onClick={() => move(0,-1)}></button>\r\n          <button onClick={() => setZoom(+cleanup(zoom + 1))}></button>\r\n          <button onClick={() => setZoom(+cleanup(zoom - 1))}></button>\r\n          { current && <button onClick={() => setCentre(`${current.coords.longitude},${current.coords.latitude}`)}></button> }\r\n          <button onClick={() => handleDownload(\"png\")} disabled={downloading}> PNG</button>\r\n          <button onClick={() => handleDownload(\"svg\")} disabled={downloading}> SVG</button>\r\n        </div>\r\n        <label>Centre <input value={centre} onChange={e => setCentre(e.target.value)} /></label>\r\n        <label>Zoom <input type=\"number\" value={zoom} onChange={e => setZoom(+e.target.value)} /></label>\r\n        <Textarea value={style} onChange={setStyle} style={{flex:1}} spellCheck={false} />\r\n        <div className=\"status-area\">\r\n          { status && <p>{status}</p> }\r\n          { progress > 0 && <progress value={progress} />}\r\n          { error && <p style={{color:\"red\"}}>{error}</p> }\r\n        </div>\r\n      </div>\r\n      <canvas ref={canvasRef} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n/**\r\n * @param {HTMLCanvasElement} canvas\r\n */\r\nfunction downloadPNG (canvas, callback=null) {\r\n  canvas.toBlob(blob => {\r\n    blobDownload(blob, \"map.png\");\r\n    if (callback) callback();\r\n  });\r\n}\r\n\r\nasync function downloadSVG (context, style, overpass, callback=null) {\r\n  const rules = expandRules(style.rules, context);\r\n\r\n  const map = rules.map(rule => {\r\n    return {\r\n      rule,\r\n      promise: overpass.getElements(rule.selector),\r\n    }\r\n  });\r\n\r\n  CollisionSystem.getCollisionSystem().clear();\r\n\r\n  const svgRender = new SVGRender(context.width, context.height);\r\n\r\n  for (const item of map) {\r\n    const elements = await item.promise;\r\n    svgRender.renderRule(context, item.rule, elements);\r\n  }\r\n\r\n  const blob = svgRender.toBlob();\r\n  blobDownload(blob, \"map.svg\");\r\n\r\n  if (callback) callback();\r\n}\r\n\r\nfunction blobDownload (blob, filename) {\r\n  const url = URL.createObjectURL(blob);\r\n  const a = document.createElement(\"a\");\r\n  a.download = filename;\r\n  a.href = url;\r\n  document.body.appendChild(a);\r\n  a.click();\r\n  document.body.removeChild(a);\r\n  URL.revokeObjectURL(url);\r\n}\r\n\r\n/**\r\n * @param {number} n\r\n */\r\nfunction cleanup (n) {\r\n  return n.toFixed(5).replace(/^0+|0+$/g, \"\");\r\n}","import React from 'react';\r\n\r\nexport default function useGeolocation () {\r\n    /** @type {[Position, (newPos: Position) => void]} */\r\n    const [ loc, setLoc ] = React.useState();\r\n\r\n    React.useEffect(() => { navigator.geolocation.getCurrentPosition(setLoc) }, []);\r\n\r\n    React.useEffect(() => {\r\n        const id = navigator.geolocation.watchPosition(setLoc);\r\n\r\n        return () => navigator.geolocation.clearWatch(id);\r\n    }, []);\r\n\r\n    return loc;\r\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}