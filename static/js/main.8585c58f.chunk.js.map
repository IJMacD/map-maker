{"version":3,"sources":["const.js","useSavedState.js","Style.js","util.js","geometry.js","matchPseudoClasses.js","getContent.js","bbox.js","MapRenderer.js","parseStrokeFill.js","canvas-render/setStrokeFill.js","canvas-render/renderText.js","canvas-render/transform.js","canvas-render/renderPoint.js","CollisionSystem.js","canvas-render/renderAreaLine.js","canvas-render/index.js","render-worker.js","WorkerRenderer.js","svg-render/renderAreaLine.js","svg-render/index.js","database.idb.js","Overpass.js","useDebounce.js","Textarea.js","App.js","useGeolocation.js","serviceWorker.js","index.js"],"names":["API_ROOT","useSavedState","key","initalState","React","useState","saved","localStorage","getItem","JSON","parse","e","state","setState","newState","setItem","stringify","StyleSelector","type","tags","pseudoClasses","pseudoElement","this","Object","entries","map","k","v","op","test","join","matchSelector","selector","element","inequalities","length","value","m","exec","cmp","COMPARE","substr","res","isNaN","localeCompare","parseMedia","mediaText","match","match2","re","out","mediaQueries","index","re2","predicate","makePredicate","parseRules","substring","rules","push","console","log","ruleText","declarations","split","s","trim","filter","forEach","i","indexOf","property","selectors","parseMultiple","expandRules","context","rule","testPredicate","left","operator","right","Function","text","tagText","m2","re3","m3","params","name","re4","m4","x","a","b","timeout","duration","Promise","resolve","setTimeout","mercatorProjection","centre","scale","width","height","cLon","cLat","tileCount","Math","pow","hPixelsPerDeg","vPixelsPerDeg","QUARTER_PI","PI","cX","cY","cLatPrime","tan","lon","lat","E","N","getAveragePoint","points","reduce","sum","p","getCentrePoint","boundingBox","getBoundingBox","getMidPoint","floor","minMax","point","min","max","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","rectToPoints","y","getCrossProductArea","getArea","abs","isAntiClockwise","isConvex","l","sign","c","next","isSelfClosing","f","getLength","dx","dy","sqrt","matchPseudoClasses","nodes","includesPseudoClass","hasPseudoClasses","pc","elementContext","area","some","getContent","content","replace","toString","contains","areaA","areaB","Ax1","Ay1","Ax2","Ay2","Bx1","By1","Bx2","By2","bbox","parts","makeBBox","zoom","size","dLon","dLat","toFixed","MapRenderer","elements","nodeMap","n","id","wayMap","projection","globalSetup","renderPseudoElement","renderArea","current","coords","renderPoint","longitude","latitude","renderGridlines","el","renderLine","renderAreaLine","getPoint","centrePoint","midPoint","avgPoint","bounding","boundingPoints","bottom","top","NaN","baseline","line","measureText","ascending","descending","padding","parseFloat","boundPoints","decimatedPoints","vertical","find","horizontal","step","round","sigFigs","ceil","log10","xmin","xmax","ymin","ymax","j","parseStrokeFill","lineWidth","fillStyle","strokeStyle","mutedStyle","ss","repeat","sm","setStrokeFill","ctx","renderText","setFont","textWidth","strokeText","fillText","actualBoundingBoxAscent","actualBoundingBoxDescent","fontSize","fontWeight","fontFamily","font","applyTransform","r","t","trans","unit","transform","rotate","translate","valueY","save","beginPath","ellipse","fill","stroke","drawPath","urlRe","url","img","Image","src","w","h","addEventListener","drawImage","restore","pathSpec","first","prev","segs","x2","y2","x3","y3","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","CollisionSystem","sets","set","box","intersects","singleton","boxA","boxB","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","scaleFactor","collisionSystem","getCollisionSystem","add","policy","offsetX","offsetY","cp","CanvasRender","canvas","getContext","globalAlpha","Worker","WorkerRenderer","transferControlToOffscreen","worker","RenderWorker","postMessage","method","_elements","layer","path","d","SVGRender","layers","currentLayer","colours","layerSetup","getTextParts","Blob","attr","attributes","opacity","IDBElementDatabase","request","indexedDB","open","ev","db","target","result","createObjectStore","keyPath","createIndex","unique","reject","store","transaction","objectStore","put","get","ids","all","getNode","makeKey","getElementsByKey","range","IDBKeyRange","bound","MAX_VALUE","openKeyCursor","count","bboxOversizeArea","cursor","primaryKey","keyBBox","keyArea","debug","continue","record","req","clear","onsuccess","onerror","bkey","require","overpassRe","recurRe","Overpass","Map","database","fetchMap","currentJob","jobs","Error","mapSelector","keys","has","searchElements","then","els","tryQuery","values","rels","slice","ways","refs","members","ref","way","saveElements","cached","Date","now","sMap","mapSelectorForQuery","query","clamp","clampBBox","fetch","ok","json","status","finally","tries","catch","getElements","dbResult","dbSearchResult","delete","fn","recur","useDebounce","delay","debouncedValue","setDebouncedValue","useEffect","handler","clearTimeout","Textarea","onChange","otherProps","onKeyDown","event","currentTarget","shiftKey","preventDefault","selectionStart","lineStart","lastIndexOf","newValue","setSelectionRange","addIndent","newPos","App","style","setStyle","setCentre","setZoom","loc","setLoc","navigator","geolocation","getCurrentPosition","watchPosition","clearWatch","useGeolocation","canvasRef","useRef","overpassRef","setStatus","error","setError","downloading","setDownloading","progress","setProgress","rendererRef","shellContextRef","executables","clearCache","counter","setCounter","useForceRender","renderPending","forceRender","render","window","location","reload","removeItem","consoleVisible","showConsole","clientWidth","clientHeight","devicePixelRatio","debouncedCentre","debouncedZoom","useMemo","debouncedStyle","parsedStyle","styleText","rulesResult","mediaResult","parseStyle","setBBox","callback","ctrlKey","altKey","document","removeEventListener","move","dX","dY","bb","stepSizeX","stepSizeY","newCentre","cleanup","handleDownload","cb","toBlob","blob","blobDownload","downloadPNG","downloadSVG","WorkerRender","useDeepCompareEffect","currentEffect","className","onClick","disabled","flex","spellCheck","color","maxHeight","overpass","promise","svgRender","item","renderRule","filename","URL","createObjectURL","createElement","download","href","body","appendChild","click","removeChild","revokeObjectURL","renderer","preLoadElements","prefix","Boolean","hostname","ReactDOM","StrictMode","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"2LACA,gDAAO,IAAMA,EAAW,2C,+HCOT,SAASC,EAAeC,EAAKC,GAAc,IAAD,EACzBC,IAAMC,UAAS,WACvC,IAAMC,EAAQC,aAAaC,QAAQN,GAEnC,GAAII,EACA,IACIH,EAAcM,KAAKC,MAAMJ,GAC3B,MAAOK,IAGb,OAAOR,KAV0C,mBAC7CS,EAD6C,KACtCC,EADsC,KAarD,MAAO,CACHD,EACA,SAAAE,GACIP,aAAaQ,QAAQb,EAAKO,KAAKO,UAAUF,IACzCD,EAASC,K,yBCHRG,EAAb,WAOI,WAAaC,EAAMC,GAA6C,IAAvCC,EAAsC,uDAAxB,GAAIC,EAAoB,uDAAN,KAAM,oBAC7DC,KAAKJ,KAAOA,EACZI,KAAKH,KAAOA,EACZG,KAAKF,cAAgBA,EACrBE,KAAKD,cAAgBA,EAX3B,uDAeM,MAAM,GAAN,OAAUC,KAAKJ,MAAf,OAAsBK,OAAOC,QAAQF,KAAKH,MAAMM,KAAI,YAAY,IAAD,mBAATC,EAAS,KAAPC,EAAO,KACvDC,EAAK,SAASC,KAAKF,GAAK,GAAK,IACnC,MAAM,IAAN,OAAWD,GAAX,OAAeE,GAAf,OAAoBD,EAApB,QACCG,KAAK,SAlBd,KAuHO,SAASC,EAAeC,EAAUC,GAA6B,IAApBC,IAAmB,yDACnE,GAAID,EAAQf,OAASc,EAASd,OAA4B,SAAlBc,EAASd,MAAoC,QAAjBe,EAAQf,MAAiB,OAAO,EAEpG,IAAMM,EAAUD,OAAOC,QAAQQ,EAASb,MACxC,GAAIK,EAAQW,QAAkC,qBAAjBF,EAAQd,KAAsB,OAAO,EAElE,cAA2BK,EAA3B,eAAoC,CAAC,IAAD,sBAAxBtB,EAAwB,KAAnBkC,EAAmB,KAClC,GAAiC,qBAAtBH,EAAQd,KAAKjB,GAAsB,OAAO,EAErD,IAAMmC,EAAI,UAAUC,KAAKF,GACzB,GAAIC,GAEF,GAAIH,EAAc,CAChB,IAAMN,EAAKS,EAAE,GACPE,EAAMC,EAAQZ,GAEpB,IAAKW,EAAK,SACV,IAAMZ,EAAIS,EAAMK,OAAOJ,EAAE,GAAGF,QAEtBO,EAAMC,OAAOhB,GAAKY,EAAIN,EAAQd,KAAKjB,GAAK0C,cAAcjB,GAAI,GAAKY,GAAKN,EAAQd,KAAKjB,IAAOyB,GAE9F,IAAKe,EAAK,OAAO,QAIhB,GAAc,MAAVN,GAAiBH,EAAQd,KAAKjB,KAASkC,EAC9C,OAAO,EAIX,OAAO,EAsCT,SAASS,EAAYC,GASnB,IARA,IAGIC,EAGAC,EANEC,EAAK,uGAELC,EAAM,CAAEC,aAAc,GAAIC,MAAO,GAGjCC,EAAM,QAGLN,EAAQE,EAAGX,KAAKQ,IAAY,CACjC,IAAMQ,EAAYC,EAAcR,GAEhCG,EAAIE,OAASL,EAAM,GAAGZ,OAHW,MAORqB,EAFzBV,EAAYA,EAAUW,UAAUV,EAAM,GAAGZ,SAEjCuB,EAPyB,EAOzBA,MAAON,EAPkB,EAOlBA,MAEfF,EAAIE,OAASA,EAEbN,EAAYA,EAAUW,UAAUL,IAEhCJ,EAASK,EAAIf,KAAKQ,KAGhBI,EAAIC,aAAaQ,KAAK,CACpBzC,KAAM,QACNoC,YACAI,UAGFR,EAAIE,OAASJ,EAAO,GAAGb,QAGvByB,QAAQC,IAAI,4BAIhB,OAAOX,EAGT,SAASM,EAAYM,GAMnB,IALA,IACIf,EADEE,EAAK,4BAGLC,EAAM,CAAEQ,MAAO,GAAIN,MAAO,GAJH,aAQ3B,IAAMW,EAAe,GAErBhB,EAAM,GAAGiB,MAAM,KAAKvC,KAAI,SAAAwC,GAAC,OAAIA,EAAEC,UAAQC,QAAO,SAAAF,GAAC,OAAIA,KAAGG,SAAQ,SAAAH,GAE5D,IAAMI,EAAIJ,EAAEK,QAAQ,KACdC,EAAWN,EAAER,UAAU,EAAEY,GAAGH,OAC5B9B,EAAQ6B,EAAER,UAAUY,EAAE,GAAGH,OAC/BH,EAAaQ,GAAYnC,KAG3B,IAAMoC,EAAYvD,EAAcwD,cAAc1B,EAAM,IAEhDyB,EAAUrC,QACZe,EAAIQ,MAAMC,KAAK,CACbzC,KAAM,OACNsD,YACAT,iBAIJb,EAAIE,OAASL,EAAM,GAAGZ,OAEtB2B,EAAWA,EAASL,UAAUV,EAAM,GAAGZ,SAxBnCY,EAAQE,EAAGX,KAAKwB,IAAY,IA2BlC,OAAOZ,EASF,SAASwB,EAAahB,EAAOiB,GAElC,IAF2C,EAErCzB,EAAM,GAF+B,cAGxBQ,GAHwB,IAG3C,2BAA0B,CAAC,IAAhBkB,EAAe,QACxB,GAAkB,SAAdA,EAAK1D,KAAiB,CAAC,IAAD,EAChB6C,EAAiBa,EAAjBb,aADgB,cAEDa,EAAKJ,WAFJ,IAExB,2BAAuC,CAAC,IAA7BxC,EAA4B,QACrCkB,EAAIS,KAAK,CAAEzC,KAAM,OAAQc,WAAU+B,kBAHb,oCAMpBc,EAAcD,EAAKtB,UAAWqB,IAChCzB,EAAIS,KAAJ,MAAAT,EAAG,YAASwB,EAAYE,EAAKlB,MAAOiB,MAXC,8BAe3C,OAAOzB,EAGT,SAASK,EAAcR,GAuBrB,OApBIA,EAAM,GAGI,CACV+B,KAAM,CAAEA,KAAM/B,EAAM,GAAIgC,SAAUhC,EAAM,GAAIiC,MAAOjC,EAAM,IACzDgC,SAAU,MACVC,MAAO,CAAEF,KAAM/B,EAAM,GAAIgC,SAAUhC,EAAM,GAAIiC,MAAOjC,EAAM,KAQhD,CACV+B,KAAM/B,EAAM,GACZgC,SAAUhC,EAAM,GAChBiC,MAAOjC,EAAM,IAYZ,SAAS8B,EAAevB,GAAwB,IAAbqB,EAAY,uDAAJ,GAC5CG,EAAiC,kBAAnBxB,EAAUwB,MAA+C,kBAAnBxB,EAAUwB,KAChExB,EAAUwB,KAAOD,EAAcvB,EAAUwB,KAAMH,GAC7CK,EAAmC,kBAApB1B,EAAU0B,OAAiD,kBAApB1B,EAAU0B,MAClE1B,EAAU0B,MAAQH,EAAcvB,EAAU0B,MAAOL,GAE/B,kBAATG,GAAqBA,KAAQH,IAElCA,EAAQG,aAAiBG,WAC3BN,EAAQG,GAAQH,EAAQG,MAE1BA,EAAOH,EAAQG,IAGI,kBAAVE,GAAsBA,KAASL,IAEpCA,EAAQK,aAAkBC,WAC5BN,EAAQK,GAASL,EAAQK,MAE3BA,EAAQL,EAAQK,IAGlB,IAAMpD,EAAKY,EAAQc,EAAUyB,UAE7B,QAAKnD,GAEEA,EAAGkD,EAAME,GApUlB/D,EAAcP,MAGd,SAAUwE,GACN,IACM7C,EADK,eACEC,KAAK4C,GAElB,IAAK7C,EAAG,OAAO,KAEf,IAAInB,EAAOmB,EAAE,GAEA,QAATnB,IACFA,EAAO,YAUT,IANA,IAAMC,EAAO,GAETgE,EAAUD,EAAKzB,UAAUpB,EAAE,GAAGF,QAAQ+B,OAEpCb,EAAM,mDAEC,CACX,IAAM+B,EAAK/B,EAAIf,KAAK6C,GAEpB,IAAKC,EAAI,MAET,IAAMxD,EAAe,MAAVwD,EAAG,GAAa,GAAKA,EAAG,GAEnCjE,EAAKiE,EAAG,IAAMA,EAAG,GAAKxD,EAAKwD,EAAG,GAAK,IAEnCD,EAAUA,EAAQ1B,UAAU2B,EAAG,GAAGjD,QAQpC,IAJA,IAAMf,EAAgB,GAEhBiE,EAAM,8BAlCA,aAqCV,IAAMC,EAAKD,EAAI/C,KAAK6C,GAEpB,IAAKG,EAAI,cAET,IAAMrC,EAAK,sFACLsC,EAASD,EAAG,GAAKA,EAAG,GAAGtB,MAAM,KAAKvC,KAAI,SAAAwC,GAAC,OAAIhB,EAAGpB,KAAKoC,GAAKV,EAAcN,EAAGX,KAAK2B,IAAMA,KAAK,GAC/F7C,EAAcuC,KAAK,CAAE6B,KAAMF,EAAG,GAAIC,WAElCJ,EAAUA,EAAQ1B,UAAU6B,EAAG,GAAGnD,WATvB,kBAGF,MASX,IAAId,EAAgB,KAEdoE,EAAM,gBAEZ,GAAIA,EAAI5D,KAAKsD,GAAU,CACrB,IAAMO,EAAKD,EAAInD,KAAK6C,GAEpB9D,EAAgBqE,EAAG,GAEnBP,EAAUA,EAAQ1B,UAAUiC,EAAG,GAAGvD,QAGpC,OAAIgD,EAAQhD,QACVyB,QAAQC,IAAR,4BAAiCqB,EAAjC,8BAA2DC,EAA3D,MACO,MAGF,IAAIlE,EAAcC,EAAMC,EAAMC,EAAeC,IAOxDJ,EAAcwD,cAAgB,SAAUS,GACpC,OAAOA,EAAKlB,MAAM,KAAKvC,IAAIR,EAAcP,OAAOyD,QAAO,SAAAwB,GAAC,OAAIA,MA2PhE,IAAMnD,EAAU,CACd,IAAK,SAACoD,EAAEC,GAAH,OAASD,GAAKC,GACnB,IAAK,SAACD,EAAEC,GAAH,OAASD,GAAKC,GACnB,IAAK,SAACD,EAAEC,GAAH,OAASD,EAAIC,GAClB,IAAK,SAACD,EAAEC,GAAH,OAASD,EAAIC,GAClB,KAAM,SAACD,EAAEC,GAAH,OAASD,GAAKC,GACpB,KAAM,SAACD,EAAEC,GAAH,OAASD,GAAKC,GACpB,IAAO,SAACD,EAAEC,GAAH,OAASD,GAAKC,GACrB,GAAM,SAACD,EAAEC,GAAH,OAASD,GAAKC,I,+BCvXf,SAASC,EAASC,GACrB,OAAO,IAAIC,SAAQ,SAAAC,GAAO,OAAIC,WAAWD,EAASF,MAyB/C,SAASI,EAAmBC,EAAQC,EAAOC,EAAOC,GACrD,IAD6D,cAGxCH,EAHwC,GAGtDI,EAHsD,KAGhDC,EAHgD,KAKvDC,EAAYC,KAAKC,IAAI,EAAGP,GAIxBQ,EARe,KAKD,IAAMH,GAIpBI,EATe,KAMD,IAAMJ,GAKpBK,EAAaJ,KAAKK,GAAK,EAEvBC,EAAKX,EAAQ,EACbY,EAAKX,EAAS,EAEdY,EAA0E,IAA9DR,KAAK9C,IAAI8C,KAAKS,IAAIL,EAAcN,EAAO,IAAME,KAAKK,GAAM,IAAYL,KAAKK,GAE3F,OAAO,SAACK,EAAKC,GACT,IAAMC,EAAIF,EACJG,EAAiE,IAA7Db,KAAK9C,IAAI8C,KAAKS,IAAIL,EAAcO,EAAM,IAAMX,KAAKK,GAAM,IAAYL,KAAKK,GAQlF,MAAO,CAACC,GANKM,EAAIf,GAGCK,EAGDK,GALJM,EAAIL,GAGCL,IAUnB,SAASW,EAAgBC,GAI5B,OAHYA,EAAOC,QAAO,SAACC,EAAKC,GAAN,MAAY,CAACD,EAAI,GAAKC,EAAE,GAAID,EAAI,GAAKC,EAAE,MAAK,CAAC,EAAG,IAEzDpG,KAAI,SAAAkE,GAAC,OAAIA,EAAI+B,EAAOvF,UASlC,SAAS2F,EAAeJ,GAC3B,IAAMK,EAAcC,EAAeN,GAEnC,MAAO,CACHK,EAAY,GAAKA,EAAY,GAAK,EAClCA,EAAY,GAAKA,EAAY,GAAK,GASnC,SAASE,EAAYP,GACxB,OAAOA,EAAOf,KAAKuB,OAAOR,EAAOvF,OAAS,GAAK,IAO5C,SAAS6F,EAAeN,GAC3B,IAAMS,EAAST,EAAOC,QAAO,SAACQ,EAAQC,GAClC,MAAO,CACHzB,KAAK0B,IAAIF,EAAO,GAAIC,EAAM,IAC1BzB,KAAK0B,IAAIF,EAAO,GAAIC,EAAM,IAC1BzB,KAAK2B,IAAIH,EAAO,GAAIC,EAAM,IAC1BzB,KAAK2B,IAAIH,EAAO,GAAIC,EAAM,OAE/B,CAACG,OAAOC,kBAAmBD,OAAOC,kBAAmBD,OAAOE,kBAAmBF,OAAOE,oBAEzF,MAAO,CACHN,EAAO,GACPA,EAAO,GACPA,EAAO,GAAKA,EAAO,GACnBA,EAAO,GAAKA,EAAO,IC1GpB,SAASO,EAAa/C,EAAGgD,EAAGrC,EAAOC,GAEtC,MAAO,CACH,CAACZ,EAAGgD,GACJ,CAAChD,EAAGgD,EAAIpC,GACR,CAACZ,EAAIW,EAAOqC,EAAIpC,GAChB,CAACZ,EAAIW,EAAOqC,IASb,SAASC,EAAqBlB,GAEjC,IADA,IAAIE,EAAM,EACDvD,EAAI,EAAGA,EAAIqD,EAAOvF,OAAS,EAAGkC,IACnCuD,GAAOF,EAAOrD,GAAG,GAAKqD,EAAOrD,EAAE,GAAG,GAAKqD,EAAOrD,EAAE,GAAG,GAAKqD,EAAOrD,GAAG,GAEtE,OAAOuD,EAAM,EAMV,SAASiB,EAASnB,GACrB,OAAOf,KAAKmC,IAAIF,EAAoBlB,IAMjC,SAASqB,EAAiBrB,GAC7B,OAAOkB,EAAoBlB,GAAU,EAOlC,SAASsB,EAAUtB,GACtB,IAAMuB,EAAIvB,EAAOvF,OACjB,KAAI8G,EAAI,GAAR,CAGA,IADA,IAAIC,EAAO,EACF7E,EAAI,EAAGA,EAAI4E,EAAG5E,IAAK,CACxB,IAAMuB,EAAI8B,EAAOrD,EAAE,GACbwB,EAAI6B,EAAOrD,GACX8E,EAAIzB,GAAQrD,EAAE,GAAK4E,GAEnBG,EAAOzC,KAAKuC,MAAMrD,EAAE,GAAKD,EAAE,KAAOuD,EAAE,GAAKtD,EAAE,KAAOA,EAAE,GAAKD,EAAE,KAAOuD,EAAE,GAAKtD,EAAE,KAEjF,GAAa,IAATqD,EAAYA,EAAOE,OAClB,GAAa,IAATA,GAAcF,IAASE,EAAM,OAAO,EAGjD,OAAO,GAOJ,SAASC,EAAe3B,GAC3B,IAAM4B,EAAI5B,EAAO,GACXuB,EAAIvB,EAAOA,EAAOvF,OAAS,GACjC,OAAOmH,EAAE,KAAOL,EAAE,IAAMK,EAAE,KAAOL,EAAE,GAMhC,SAASM,EAAW7B,GAGvB,IAFA,IAAIE,EAAM,EAEDvD,EAAI,EAAGA,EAAIqD,EAAOvF,OAAQkC,IAAK,CACpC,IAAMmF,EAAK9B,EAAOrD,GAAG,GAAKqD,EAAOrD,EAAE,GAAG,GAChCoF,EAAK/B,EAAOrD,GAAG,GAAKqD,EAAOrD,EAAE,GAAG,GACtCuD,GAAOjB,KAAK+C,KAAKF,EAAKA,EAAKC,EAAKA,GAGpC,OAAO7B,EC7EJ,SAAS+B,EAAmB/E,EAAM8C,GAAqC,IAAfkC,EAAc,uDAAN,KAC3D5H,EAAa4C,EAAb5C,SAER,GAAI6H,EAAoB7H,EAAU,KAAM,YAC/BgH,EAAStB,GACV,OAAO,EAGf,GAAImC,EAAoB7H,EAAU,KAAM,YAChCgH,EAAStB,GACT,OAAO,EAGf,GAAImC,EAAoB7H,EAAU,KAAM,cAChC+G,EAAgBrB,GAChB,OAAO,EAGf,GAAImC,EAAoB7H,EAAU,KAAM,oBAC/B+G,EAAgBrB,GACjB,OAAO,EAGf,GAAImC,EAAoB7H,EAAU,KAAM,iBAChC4H,EAAM,KAAOA,EAAMlC,EAAOvF,OAAS,GACnC,OAAO,EAGf,IA5ByE,EA4BnE2H,EAAmB9H,EAASZ,cAAc+C,QAAO,SAAAgF,GAAC,MAAe,QAAXA,EAAE3D,QA5BW,cA8BxDsE,GA9BwD,IA8BzE,2BAAmC,CAAC,IAAzBC,EAAwB,QAC/B,GAA4B,kBAAjBA,EAAGxE,OAAO,GACjB,OAAO,EAEX,IAAMjC,EAAYyG,EAAGxE,OAAO,GAGtByE,EAAiB,CACnBC,KAAM,kBAAMpB,EAAQnB,IACpBvF,OAAQ,kBAAMoH,EAAU7B,IACxBpB,MAAO,kBAAM0B,EAAeN,GAAQ,IACpCnB,OAAQ,kBAAMyB,EAAeN,GAAQ,KAGnC3E,EAAQ8B,EAAcvB,EAAW0G,GAEvC,IAAKjH,EAAO,OAAO,GA9CkD,8BAiDzE,OAAO,EASX,SAAS8G,EAAqB7H,EAAUwD,GAAkB,IAAD,uBAARD,EAAQ,iCAARA,EAAQ,kBACrD,OAAOvD,EAASZ,cAAc8I,MAAK,SAAAf,GAAC,OAAIA,EAAE3D,OAASA,GAAQ2D,EAAE5D,OAAO,KAAOA,EAAO,MCnE/E,SAAS4E,EAAWvF,EAAM3C,EAAS0C,GACtC,IAAIyF,EAAUxF,EAAKb,aAAL,QAEd,IAAKqG,EACD,MAAO,GAMX,IAJA,IAAIhH,EAAQ,EAENF,EAAM,GAELE,EAAQgH,EAAQjI,QAAQ,CAC3B,IAAMgH,EAAIiB,EAAQ3H,OAAOW,GAErBf,EAAI,OAAOC,KAAK6G,GACpB,GAAI9G,EACAe,GAASf,EAAE,GAAGF,YAKlB,GADAE,EAAI,gBAAgBC,KAAK6G,GAErBjG,EAAIS,KAAKtB,EAAE,GAAGgI,QAAQ,OAAb,KAA0BA,QAAQ,OAAlC,OACTjH,GAASf,EAAE,GAAGF,YAKlB,GADAE,EAAI,kBAAkBC,KAAK6G,GAEvBjG,EAAIS,KAAK1B,EAAQd,KAAKkB,EAAE,KAAO,IAC/Be,GAASf,EAAE,GAAGF,WAFlB,CAOA,KADAE,EAAI,oBAAoBC,KAAK6G,IAc7B,MAAO,IAZU,SAAT9G,EAAE,GAAea,EAAIS,KAAK1B,EAAQf,MACpB,SAATmB,EAAE,GAAea,EAAIS,KAAKpC,OAAOC,QAAQS,EAAQd,MAAMM,KAAI,mCAAEvB,EAAF,KAAOkC,EAAP,sBAAsBlC,EAAtB,YAA6BkC,EAA7B,QAAuCN,KAAK,OAC9F,aAATO,EAAE,IAAsC,SAAjBJ,EAAQf,KAAiBgC,EAAIS,KAAJ,WAAa1B,EAAQoF,IAArB,YAA4BpF,EAAQqF,IAApC,MACvC,eAATjF,EAAE,IAAyC,QAAjBJ,EAAQf,MAAmC,SAAjBe,EAAQf,KAGnD,UAATmB,EAAE,IAAgBa,EAAIS,KAAKgB,EAAQ0B,MAAMiE,YAHqCpH,EAAIS,KAAK1B,EAAQ2H,MAAMzH,OAAOmI,YAIrHlH,GAASf,EAAE,GAAGF,QAQtB,OAAOe,EAAIpB,KAAK,IC/Bb,SAASyI,EAAUC,EAAOC,GAAQ,IAAD,EACVD,EAAMxG,MAAM,KADF,mBAC7B0G,EAD6B,KACzBC,EADyB,KACrBC,EADqB,KACjBC,EADiB,OAEVJ,EAAMzG,MAAM,KAFF,mBAE7B8G,EAF6B,KAEzBC,EAFyB,KAErBC,EAFqB,KAEjBC,EAFiB,KAIpC,OAAQH,GAAOJ,GAAOK,GAAOJ,GAAOK,GAAOJ,GAAOK,GAAOJ,EAOtD,SAAShC,EAASqC,GACrB,IAAMC,EAAQD,EAAKlH,MAAM,KACzB,QAASmH,EAAM,IAAMA,EAAM,MAAQA,EAAM,IAAMA,EAAM,IASlD,SAASC,EAAUhF,EAAQiF,EAAMC,GACpC,IAD0C,cAGrBlF,EAHqB,GAGlCiB,EAHkC,KAG7BC,EAH6B,mBAIhBgE,EAJgB,GAIlChF,EAJkC,KAI3BC,EAJ2B,KAMpCG,EAAYC,KAAKC,IAAI,EAAGyE,GAOxBE,EANQ,IAAM7E,GAGDJ,EATE,KAafkF,EANQ,IAAM9E,GAGDH,EAVE,KAerB,MAAO,CAAEc,EAAMkE,EAAMjE,EAAMkE,EAAMnE,EAAMkE,EAAMjE,EAAMkE,GAAO/J,KAAI,SAAAoG,GAAC,OAAIA,EAAE4D,QAAQ,MAAI3J,KAAK,K,ICtDrE4J,E,mGAOL/G,EAASC,GAAoB,IAAd+G,EAAa,uDAAJ,GAG1BC,EAAU,GAChBD,EAASvH,SAAQ,SAAAyH,GAAC,MAAe,SAAXA,EAAE3K,OAAoB0K,EAAQC,EAAEC,IAAMD,MAG5D,IAAME,EAAS,GACfJ,EAASvH,SAAQ,SAAAyH,GAAC,MAAe,QAAXA,EAAE3K,OAAmB6K,EAAOF,EAAEC,IAAMD,MARtB,IAU5BzF,EAAgCzB,EAAhCyB,OAAQiF,EAAwB1G,EAAxB0G,KAAM/E,EAAkB3B,EAAlB2B,MAAOC,EAAW5B,EAAX4B,OAGvByF,EAAa7F,EAAmBC,EAAQiF,EAAM/E,EAAOC,GAG3DjF,KAAK2K,YAAYtH,EAASC,GAhBU,IAkB5B1D,EAAS0D,EAAK5C,SAAdd,KAGR,OAAQA,GACJ,IAAK,MACD,IAAMwG,EAASgB,EAAa,EAAG,EAAGpC,EAAOC,GACrC3B,EAAK5C,SAASX,cACdC,KAAK4K,oBAAoBvH,EAASC,EAAM8C,EAAQ,KAAM,MAEtDpG,KAAK6K,WAAWxH,EAASC,EAAM8C,EAAQ,MAC3C,MAEJ,IAAK,UACD,GAAI/C,EAAQyH,QAAS,CACjB,IAAMC,EAAS1H,EAAQyH,QACvB9K,KAAKgL,YAAY3H,EAASC,EAAMoH,EAAWK,EAAOE,UAAWF,EAAOG,WAExE,MAEJ,IAAK,YACDlL,KAAKmL,gBAAgB9H,EAASC,EAAMoH,GACpC,MAEJ,IAAK,QACD1K,KAAKgL,YAAY3H,EAASC,EAAM,CAAC,EAAG,IACpC,MAEJ,4BAEqB+G,GAFrB,IAEI,2BAA2B,CAAC,IAAjBe,EAAgB,QACvB,GAAK3K,EAAc6C,EAAK5C,SAAU0K,GAElC,OAAQxL,GACJ,IAAK,OACD,GAAgB,SAAZwL,EAAGxL,KAAiB,SAExB,IAAMkH,EAAQ4D,EAAWU,EAAGrF,IAAKqF,EAAGpF,KAEhC1C,EAAK5C,SAASX,cACdC,KAAK4K,oBAAoBvH,EAASC,EAAM,CAACwD,GAAQsE,EAAI,CAACA,IAGtDpL,KAAKgL,YAAY3H,EAASC,EAAMwD,EAAOsE,GAE3C,MAEJ,IAAK,MACL,IAAK,OACD,GAAgB,QAAZA,EAAGxL,KAAgB,SAGvB,IAAM0I,EAAQ8C,EAAG9C,MAAMnI,KAAI,SAAAqK,GAAE,OAAIF,EAAQE,MACnCpE,EAASkC,EAAMnI,KAAI,SAAAoK,GAAC,OAAIG,EAAWH,EAAExE,IAAKwE,EAAEvE,QAElD,IAAKqC,EAAmB/E,EAAM8C,EAAQgF,EAAI9C,GAAQ,SAE9ChF,EAAK5C,SAASX,cACdC,KAAK4K,oBAAoBvH,EAASC,EAAM8C,EAAQgF,EAAI9C,GAIvC,SAAT1I,EACAI,KAAK6K,WAAWxH,EAASC,EAAM8C,EAAQgF,GAEvCpL,KAAKqL,WAAWhI,EAASC,EAAM8C,EAAQgF,GAG/C,MAEJ,IAAK,WACD,GAAgB,aAAZA,EAAGxL,KAAqB,WA3C5C,kC,kCAqDKyD,EAASC,EAAMwD,M,iCAEhBzD,EAASC,EAAM8C,GAAuB,IAAfzF,EAAc,uDAAN,KACvCX,KAAKsL,eAAejI,EAASC,EAAM8C,EAAQO,EAAahG,K,iCAGhD0C,EAASC,EAAM8C,GAAuB,IAAfzF,EAAc,uDAAN,KACjB,IAAlByF,EAAOvF,SAGNkH,EAAc3B,KACfA,EAAM,sBAAQA,GAAR,CAAgBA,EAAO,MAGjCpG,KAAKsL,eAAejI,EAASC,EAAM8C,EAAQI,EAAgB7F,M,qCAG/C0C,EAASC,EAAM8C,EAAQmF,M,0CASnBlI,EAASC,EAAM8C,GAAmC,IAA3BzF,EAA0B,uDAAlB,KAC/C,OAAQ2C,EAAK5C,SAASX,eAClB,IAAK,SACL,IAAK,SAED,IAAMyL,EAAchF,EAAeJ,GACnCpG,KAAKgL,YAAY3H,EAASC,EAAMkI,EAAa7K,GAC7C,MAEJ,IAAK,YAED,IAAM8K,EAAW9E,EAAYP,GAC7BpG,KAAKgL,YAAY3H,EAASC,EAAMmI,EAAU9K,GAC1C,MAEJ,IAAK,gBAED,IAAM+K,EAAWvF,EAAgBC,GACjCpG,KAAKgL,YAAY1H,EAAMoI,EAAU/K,EAAS0C,GAC1C,MAEJ,IAAK,QAEDrD,KAAKgL,YAAY3H,EAASC,EAAM8C,EAAO,GAAIzF,GAC3C,MAEJ,IAAK,MAEDX,KAAKgL,YAAY3H,EAASC,EAAM8C,EAAOA,EAAOvF,OAAS,GAAIF,GAC3D,MAEJ,IAAK,iBAID,MAEJ,IAAK,eACD,IAAMgL,EAAWjF,EAAeN,GAE1BwF,EAAiBxE,EAAY,WAAZ,cAAgBuE,IAEvC3L,KAAK6K,WAAWxH,EAASC,EAAMsI,EAAgBjL,GAC/C,MAEJ,IAAK,cAAgB,IACToE,EAAU1B,EAAV0B,MADQ,cAEDqB,EAAO,GAFN,GAEV/B,EAFU,KAEPgD,EAFO,KAIVyB,EAAUD,EAAWvF,EAAM3C,EAAS0C,GAE1C,IAAKyF,EAAS,OAEd,IAEI+C,EAVY,EAQZ7G,EAAQiC,OAAOE,kBACf2E,EAAM7E,OAAO8E,IAEbC,EAAW3E,EAXC,cAYGyB,EAAQpG,MAAM,OAZjB,IAYhB,2BAAwC,CAAC,IAA9BuJ,EAA6B,QAC9BjC,EAAOhK,KAAKkM,YAAY7I,EAASC,EAAM2I,GAE7CjH,EAAQK,KAAK2B,IAAIhC,EAAOgF,EAAKhF,OAEzB3D,MAAMyK,KAAMA,EAAMzE,EAAI2C,EAAKmC,WAE/BN,EAASG,EAAWhC,EAAKoC,WAEzBJ,GAAYhC,EAAK/E,QArBL,8BAwBhB,IAAMoH,EAAU/I,EAAKb,aAAL,QAA+B6J,WAAWhJ,EAAKb,aAAL,SAAgCsC,EAAQ,EAE1D,WAApCzB,EAAKb,aAAa,eAAkE,WAApCa,EAAKb,aAAa,cAClE4B,GAAKW,EAAQ,EAE4B,UAApC1B,EAAKb,aAAa,gBACvB4B,GAAKW,GAIT,IAAMuH,EAAc,CAChB,CAAElI,EAAIgI,EAAmBP,EAAMO,GAC/B,CAAEhI,EAAIgI,EAAmBR,EAASQ,GAClC,CAAEhI,EAAIW,EAAQqH,EAAWR,EAASQ,GAClC,CAAEhI,EAAIW,EAAQqH,EAAWP,EAAMO,IAInCE,EAAYlK,KAAKkK,EAAY,IAE7BvM,KAAKsL,eAAejI,EAASC,EAAMiJ,GAAa,kBAAMnG,EAAO,KAAIzF,GACjE,MAEJ,IAAK,WACD,GAA2B,QAAvB2C,EAAK5C,SAASd,KAAgB,CAC9B,IAAM+H,EAAIvB,EAAOvF,OAAS,EACpB2L,EAAkBpG,EAAOvD,QAAO,SAAC0D,EAAGxD,GAAJ,OAAUA,EAAI,KAAO,GAAKA,IAAM4E,KACtE3H,KAAKqL,WAAWhI,EAASC,EAAMkJ,EAAiB7L,O,sCAO/C0C,EAASC,EAAMoH,GAC5B,IAAM+B,EAAWnJ,EAAK5C,SAASZ,cAAc4M,MAAK,SAAAnG,GAAC,MAAe,aAAXA,EAAErC,QACnDyI,EAAarJ,EAAK5C,SAASZ,cAAc4M,MAAK,SAAAnG,GAAC,MAAe,eAAXA,EAAErC,QAEnDc,EAAgC3B,EAAhC2B,MAAOC,EAAyB5B,EAAzB4B,OAGT4E,EADOC,EAF2BzG,EAAjByB,OAAiBzB,EAAT0G,KAEK,CAAC/E,EAAOC,IACzBvC,MAAM,KAEzB,GAAI+J,EAYA,IAXA,IAAMG,EAAON,WAAWG,EAASxI,OAAO,IAElC4I,EAAQ,EAAID,EAEZE,EAAUzH,KAAK0H,KAAK1H,KAAK2H,MAAMH,IAE/BI,EAAO5H,KAAKuB,OAAOiD,EAAM,GAAKgD,GAASA,EACvCK,EAAO7H,KAAK0H,MAAMlD,EAAM,GAAKgD,GAASA,EACtCM,EAAO9H,KAAKuB,OAAOiD,EAAM,GAAKgD,GAASA,EACvCO,EAAO/H,KAAK0H,MAAMlD,EAAM,GAAKgD,GAASA,EAEnC9J,EAAIkK,EAAMlK,GAAKmK,EAAMnK,GAAK6J,EAAM,CACrC,IAAMxG,EAAS,CAAEsE,EAAW3H,EAAGoK,GAAQzC,EAAW3H,GAAIoK,EAAOC,GAAQ,GAAI1C,EAAW3H,EAAGqK,IACvFpN,KAAKqL,WAAWhI,EAASC,EAAM8C,EAAQ,CAAExG,KAAM,MAAO4K,GAAI,EAAGlC,MAAO,GAAIzI,KAAM,CAAEqE,KAAMnB,EAAEoH,QAAQ2C,MAIxG,GAAIH,EAYA,IAXA,IAAMC,EAAON,WAAWK,EAAW1I,OAAO,IAEpC4I,EAAQ,EAAID,EAEZE,EAAUzH,KAAK0H,KAAK1H,KAAK2H,MAAMH,IAE/BI,EAAO5H,KAAKuB,OAAOiD,EAAM,GAAKgD,GAASA,EACvCK,EAAO7H,KAAK0H,MAAMlD,EAAM,GAAKgD,GAASA,EACtCM,EAAO9H,KAAKuB,OAAOiD,EAAM,GAAKgD,GAASA,EACvCO,EAAO/H,KAAK0H,MAAMlD,EAAM,GAAKgD,GAASA,EAEnCQ,EAAIF,EAAME,GAAKD,EAAMC,GAAKT,EAAM,CACrC,IAAMxG,EAAS,CAAEsE,EAAWuC,EAAMI,GAAI3C,GAAYuC,EAAOC,GAAQ,EAAGG,GAAI3C,EAAWwC,EAAMG,IACzFrN,KAAKqL,WAAWhI,EAASC,EAAM8C,EAAQ,CAAExG,KAAM,MAAO4K,GAAI,EAAGlC,MAAO,GAAIzI,KAAM,CAAEqE,KAAMmJ,EAAElD,QAAQ2C,S,4BAKrGzJ,M,kCAEMA,EAASC,M,kCASTD,EAASC,EAAMM,GACxB,MAAO,CAAEoB,MAAO,EAAGmH,UAAW,EAAGC,WAAY,EAAGnH,OAAQ,O,KC7SzD,SAASqI,EAAgBhK,EAAMyB,GAClC,IAEIwI,EAFEC,EAAYlK,EAAKb,aAAL,KACdgL,EAAcnK,EAAKb,aAAL,OAGlB,GAAIgL,EAAa,CAEb,IAAIC,EAAaD,EAAY1E,QAAQ,cAAc,SAAA4E,GAAE,MAAI,IAAIC,OAAOD,EAAG9M,WAIvE6M,GADAA,EAAaA,EAAW3E,QAAQ,gBAAiB,SACzBA,QAAQ,gBAAiB,WAKjD,IACM8E,EADO,4BACG7M,KAAK0M,GACjBG,IACAN,GAAaM,EAAG,GAAK9I,EACrB0I,EAAcA,EAAY1E,QAAQ8E,EAAG,GAAI,KAQjD,OAJIvK,EAAKb,aAAa,kBAClB8K,GAAajK,EAAKb,aAAa,gBAAkBsC,GAG9C,CACHyI,YACAC,cACAF,aCzBD,SAASO,EAAeC,EAAKzK,EAAMyB,GAAQ,IAAD,EACCuI,EAAgBhK,EAAMyB,GAA5DyI,EADqC,EACrCA,UAAWC,EAD0B,EAC1BA,YAAaF,EADa,EACbA,UAEhCQ,EAAIP,UAAYA,EAChBO,EAAIN,YAAcA,EAClBM,EAAIR,UAAYA,ECCb,SAASS,EAAWD,EAAKzK,EAAzB,GAAiE,IAAD,mBAAhCe,EAAgC,KAA7BgD,EAA6B,KAAzB1G,EAAyB,uDAAf,KAAM0C,EAAS,uCACnEyK,EAAcC,EAAKzK,EAAMD,EAAQ0B,OAEjC,IAAI+D,EAAUD,EAAWvF,EAAM3C,EAAS0C,GAExC4K,EAAQF,EAAKzK,EAAMD,EAAQ0B,OALwC,oBAOhD+D,EAAQpG,MAAM,OAPkC,IAOnE,2BAAwC,CAAC,IAA9BuJ,EAA6B,QACpC5E,GAAKgE,EAAW0C,EAAKzK,EAAM2I,EAAM5H,EAAGgD,IAR2B,+BAmBvE,SAASgE,EAAW0C,EAAKzK,EAAMwF,EAASzE,EAAGgD,GACvC,IAAM2C,EAAO+D,EAAI7B,YAAYpD,GAE7B,GAAIxF,EAAKb,aAAa,cAAe,CACjC,IAAMyL,EAAYlE,EAAKhF,MAEiB,WAApC1B,EAAKb,aAAa,eAAkE,WAApCa,EAAKb,aAAa,cAClE4B,GAAK6J,EAAY,EAEwB,UAApC5K,EAAKb,aAAa,gBACvB4B,GAAK6J,GAeb,OAXI5K,EAAKb,aAAa,iBAClBsL,EAAIN,YAAcnK,EAAKb,aAAa,eACpCsL,EAAII,WAAWrF,EAASzE,EAAGgD,KAG3B/D,EAAKb,aAAa,eAAkBa,EAAKb,aAAa,iBACtDsL,EAAIP,UAAYlK,EAAKb,aAAa,cAClCsL,EAAIK,SAAStF,EAASzE,EAAGgD,IAGd2C,EAAKqE,wBAA0BrE,EAAKsE,yBAShD,SAASL,EAAQF,EAAKzK,EAAMyB,GAC/B,IAAIwJ,EAAQ,UAAM,GAAKxJ,EAAX,MACRyJ,EAAa,SACbC,EAAa,aAEbnL,EAAKb,aAAL,KAGAsL,EAAIW,KAAOpL,EAAKb,aAAL,KAA0BsG,QAAQ,iBAAiB,SAAApG,GAAC,iBAAQA,EAAIoC,OAGvEzB,EAAKb,aAAa,eAClB8L,EAAWjL,EAAKb,aAAa,aAAasG,QAAQ,aAAa,SAAAhI,GAAC,iBAAQA,EAAIgE,OAG5EzB,EAAKb,aAAa,iBAClB+L,EAAalL,EAAKb,aAAa,gBAG/Ba,EAAKb,aAAa,iBAClBgM,EAAanL,EAAKb,aAAa,gBAGnCsL,EAAIW,KAAJ,UAAcF,EAAd,YAA4BD,EAA5B,YAAwCE,ICjFzC,SAASE,EAAeZ,EAAKzK,EAAMyB,GAEtC,GAAIzB,EAAKb,aAAL,UAIA,IAHA,IAEI1B,EAFE6N,EAAI,6BACJC,EAAIvL,EAAKb,aAAL,UAEH1B,EAAI6N,EAAE5N,KAAK6N,IAAI,CAClB,IAAMC,EAAQ/N,EAAE,GACVkD,EAASlD,EAAE,GAAG2B,MAAM,KAAKvC,KAAI,SAAAwC,GAAC,MAAK,CAAE7B,MAAOwL,WAAW3J,GAAKoC,EAAOgK,KAAMpM,EAAEoG,QAAQ,YAAa,QACtG,OAAQ+F,GACJ,IAAK,SAEDf,EAAIiB,UAAJ,MAAAjB,EAAG,YAAc9J,EAAO9D,KAAI,SAAAoG,GAAC,OAAIA,EAAEzF,WACnC,MACJ,IAAK,SAAW,IAAD,EACWmD,EAAO,GAAvBnD,EADK,EACLA,MAAOiO,EADF,EACEA,KAEA,QAATA,EACAjO,GAASuE,KAAKK,GAAK,IACH,SAATqJ,IACPjO,GAAmB,EAAVuE,KAAKK,IAGlBqI,EAAIkB,OAAOnO,GACX,MAEJ,IAAK,QACD,IAAMuD,EAAIJ,EAAO,GAAGnD,MACduG,EAAIpD,EAAO,GAAKA,EAAO,GAAGnD,MAAQuD,EACxC0J,EAAIhJ,MAAMV,EAAGgD,GACb,MACJ,IAAK,YAED0G,EAAImB,UAAJ,MAAAnB,EAAG,YAAc9J,EAAO9D,KAAI,SAAAoG,GAAC,OAAIA,EAAEzF,WACnC,MACJ,IAAK,OAAL,MAC0BmD,EAAO,GAAvBnD,EADV,EACUA,MAAOiO,EADjB,EACiBA,KAEA,QAATA,EACAjO,EAAQuE,KAAKS,IAAIhF,GACH,QAATiO,IACLjO,EAAQuE,KAAKS,IAAIhF,EAAQuE,KAAKK,GAAK,MAEvC,IAAIyJ,EAAS,EAEb,GAAIlL,EAAO,GAAI,CAAC,IAAD,EACWA,EAAO,GAAvBnD,EADK,EACLA,MAAOiO,EADF,EACEA,KAEA,QAATA,EACAjO,EAAQuE,KAAKS,IAAIhF,GACH,QAATiO,IACLjO,EAAQuE,KAAKS,IAAIhF,EAAQuE,KAAKK,GAAK,MAEvCyJ,EAASrO,EAGbiN,EAAIiB,UAAU,EAAGG,EAAQrO,EAAO,EAAG,EAAG,KCjDnD,SAASkK,GAAY+C,EAAKzK,EAA1B,GAAuE,IAAD,mBAArCe,EAAqC,KAAlCgD,EAAkC,KAA9B1G,EAA8B,uDAApB,KAAM0C,EAAc,uDAAJ,GACrE0K,EAAIqB,OADqE,IAGjErK,EAAU1B,EAAV0B,MAYR,GAVA+I,EAAcC,EAAKzK,EAAMyB,GAEa,aAAlCzB,EAAKb,aAAL,WACA4B,GAAKiI,WAAWhJ,EAAKb,aAAL,OAA8B,GAAKsC,EACnDsC,GAAKiF,WAAWhJ,EAAKb,aAAL,MAA6B,GAAKsC,GAEtDgJ,EAAImB,UAAU7K,EAAGgD,GAEjBsH,EAAeZ,EAAKzK,EAAMyB,GAEtBzB,EAAKb,aAAL,KAA2B,CAC3BsL,EAAIsB,YAEJ,IAAMT,GAAKtL,EAAKb,aAAL,KAA4BsC,EAEvCgJ,EAAIuB,QAAQ,EAAG,EAAGV,EAAGA,EAAG,EAAG,EAAa,EAAVvJ,KAAKK,IAEnCpC,EAAKb,aAAL,MAA6BsL,EAAIwB,OACjCjM,EAAKb,aAAL,QAA+BsL,EAAIyB,SAGnClM,EAAKb,aAAL,OACAsL,EAAIsB,YAEJI,GAAS1B,EAAKzK,EAAKb,aAAL,KAA2BsC,GAEzCzB,EAAKb,aAAL,MAA6BsL,EAAIwB,OACjCjM,EAAKb,aAAL,QAA+BsL,EAAIyB,UAMvC,IAAME,EAAQ,iDACd,GAAIA,EAAMnP,KAAK+C,EAAKb,aAAL,MAA4B,CACvC,IAAM1B,EAAI2O,EAAM1O,KAAKsC,EAAKb,aAAL,MACfkN,EAAM5O,EAAE,GACR6O,EAAM,IAAIC,MAChBD,EAAIE,IAAMH,EACV,IAAMI,EAAIzD,WAAWvL,EAAE,IACjBiP,EAAI1D,WAAWvL,EAAE,IAGvB6O,EAAIK,iBAAiB,QAAQ,WASzB,GAPAlC,EAAIqB,OAGJrB,EAAImB,UAAU7K,EAAGgD,GAIb0I,EAAG,CACH,IAAM9K,EAAU5D,MAAM2O,GAASJ,EAAI3K,QAAU8K,EAAIH,EAAI5K,OAA1BgL,EAC3BjC,EAAImC,UAAUN,EAAK,EAAG,EAAGG,EAAIhL,EAAOE,EAASF,QAG7CgJ,EAAImC,UAAUN,EAAK,EAAG,GAG1B7B,EAAIoC,aAIR7M,EAAKb,aAAL,SACAuL,EAAWD,EAAKzK,EAAM,CAAC,EAAG,GAAI3C,EAAS0C,GAG3C0K,EAAIoC,UAOR,SAASV,GAAU1B,EAAKqC,EAAUrL,GAQ9B,IAPA,IACItD,EAEA4O,EAEAC,EALEC,EAAO,8IAON9O,EAAQ8O,EAAKvP,KAAKoP,IAAW,CAChC,IAAM/L,EAAIiI,WAAW7K,EAAM,IAAMsD,EAC3BsC,EAAIiF,WAAW7K,EAAM,IAAMsD,EAC3ByL,EAAKlE,WAAW7K,EAAM,IAAMsD,EAC5B0L,EAAKnE,WAAW7K,EAAM,IAAMsD,EAC5B2L,EAAKpE,WAAW7K,EAAM,IAAMsD,EAC5B4L,EAAKrE,WAAW7K,EAAM,IAAMsD,EAE7BsL,IAAOA,EAAQ,CAAChM,EAAEgD,IAEN,MAAb5F,EAAM,IACN6O,EAAO,CAACjM,EAAEgD,GACV0G,EAAI6C,OAAOvM,EAAGgD,IAEI,MAAb5F,EAAM,IACX6O,EAAO,CAACjM,EAAEgD,GACV0G,EAAI8C,OAAOxM,EAAGgD,IAEI,MAAb5F,EAAM,IACX6O,EAAO,CAACE,EAAGC,GACX1C,EAAI+C,iBAAiBzM,EAAGgD,EAAGmJ,EAAIC,IAEb,MAAbhP,EAAM,IACX6O,EAAO,CAACI,EAAGC,GACX5C,EAAIgD,cAAc1M,EAAGgD,EAAGmJ,EAAIC,EAAIC,EAAIC,IAElB,MAAblP,EAAM,IACX6O,EAAOD,EACPtC,EAAI8C,OAAJ,MAAA9C,EAAG,YAAWuC,KAEI,MAAb7O,EAAM,IACX6O,EAAO,CAACA,EAAK,GAAIjM,GACjB0J,EAAI8C,OAAJ,MAAA9C,EAAG,YAAWuC,KAEI,MAAb7O,EAAM,IACX6O,EAAO,CAACjM,EAAGiM,EAAK,IAChBvC,EAAI8C,OAAJ,MAAA9C,EAAG,YAAWuC,KAEI,MAAb7O,EAAM,IACX6O,EAAO,CAACA,EAAK,GAAKjM,EAAGiM,EAAK,GAAKjJ,GAC/B0G,EAAI6C,OAAJ,MAAA7C,EAAG,YAAWuC,KAEI,MAAb7O,EAAM,IACX6O,EAAO,CAACA,EAAK,GAAKjM,EAAGiM,EAAK,GAAKjJ,GAC/B0G,EAAI8C,OAAJ,MAAA9C,EAAG,YAAWuC,KAEI,MAAb7O,EAAM,IACXsM,EAAI+C,iBAAiBR,EAAK,GAAKjM,EAAGiM,EAAK,GAAKjJ,EAAGiJ,EAAK,GAAKE,EAAIF,EAAK,GAAKG,GACvEH,EAAO,CAACA,EAAK,GAAKE,EAAIF,EAAK,GAAKG,IAEd,MAAbhP,EAAM,IACX6O,EAAO,CAACI,EAAGC,GACX5C,EAAIgD,cAAcT,EAAK,GAAKjM,EAAGiM,EAAK,GAAKjJ,EAAGiJ,EAAK,GAAKE,EAAIF,EAAK,GAAKG,EAAIH,EAAK,GAAKI,EAAIJ,EAAK,GAAKK,GAChGL,EAAO,CAACA,EAAK,GAAKI,EAAIJ,EAAK,GAAKK,IAEd,MAAblP,EAAM,IACX6O,EAAOD,EACPtC,EAAI8C,OAAJ,MAAA9C,EAAG,YAAWsC,KAEI,MAAb5O,EAAM,IACX6O,EAAO,CAACA,EAAK,GAAIA,EAAK,GAAKjM,GAC3B0J,EAAI8C,OAAJ,MAAA9C,EAAG,YAAWuC,KAEI,MAAb7O,EAAM,KACX6O,EAAO,CAACA,EAAK,GAAKjM,EAAGiM,EAAK,IAC1BvC,EAAI8C,OAAJ,MAAA9C,EAAG,YAAWuC,M,ICtKLU,G,WAIjB,aAAgB,oBAEZhR,KAAKiR,KAAO,G,oDAIZjR,KAAKiR,KAAO,K,0BAQXC,EAAKC,GACDnR,KAAKiR,KAAKC,KAAMlR,KAAKiR,KAAKC,GAAO,IAD3B,oBAGSlR,KAAKiR,KAAKC,IAHnB,IAGX,2BAAoC,CAChC,GAAIE,GAAWD,EADiB,SACJ,OAAO,GAJ5B,8BASX,OAFAnR,KAAKiR,KAAKC,GAAK7O,KAAK8O,IAEb,K,4CAQP,OAJKnR,KAAKqR,YACNrR,KAAKqR,UAAY,IAAIL,GAGlBhR,KAAKqR,c,KAUpB,SAASD,GAAYE,EAAMC,GACvB,IAAMC,EAAMF,EAAK,GACXG,EAAMH,EAAK,GACXI,EAAMJ,EAAK,GAAKA,EAAK,GACrBK,EAAML,EAAK,GAAKA,EAAK,GACrBM,EAAML,EAAK,GACXM,EAAMN,EAAK,GACXO,EAAMP,EAAK,GAAKA,EAAK,GACrBQ,EAAMR,EAAK,GAAKA,EAAK,GAC3B,OAAOC,EAAMM,GAAOJ,EAAME,GAAOH,EAAMM,GAAOJ,EAAME,ECtCjD,SAASvG,GAAeyC,EAAKzK,EAAM8C,EAAQmF,GAAyC,IAA/B5K,EAA8B,uDAApB,KAAM0C,EAAc,uDAAJ,GAClF,GAAsB,IAAlB+C,EAAOvF,OAAX,CAIA,GAAIyC,EAAKb,aAAa,iBAAkB,CACpC,IAAM0O,EAAMzK,EAAeN,GAE3B,GAAI9C,EAAKb,aAAa,kBAAmB,CACrC,IAAME,EAAI,eAAe3B,KAAKsC,EAAKb,aAAa,mBAE1CuP,GAAerP,EAAE,GAAK,IACtBoN,EAAIoB,EAAI,GACRnB,EAAImB,EAAI,GAEdA,EAAI,KAAO,EAAIa,GAAejC,EAAI,EAClCoB,EAAI,KAAO,EAAIa,GAAehC,EAAI,EAClCmB,EAAI,GAAKpB,EAAIiC,EACbb,EAAI,GAAKnB,EAAIgC,EAGjB,IAAMC,EAAkBjB,GAAgBkB,qBAExC,IAAKD,EAAgBE,IAAI7O,EAAKb,aAAa,iBAAkB0O,GAAM,CAC/D,IAAMiB,EAAS9O,EAAKb,aAAa,qBAAuB,OAExD,GAAe,SAAX2P,EACA,QAKZrE,EAAIqB,OAEJtB,EAAcC,EAAKzK,EAAMD,EAAQ0B,OAEjC,IAAIsN,EAAU,EACVC,EAAU,EAEd,GAAIhP,EAAKb,aAAL,UAAgC,CAIhC,IAAM8P,EAAKhH,EAASnF,GAGpBiM,EAAUE,EAAG,GACbD,EAAUC,EAAG,GAGbxE,EAAImB,UAAUmD,EAASC,GAGvB3D,EAAeZ,EAAKzK,EAAMD,EAAQ0B,OAGtCgJ,EAAIsB,YACJtB,EAAI6C,OAAOxK,EAAO,GAAG,GAAKiM,EAASjM,EAAO,GAAG,GAAKkM,GAClD,IAAK,IAAIvP,EAAI,EAAGA,EAAIqD,EAAOvF,OAAQkC,IAC/BgL,EAAI8C,OAAOzK,EAAOrD,GAAG,GAAKsP,EAASjM,EAAOrD,GAAG,GAAKuP,GAGtDhP,EAAKb,aAAL,MAA6BsL,EAAIwB,OACjCjM,EAAKb,aAAL,QAA+BsL,EAAIyB,SAEnCzB,EAAIoC,WAGA7M,EAAKb,aAAL,SAAgCa,EAAKb,aAAL,MAA6Ba,EAAKb,aAAL,MAA6Ba,EAAKb,aAAL,QAC1FsL,EAAIqB,OACJpE,GAAY+C,EAAKzK,EAAMiI,EAASnF,GAASzF,EAAS0C,GAClD0K,EAAIoC,Y,IC9ESqC,G,kDAKjB,WAAaC,GAAS,IAAD,8BACjB,gBACKA,OAASA,EAFG,E,kDAKdpP,GAAU,IACL2B,EAAkB3B,EAAlB2B,MAAOC,EAAW5B,EAAX4B,OAEfjF,KAAKyS,OAAOzN,MAAQA,EACpBhF,KAAKyS,OAAOxN,OAASA,I,iCAGb5B,EAASC,GAAoB,IAAd+G,EAAa,uDAAJ,GAC1B0D,EAAM/N,KAAKyS,OAAOC,WAAW,MACnC3E,EAAIqB,OACJ,kEAAiB/L,EAASC,EAAM+G,GAChC0D,EAAIoC,Y,oCAGe7M,GAAO,IAAhByB,EAAe,EAAfA,MACJgJ,EAAM/N,KAAKyS,OAAOC,WAAW,MAKnC,GAHIpP,EAAKb,aAAL,UACAsL,EAAI4E,aAAerP,EAAKb,aAAL,SAEe,aAAlCa,EAAKb,aAAL,SAA8C,CAC9C,IAAMqJ,GAAOQ,WAAWhJ,EAAKb,aAAL,MAA6B,GAAKsC,EACpDvB,GAAQ8I,WAAWhJ,EAAKb,aAAL,OAA8B,GAAKsC,EAE5DgJ,EAAImB,UAAU1L,EAAMsI,M,kCAIfzI,EAASC,EAAMwD,GAAsB,IAAfnG,EAAc,uDAAN,KACjCoN,EAAM/N,KAAKyS,OAAOC,WAAW,MACnC1H,GAAY+C,EAAKzK,EAAMwD,EAAOnG,EAAS0C,K,qCAG3BA,EAASC,EAAM8C,EAAQmF,GAAyB,IAAf5K,EAAc,uDAAN,KAC/CoN,EAAM/N,KAAKyS,OAAOC,WAAW,MACnCpH,GAAeyC,EAAKzK,EAAM8C,EAAQmF,EAAU5K,EAAS0C,K,kCAG5CA,EAASC,EAAMM,GACxB,IAAMmK,EAAM/N,KAAKyS,OAAOC,WAAW,MAEnCzE,EAAQF,EAAKzK,EADKD,EAAV0B,OAER,IAAMiF,EAAO+D,EAAI7B,YAAYtI,GACrBoB,EAAoFgF,EAApFhF,MAAiCoH,EAAmDpC,EAA7EsE,yBAA+DnC,EAAcnC,EAAvCqE,wBAErD,MAAO,CACHrJ,QACAmH,YACAC,aACAnH,OAAQkH,EAAYC,O,GA3DUhC,GCT3B,cACb,OAAO,IAAIwI,OAAO,IAA0B,+CCGzBC,G,kDAIjB,WAAaJ,GAAS,IAAD,8BACjB,gBAEKA,OAASA,EAAOK,6BAErB,EAAKC,OAAS,IAAIC,GAElB,EAAKD,OAAOE,YAAY,CAAER,OAAQ,EAAKA,QAAU,CAAE,EAAKA,SAPvC,E,kDAUdpP,GACHrD,KAAK+S,OAAOE,YAAY,CAAEC,OAAQ,QAAS7P,c,iCAGnCA,EAASC,EAAM6P,GACvBnT,KAAK+S,OAAOE,YAAY,CAAEC,OAAQ,aAAc7P,UAASC,a,GAnBrB8G,G,SCYrC,SAASkB,GAAe8H,EAAO9P,EAAM8C,EAAQmF,GAChD,GAAsB,IAAlBnF,EAAOvF,OAAX,CAIA,GAAIyC,EAAKb,aAAa,iBAAkB,CACpC,IAAM0O,EAAMzK,EAAeN,GAErB6L,EAAkBjB,GAAgBkB,qBAExC,IAAKD,EAAgBE,IAAI7O,EAAKb,aAAa,iBAAkB0O,GAAM,CAC/D,IAAMiB,EAAS9O,EAAKb,aAAa,qBAAuB,OAExD,GAAe,SAAX2P,EACA,QAKZ,IAAMiB,EAAO,CAAEzT,KAAM,QAEjByS,EAAU,EACVC,EAAU,EAEd,GAAIhP,EAAKb,aAAL,UAAgC,CAIhC,IAAM8P,EAAKhH,EAASnF,GAGpBiM,EAAUE,EAAG,GACbD,EAAUC,EAAG,GAQbc,EAAKrE,UAAY1L,EAAKb,aAAL,UAGrB,IAAM6Q,EAAI,GAEVA,EAAEjR,KAAF,aAAa+D,EAAO,GAAG,GAAKiM,GAASlI,QAAQ,GAA7C,aAAoD/D,EAAO,GAAG,GAAKkM,GAASnI,QAAQ,KACpF,IAAK,IAAIpH,EAAI,EAAGA,EAAIqD,EAAOvF,OAAQkC,IAC/BuQ,EAAEjR,KAAF,aAAa+D,EAAOrD,GAAG,GAAKsP,GAASlI,QAAQ,GAA7C,aAAoD/D,EAAOrD,GAAG,GAAKuP,GAASnI,QAAQ,KAGxFkJ,EAAKC,EAAIA,EAAE9S,KAAK,KAEhB4S,EAAM/I,SAAShI,KAAKgR,GAGhB/P,EAAKb,aAAL,SAAgCa,EAAKb,aAAL,MAA6Ba,EAAKb,aAAL,MAA6Ba,EAAKb,aAAL,M,IChE7E8Q,G,kDAKjB,WAAavO,EAAOC,GAAS,IAAD,8BACxB,gBACKuO,OAAS,GACd,EAAKxO,MAAQA,EACb,EAAKC,OAASA,EACd,EAAKwO,aAAe,KALI,E,oDASxBzT,KAAKwT,OAAO3S,OAAS,I,iCAQbwC,EAASC,GAAoB,IAAd+G,EAAa,uDAAJ,GAChCrK,KAAKyT,aAAe,CAAEpJ,SAAU,IAEhC,IAAMqJ,EAAUpG,EAAgBhK,GAEhCtD,KAAKyT,aAAajE,OAASkE,EAAQjG,YACnCzN,KAAKyT,aAAalE,KAAOmE,EAAQlG,WAAa,OAG9CmG,GAAW3T,KAAKyT,aAAcnQ,EAAMD,EAAQ0B,OAE5C,kEAAiB1B,EAASC,EAAM+G,GAEhCrK,KAAKwT,OAAOnR,KAAKrC,KAAKyT,gB,qCAGVpQ,EAASC,EAAM8C,EAAQmF,GAAyB,IAAf5K,EAAc,uDAAN,KACrD2K,GAAetL,KAAKyT,aAAcnQ,EAAM8C,EAAQmF,EAAU5K,EAAS0C,K,iCAInE,OAAOrD,KAAK4T,eAAepT,KAAK,M,+BAIhC,OAAO,IAAIqT,KAAK7T,KAAK4T,kB,qCAIrB,IAAM/J,EAAQ,GAEdA,EAAMxH,KAAN,0CAA8CrC,KAAKgF,MAAnD,YAA4DhF,KAAKiF,OAAjE,oBAAmFjF,KAAKgF,MAAxF,qBAA0GhF,KAAKiF,OAA/G,4CAHW,oBAKSjF,KAAKwT,QALd,IAKX,2BAAiC,CAAC,IAAvBJ,EAAsB,QACrB/I,EAAsB+I,EAAtB/I,SAAayJ,EADQ,aACCV,EADD,cAG7BvJ,EAAMxH,KAAN,aAAiB0R,GAAWD,GAA5B,QAH6B,oBAKPzJ,GALO,IAK7B,2BAAgC,CAAC,IAAtB1J,EAAqB,QACpBf,EAAkBe,EAAlBf,KAASkU,EADW,aACFnT,EADE,UAE5BkJ,EAAMxH,KAAN,WAAezC,EAAf,YAAuBmU,GAAWD,GAAlC,WAPyB,8BAU7BjK,EAAMxH,KAAN,WAfO,8BAmBX,OADAwH,EAAMxH,KAAN,UACOwH,M,GArEwBO,GAyEvC,SAAS2J,GAAWD,GAChB,OAAO7T,OAAOC,QAAQ4T,GAAMjR,QAAO,8CAAmC,qBAAnC,QAAgD1C,KAAI,mCAAEvB,EAAF,KAAOkC,EAAP,qBAAqBlC,EAArB,aAA6BkC,EAA7B,QAAuCN,KAAK,KAGhI,SAASmT,GAAWP,EAAO9P,EAAMyB,GAIpC,GAHIzB,EAAKb,aAAL,UACA2Q,EAAMY,SAAW1Q,EAAKb,aAAL,SAEiB,aAAlCa,EAAKb,aAAL,SAA8C,CAC9C,IAAMqJ,GAAOQ,WAAWhJ,EAAKb,aAAL,MAA6B,GAAKsC,EACpDvB,GAAQ8I,WAAWhJ,EAAKb,aAAL,OAA8B,GAAKsC,EAE5DqO,EAAMlE,UAAY,CAAC1L,EAAMsI,I,aC1FZmI,G,WACjB,aAAuC,IAA1B/P,EAAyB,uDAApB,mBAAoB,oBAClC,IAAMgQ,EAAUC,UAAUC,KAAKlQ,GAE/BgQ,EAAQjE,iBAAiB,iBAAiB,SAAAoE,GAEtC,IACMC,EADWD,EAAGE,OACDC,OACnBF,EAAGG,kBAAkB,QAAS,CAAEC,QAAS,OAE3BJ,EAAGG,kBAAkB,YAC7BE,YAAY,gBAAiB,CAAC,WAAY,OAAQ,QAAS,CAAEC,QAAQ,OAI/E5U,KAAKsU,GAAK,IAAI5P,SAAQ,SAACC,EAASkQ,GAC5BX,EAAQjE,iBAAiB,WAAW,SAAAoE,GAEhC,IAAMH,EAAWG,EAAGE,OACpB5P,EAAQuP,EAAQM,WAGpBN,EAAQjE,iBAAiB,QAAS4E,M,+FAKzBvM,G,+FACItI,KAAKsU,G,OAAhBA,E,OACAQ,EAAQR,EAAGS,YAAY,QAAS,aAAaC,YAAY,S,cAC/C1M,G,IAAhB,2BAAWiC,EAAY,QACnBuK,EAAMG,IAAI1K,G,4MAIHC,G,uFACMxK,KAAKsU,G,cAAhBA,E,yBAEC,IAAI5P,SAAQ,SAACC,EAASkQ,GACzB,IACMX,EADQI,EAAGS,YAAY,QAAS,YAAYC,YAAY,SACxCE,IAAI1K,GAC1B0J,EAAQjE,iBAAiB,WAAW,SAAA5Q,GAAC,OAAIsF,EAAQuP,EAAQM,WACzDN,EAAQjE,iBAAiB,SAAS,SAAA5Q,GAAC,OAAIwV,EAAOxV,U,sIAQ5C8V,GAAM,IAAD,OACX,OAAOzQ,QAAQ0Q,IAAID,EAAIhV,KAAI,SAAAqK,GAAE,OAAI,EAAK6K,QAAQ7K,S,kCASrCZ,EAAMlJ,GACf,IAAM9B,EAAM0W,GAAQ1L,EAAMlJ,GAC1B,OAAOV,KAAKuV,iBAAiB3W,K,gFAQTA,G,uFACHoB,KAAKsU,G,cAAhBA,E,yBACC,IAAI5P,SAAQ,SAACC,EAASkQ,GACzB,IACMX,EADcI,EAAGS,YAAY,WAAY,YAAYC,YAAY,YAC3CE,IAAItW,GAChCsV,EAAQjE,iBAAiB,WAAW,SAAA5Q,GAAC,OAAIsF,EAAQuP,EAAQM,WACzDN,EAAQjE,iBAAiB,QAAS4E,O,qLAUpBjL,EAAMlJ,G,uFACPV,KAAKsU,G,cAAhBA,E,yBAEC,IAAI5P,SAAQ,SAACC,EAASkQ,GACzB,IACM/S,EADcwS,EAAGS,YAAY,WAAY,YAAYC,YAAY,YAC7ClT,MAAM,iBAC1B0T,EAAQC,YAAYC,MAAM,CAAChV,EAAS,EAAE,KAAM,CAACA,EAASuG,OAAO0O,UAAU,uBACvEzB,EAAUpS,EAAM8T,cAAcJ,GAChCK,EAAQ,EACNC,EAAmC,EAAhBvO,EAAQqC,GACjCsK,EAAQjE,iBAAiB,WAAW,SAAA5Q,GAChC,IAAM0W,EAAS7B,EAAQM,OAEvB,GAAIuB,EAAQ,CAAC,IACDnX,EAAoBmX,EAApBnX,IAAKoX,EAAeD,EAAfC,WACPC,EAAUrX,EAAI,GACdsX,EAAUtX,EAAI,GAGpB,GAFAiX,IACAvT,QAAQ6T,MAAR,0BAAiCN,EAAjC,gBAA8CnV,IAC1CuI,EAASgN,EAASrM,IAASsM,EAAUJ,EAGrC,OAFAxT,QAAQ6T,MAAR,UAAiBzV,EAAjB,iCAAkDmV,EAAlD,kBACAlR,EAAQqR,EAAWhN,YAGvB+M,EAAOK,gBAGP9T,QAAQ6T,MAAR,UAAiBzV,EAAjB,qCAAsDmV,EAAtD,aACAlR,EAAQ,SAGhBuP,EAAQjE,iBAAiB,QAAS4E,O,qLAUtBjL,EAAMlJ,EAAU2V,G,2FACfrW,KAAKsU,G,cAAhBA,E,OACA1V,EAAM0W,GAAQ1L,EAAMlJ,GACpBiI,EAAOpB,EAAQqC,G,kBAEd,IAAIlF,SAAQ,SAACC,EAASkQ,GACzB,IACMX,EADcI,EAAGS,YAAY,WAAY,aAAaC,YAAY,YAC5CC,IAAZ,cAAkBvU,WAAUkJ,OAAMjB,QAAS0N,GAAUzX,GACrEsV,EAAQjE,iBAAiB,WAAW,WAChC3N,QAAQ6T,MAAR,gBAAuBzV,EAAvB,YAAmCkJ,EAAnC,6BAA4DyM,EAAOhM,SAASxJ,OAA5E,cACA8D,OAEJuP,EAAQjE,iBAAiB,QAAS4E,O,yQAMrB7U,KAAKsU,G,cAAhBA,E,yBAEC,IAAI5P,SAAQ,SAACC,EAASkQ,GACzB,IAAMyB,EAAMhC,EAAGS,YAAY,WAAY,aAAaC,YAAY,YAAYuB,QAC5ED,EAAIE,UAAY7R,EAChB2R,EAAIG,QAAU5B,M,6GAK1B,SAASS,GAAS1L,EAAMlJ,GACpB,IAAMgW,EAAO9M,EAAKlH,MAAM,KAAKvC,KAAI,SAAAoG,GAAC,QAAMA,GAAG4D,QAAQ,MAAI3J,KAAK,KAC5D,MAAM,GAAN,OAAUE,EAAV,YAAsBgW,GCxJ1B,IAAMhY,GAAWiY,EAAQ,IAAWjY,SAE9BkY,GAAa,iCACbC,GAAU,4BAEHC,GAAb,WAEI,aAAyB,IAAZlN,EAAW,uDAAN,KAAM,oBAEpB5J,KAAKqK,SAAW,IAAI0M,IACpB/W,KAAK4J,KAAOA,EACZ5J,KAAKgX,SAAW,IAAI/C,GAEpBjU,KAAKiX,SAAW,GAEhBjX,KAAKkX,WAAaxS,QAAQC,UAVlC,oDAaaiF,GAGD5J,KAAK4J,OAASX,EAASjJ,KAAK4J,KAAMA,IAClC5J,KAAKqK,SAASkM,QAElBvW,KAAK4J,KAAOA,IAnBpB,+EA0B2B1G,GA1B3B,qGA2BelD,KAAKmX,KAAL,sBAAU,oDAAA7S,EAAA,yDACLsF,EAAS,EAATA,KAEH,EAAKA,KAHG,sBAIHwN,MAAM,6BAJH,OAeb,IANMlG,EAAM,GACZhO,EAAUJ,SAAQ,SAAAH,GAAC,OAAIuO,EAAImG,GAAY1U,IAAMA,KAE7CL,QAAQ6T,MAAR,+BAAsCjT,EAAUrC,OAAhD,uBAAqEZ,OAAOqX,KAAKpG,GAAKrQ,OAAtF,aAGA,MAA8BZ,OAAOC,QAAQgR,GAA7C,eAAoD,EAAD,oBAAvCtS,EAAuC,KAAlC8B,EAAkC,KAC1CkW,GAAWrW,KAAKG,EAASd,cAAcsR,EAAItS,GAKpD,IAHA0D,QAAQ6T,MAAR,+BAAsClW,OAAOqX,KAAKpG,GAAKrQ,OAAvD,2BAGA,MAAkBZ,OAAOqX,KAAKpG,GAA9B,eAAWtS,EAAyB,KAC5B,EAAKyL,SAASkN,IAAI3Y,WAAasS,EAAItS,GAtB9B,OAwBb0D,QAAQ6T,MAAR,+BAAsClW,OAAOqX,KAAKpG,GAAKrQ,OAAvD,oBAxBa,UA2BP6D,QAAQ0Q,IAAInV,OAAOqX,KAAKpG,GAAK/Q,KAAI,SAAAwC,GACnC,OAAO,EAAKqU,SAASQ,eAAe5N,EAAMjH,GACrC8U,MAAK,SAAAC,GACEA,UAAYxG,EAAIvO,UA9BnB,WAiCbL,QAAQ6T,MAAR,+BAAsClW,OAAOqX,KAAKpG,GAAKrQ,OAAvD,qBAEgC,IAA5BZ,OAAOqX,KAAKpG,GAAKrQ,OAnCR,0CAmC6B,GAnC7B,yBAqCU,EAAK8W,SAAS1X,OAAO2X,OAAO1G,IArCtC,eAqCP7G,EArCO,OAuCb/H,QAAQC,IAAR,uCAA4C8H,EAASxJ,OAArD,0BAIMyJ,EAAU,GAChBD,EAASvH,SAAQ,SAAAyH,GAAC,MAAe,SAAXA,EAAE3K,OAAoB0K,EAAQC,EAAEC,IAAMD,MAGtDE,EAAS,GACfJ,EAASvH,SAAQ,SAAAyH,GAAC,MAAe,QAAXA,EAAE3K,OAAmB6K,EAAOF,EAAEC,IAAMD,MAhD7C,UAkDP7F,QAAQ0Q,IAAInV,OAAO2X,OAAO1G,GAAK/Q,KAAI,SAAAO,GACrC,IAAMkB,EAAMyI,EAASxH,QAAO,SAAAuI,GAAE,OAAI3K,EAAcC,EAAU0K,GAAI,MAE9D,GAAsB,aAAlB1K,EAASd,KAAqB,CAE9B,IAF8B,EAExBiY,EAAQjW,EAAIkW,QAGZC,EAAO,GALiB,cAOZF,GAPY,IAO9B,2BAAwB,CAAC,IACfG,EADc,QACHC,QAAQ9X,KAAI,SAAAY,GAAC,OAAIA,EAAEmX,OACpCH,EAAK1V,KAAL,MAAA0V,EAAI,YAASC,EAAK7X,KAAI,SAAAqK,GAAE,OAAIC,EAAOD,SATT,8BAY9B5I,EAAIS,KAAJ,MAAAT,EAAYmW,GAEZ,cAAkBA,EAAlB,eAAwB,CAAnB,IAAMI,EAAG,KACVvW,EAAIS,KAAJ,MAAAT,EAAG,YAASuW,EAAI7P,MAAMnI,KAAI,SAAAqK,GAAE,OAAIF,EAAQE,cAGzC,GAAsB,QAAlB9J,EAASd,MAAoC,SAAlBc,EAASd,KAAiB,CAE5D,IAF4D,EAEtDmY,EAAQnW,EAAIkW,QAF0C,cAI1CC,GAJ0C,IAI5D,2BAAwB,CAAC,IAAdI,EAAa,QACpBvW,EAAIS,KAAJ,MAAAT,EAAG,YAASuW,EAAI7P,MAAMnI,KAAI,SAAAqK,GAAE,OAAIF,EAAQE,SALgB,+BAUhE,OADA,EAAKH,SAAS6G,IAAImG,GAAY3W,GAAWgE,QAAQC,QAAQ/C,IAClD,EAAKoV,SAASoB,aAAaxO,EAAMyN,GAAY3W,GAAW,CAAE2J,SAAUzI,EAAKyW,OAAQC,KAAKC,YAjFpF,iCAoFNlO,EAASxJ,QApFH,8CA3BzB,mIAwHWqC,GAAY,IAAD,OACd,GAAIlD,KAAK4J,KAAKlH,MAAM,KAAKvC,KAAI,SAAAoG,GAAC,OAAKA,KAAGqC,KAAKvH,OAAQ,MAAM+V,MAAM,gBAE/D,IAAMoB,EAAOtV,EAAU/C,IAAIsY,IACrBC,EAAK,8BAA0BF,EAAKhY,KAAK,IAApC,cACLmP,EAAG,UAAMjR,GAAN,iBAAuBga,EAAM3P,QAAQ,KAAK,IAA1C,iBA0IjB,SAAoBa,GAChB,IAAMrD,EAAIqD,EAAKlH,MAAM,KAAKvC,KAAI,SAAAoG,GAAC,OAAKA,KACpC,MAAM,GAAN,OAAUoS,GAAMpS,EAAE,IAAK,IAAK,KAA5B,YAAoCoS,GAAMpS,EAAE,IAAK,GAAI,IAArD,YAA4DoS,GAAMpS,EAAE,IAAK,IAAK,KAA9E,YAAsFoS,GAAMpS,EAAE,IAAK,GAAI,KA5IpCqS,CAAU5Y,KAAK4J,OAQ9E,OANK5J,KAAKiX,SAAStH,KACf3P,KAAKiX,SAAStH,GAAOkJ,MAAMlJ,EAAI3G,YAAYyO,MAAK,SAAA7I,GAAC,OAAIA,EAAEkK,GAAKlK,EAAEmK,OAASrU,QAAQmQ,OAAOjG,EAAEoK,WAASvB,MAAK,SAAA7I,GAAC,OAAIA,EAAEvE,YAE7GrK,KAAKiX,SAAStH,GAAKsJ,SAAQ,yBAAa,EAAKhC,SAAStH,OAGnD3P,KAAKiX,SAAStH,KArI7B,+BA8IczM,GAAsB,IAAD,OAAVgW,EAAU,uDAAJ,GACvB,OAAOlZ,KAAK0Y,MAAMxV,GAAWiW,OAAM,SAAA9Z,GAC/B,GAAU,MAANA,EAAW,MAAM+X,MAAM,gBAE3B,GAAI8B,EAAQ,EACR,OAAO1U,EAAQ,KAAOiT,MAAK,kBAAM,EAAKE,SAASzU,EAAWgW,EAAQ,MAGtE,MAAM9B,MAAM,uCAtJxB,2EA8JuB1W,GA9JvB,2FA+JakW,GAAWrW,KAAKG,EAASd,MA/JtC,oDAiKaI,KAAK4J,KAjKlB,oDAmKcjH,EAAI0U,GAAY3W,IAClBV,KAAKqK,SAASkN,IAAI5U,GApK9B,yCAoKyC3C,KAAKqK,SAAS6K,IAAIvS,IApK3D,uBAsK+B3C,KAAKgX,SAASoC,YAAYpZ,KAAK4J,KAAMjH,GAtKpE,YAsKc0W,EAtKd,gCAyKoBhP,EAAagP,EAAbhP,SACRrK,KAAKqK,SAAS6G,IAAIvO,EAAG+B,QAAQC,QAAQ0F,IA1KjD,kBA2KmBA,GA3KnB,yBA8KqCrK,KAAKgX,SAASQ,eAAexX,KAAK4J,KAAMjH,GA9K7E,aA8Kc2W,EA9Kd,gCAiLkBjP,EAAWrK,KAAKgX,SAASzB,iBAAiB+D,GAAgB7B,MAAK,SAAA7I,GAAC,OAAIA,EAAEvE,YAC5ErK,KAAKqK,SAAS6G,IAAIvO,EAAG0H,GAlLjC,kBAmLmBA,GAnLnB,eAsLc9D,EAAIvG,KAAK2X,SAAS,CAACjX,IAEzBV,KAAKqK,SAAS6G,IAAIvO,EAAG4D,GAErBA,EAAE4S,OAAM,kBAAM,EAAK9O,SAASkP,OAAO5W,MAEnC4D,EAAEkR,MAAK,SAAApN,GACH,EAAK2M,SAASoB,aAAa,EAAKxO,KAAMjH,EAAG,CAAE0H,WAAUgO,OAAQC,KAAKC,WA7L9E,kBAgMehS,GAhMf,mIAmMUiT,GAGF,OAFAxZ,KAAKkX,WAAalX,KAAKkX,WAAWO,MAAK,kBAAM+B,OAEtCxZ,KAAKkX,aAtMpB,mCA0MmC,IAAnBF,EAAkB,wDAE1B,GADAhX,KAAKqK,SAASkM,QACVS,EACA,OAAOhX,KAAKgX,SAAST,YA7MjC,KAkNA,SAASkC,GAAqB/X,GAC1B,IAAM+Y,EAAQ5C,GAAQtW,KAAKG,EAASd,MAAQ,KAAO,GACnD,MAAM,GAAN,OAAUyX,GAAY3W,GAAtB,YAAmC+Y,GAIvC,SAASpC,GAAa3W,GAClB,IAAMd,EAAyB,SAAlBc,EAASd,KAAkB,MAAQc,EAASd,KACnDC,EAAOI,OAAOC,QAAQQ,EAASb,MAAMM,KAAI,YAAY,IAAD,mBAATC,EAAS,KAAPC,EAAO,KACtD,MAAQ,UAAUE,KAAKF,IAAY,MAANA,EAAtB,WAAuCD,EAAvC,gBAAkDA,EAAlD,YAAuDC,EAAvD,QAEX,MAAM,GAAN,OAAUT,GAAV,OAAiBC,EAAKW,KAAK,KA+C/B,SAASmY,GAAOtY,EAAG0G,EAAKC,GACpB,OAAO3B,KAAK2B,IAAID,EAAK1B,KAAK0B,IAAI1G,EAAG2G,IClR9B,SAAS0S,GAAY5Y,EAAO6Y,GAAO,MAEM5a,mBAAS+B,GAFf,mBAE/B8Y,EAF+B,KAEfC,EAFe,KAqBtC,OAjBAC,qBACE,WAEE,IAAMC,EAAUnV,YAAW,WACzBiV,EAAkB/Y,KACjB6Y,GAKH,OAAO,WACLK,aAAaD,MAGjB,CAACjZ,EAAO6Y,IAGHC,ECtBI,SAASK,GAAT,GAAwD,IAAnCnZ,EAAkC,EAAlCA,MAAOoZ,EAA2B,EAA3BA,SAAaC,EAAc,qCA+ClE,OAAO,4CAAUrZ,MAAOA,EAAOoZ,SAAU,SAAA7a,GAAC,OAAI6a,EAAS7a,EAAEkV,OAAOzT,QAAQsZ,UA3CxE,SAAwBC,GAAQ,IACpBzb,EAAiCyb,EAAjCzb,IAAK0b,EAA4BD,EAA5BC,cAAeC,EAAaF,EAAbE,SAE5B,GAAY,QAAR3b,EAAe,CACfyb,EAAMG,iBAEN,IAAMzX,EAAIuX,EAAcG,eAClBC,EAAY5Z,EAAM6Z,YAAY,KAAM5X,EAAE,GAAK,EAEjD,GAAIwX,GACA,GAAmC,SAA/BzZ,EAAMK,OAAOuZ,EAAW,GAAe,CACvC,IAAME,EAAW9Z,EAAMqB,UAAU,EAAEuY,GAAa5Z,EAAMqB,UAAUuY,EAAY,GAC5ER,EAASU,GAEThW,YAAW,kBAAM0V,EAAcO,kBAAkB9X,EAAI,EAAGA,EAAI,KAAI,SAEjE,CACH,IACMsB,EAAI,GADMtB,EAAI2X,GACI,EAElBE,EAAW9Z,EAAMqB,UAAU,EAAEY,GAAK,OAAOZ,UAAU,EAAEkC,GAAKvD,EAAMqB,UAAUY,GAChFmX,EAASU,GAEThW,YAAW,kBAAM0V,EAAcO,kBAAkB9X,EAAIsB,EAAGtB,EAAIsB,KAAI,UAInE,GAAY,UAARzF,EAAiB,CACtByb,EAAMG,iBAEN,IAAMzX,EAAIuX,EAAcG,eAClBK,EAA2B,MAAfha,EAAMiC,EAAE,GACpB2X,EAAY5Z,EAAM6Z,YAAY,KAAM5X,EAAE,GAAK,EAC3CtB,EAAQX,EAAMqB,UAAUuY,EAAW3X,GAAGtB,MAAM,OAC5CsZ,EAAShY,EAAItB,EAAM,GAAGZ,OAAS,GAAKia,EAAY,EAAI,GAEpDF,EAAW9Z,EAAMqB,UAAU,EAAEY,GAAK,MAAQ+X,EAAY,OAAS,IAAMrZ,EAAM,GAAKX,EAAMqB,UAAUY,GACtGmX,EAASU,GAEThW,YAAW,kBAAM0V,EAAcO,kBAAkBE,EAAQA,KAAS,OAI4BZ,I,4BC6H3Fa,OA7Jf,WAAgB,IAAD,EACerc,EAAc,aAAc,2DAD3C,mBACLsc,EADK,KACEC,EADF,OAEiBvc,EAAc,cAAe,YAF9C,mBAELmG,EAFK,KAEGqW,EAFH,OAGaxc,EAAc,aAAc,IAHzC,mBAGLoL,EAHK,KAGCqR,EAHD,KAIPtQ,ECvBO,WAA2B,MAEdhM,IAAMC,WAFQ,mBAE9Bsc,EAF8B,KAEzBC,EAFyB,KAYtC,OARAxc,IAAMgb,WAAU,WAAQyB,UAAUC,YAAYC,mBAAmBH,KAAW,IAE5Exc,IAAMgb,WAAU,WACZ,IAAMtP,EAAK+Q,UAAUC,YAAYE,cAAcJ,GAE/C,OAAO,kBAAMC,UAAUC,YAAYG,WAAWnR,MAC/C,IAEI6Q,EDWOO,GAEVC,EAAY/c,IAAMgd,SAElBC,EAAcjd,IAAMgd,OAAO,IAAIhF,IARxB,EAUiBhY,IAAMC,SAAS,MAVhC,mBAULia,EAVK,KAUGgD,EAVH,OAWeld,IAAMC,SAAS,IAX9B,mBAWLkd,EAXK,KAWEC,EAXF,OAY2Bpd,IAAMC,UAAS,GAZ1C,mBAYLod,EAZK,KAYQC,EAZR,OAaqBtd,IAAMC,SAAS,GAbpC,mBAaLsd,EAbK,KAaKC,EAbL,KAePC,EAAczd,IAAMgd,SACpBU,EAAkB1d,IAAMgd,OAAO,CACnCW,YAAa,CACX,cAAe,WACTV,EAAYjR,SACdiR,EAAYjR,QAAQ4R,YAAW,OApB1B,EAoNf,WAA4B,IAAD,EACO5d,IAAMC,SAAS,GADtB,mBACjB4d,EADiB,KACRC,EADQ,KAGzB,MAAO,CAAED,EAAS,kBAAMC,GAAW,SAAA/U,GAAC,OAAIA,EAAI,OA9LLgV,GAzB1B,mBAyBLC,EAzBK,KAyBUC,EAzBV,KA0Bbje,IAAMgb,WAAU,WAAO,IACF2C,EAAkBD,EAA7B1R,QAAW2R,YACnBA,EAAYO,OAASD,EACrBN,EAAYvH,IAAM,SAAAhR,GAChB,MAAa,WAATA,EAA0BY,EACjB,SAATZ,EAAwB6F,EACf,UAAT7F,EAAwB,GAAN,OAAU4G,EAAQC,OAAOE,UAAzB,YAAsCH,EAAQC,OAAOG,eAA3E,GAGFuR,EAAYvL,IAAM,SAAChN,EAAMpD,GACvB,MAAa,WAAToD,GAAqBiX,EAAUra,IAAe,GACrC,SAAToD,IAAmBkX,EAAQta,IAAe,IAGhD2b,EAAY,iBAAmB,WAC7Bxd,aAAaQ,QA5CQ,iBA4CoB,MACzCwd,OAAOC,SAASC,UAElBV,EAAY,kBAAoB,WAC9Bxd,aAAame,WAhDQ,kBAiDrBH,OAAOC,SAASC,YAEjB,CAAEJ,EAAajY,EAAQiF,EAAMoR,EAAWC,EAAStQ,IAhDvC,MAiD2BhM,IAAMC,UAAS,GAjD1C,mBAiDLse,EAjDK,KAiDWC,EAjDX,OAmDyBzB,EAAU/Q,SAAW,CAAEyS,YAAa,IAAMC,aAAc,KAAtFD,EAnDK,EAmDLA,YAAaC,EAnDR,EAmDQA,aAEfxY,EAAQuY,EAAcE,iBACtBxY,EAASuY,EAAeC,iBAExBC,GAAkBhE,GAAY5U,EAAQ,KACtC6Y,GAAgBjE,GAAY3P,EAAM,KAElCH,GAAO9K,IAAM8e,SAAQ,kBAAM9T,EAAS4T,GAAgBhb,MAAM,KAAKvC,KAAI,SAAAoG,GAAC,OAAKA,KAAIoX,GAAe,CAACJ,EAAaC,MAAgB,CAACE,GAAiBC,GAAeJ,EAAaC,IAExKK,GAAiBnE,GAAYuB,EAAO,KAEpC6C,GAAchf,IAAM8e,SAAQ,kBvB6F7B,SAAqBG,GAM1B,IAJA,IAAMnc,EAAM,CAAEQ,MAAO,IAEjBvB,EAASkd,EAAUld,OAEhBA,EAAS,GAAG,CAAC,IAAD,IAGXmd,EAAc9b,EAAW6b,IAC/B,EAAAnc,EAAIQ,OAAMC,KAAV,oBAAkB2b,EAAY5b,QAI9B,IAAM6b,EAAc1c,EAHpBwc,EAAYA,EAAU5b,UAAU6b,EAAYlc,OAAOc,QAOnD,IAHA,EAAAhB,EAAIQ,OAAMC,KAAV,oBAAkB4b,EAAYpc,gBAC9Bkc,EAAYA,EAAU5b,UAAU8b,EAAYnc,OAAOc,QAErC/B,SAAWA,EAAQ,CAC/ByB,QAAQC,IAAI,+BAAiCwb,GAC7C,MAGFld,EAASkd,EAAUld,OAGrB,OAAOe,EuBvHiCsc,CAAWL,MAAiB,CAACA,KAErE/e,IAAMgb,WAAU,kBAAMiC,EAAYjR,QAAQqT,QAAQvU,MAAO,CAACA,KAG1D,IAGMvG,GAAU,CAAEyB,OAHG4Y,GAAgBhb,MAAM,KAAKvC,KAAI,SAAAoG,GAAC,OAAKA,KAGnBwD,KAAM4T,GAAe/T,QAAM7E,MAAO0Y,iBAAkBzY,QAAOC,UAC5F7C,GAAQgB,EAAY0a,GAAY1b,MAAOiB,IAW7C,GATAvE,IAAMgb,WAAU,WAEd,IAAMsE,EAAW,SAAA/e,GAAC,MAAc,MAAVA,EAAET,KAAeS,EAAEgf,SAAWhf,EAAEif,QAAUhB,GAAaD,IAI7E,OAFAkB,SAAStO,iBAAiB,QAASmO,GAE5B,kBAAMG,SAASC,oBAAoB,QAASJ,MAClD,CAACf,IAEAjb,GAAMwG,MAAK,SAAAgG,GAAC,MAAwB,YAApBA,EAAElO,SAASd,QAAqB,CAAC,IAAD,IACNkL,GAAW,CAAEC,OAAQ,KAAzDA,OAAUE,GADgC,GAChCA,UAAWC,GADqB,GACrBA,SAC7B7H,GAAQyH,QAAU,CAAEG,aAAWC,aAqBjC,SAASuT,GAAMC,EAAIC,GAEjB,IAAMnT,EAAekS,GAAgBhb,MAAM,KAAKvC,KAAI,SAAAoG,GAAC,OAAKA,KACpDqY,EAAKhV,GAAKlH,MAAM,KAAKvC,KAAI,SAAAoG,GAAC,OAAKA,KAC/BsY,GAAaD,EAAG,GAAKA,EAAG,IAAM,EAC9BE,GAAaF,EAAG,GAAKA,EAAG,IAAM,EAC9BG,EAAY,CAAEC,GAAQxT,EAAY,GAAKkT,EAAKG,GAAYG,GAAQxT,EAAY,GAAKmT,EAAKG,IAC5F3D,EAAU4D,EAAUve,KAAK,MAG3B,SAASye,GAAgBrf,GACvB,IAAKuc,EAAa,CAChBC,GAAe,GACf,IAAM8C,EAAK,kBAAM9C,GAAe,IACnB,QAATxc,EA0CV,SAAsB6S,GAAwB,IAAhB2L,EAAe,uDAAN,KACrC3L,EAAO0M,QAAO,SAAAC,GACZC,GAAaD,EAAM,WACfhB,GAAUA,OA5CVkB,CAAYzD,EAAU/Q,QAASoU,G,yCAE/BK,CAAYlc,GAASya,GAAa/B,EAAYjR,QAASoU,IAK7D,OAxCIrD,EAAU/Q,UAAYyR,EAAYzR,UAChCmS,OAAOrK,QAAUiJ,EAAU/Q,QAAQgI,4BAA8B7T,aAAaC,QA5F3D,kBA6FrBqd,EAAYzR,QAAU,IAAI0U,GAAa3D,EAAU/Q,SAEjDyR,EAAYzR,QAAU,IAAI0H,GAAaqJ,EAAU/Q,UAKrD2U,cAAqB,WAEnB,IAAI3U,EAAU,CAAE4U,eAAe,GAI/B,O,mDAFA1C,CAAO5a,GAAO2Z,EAAYjR,QAASyR,EAAYzR,QAASzH,GAAS2Y,EAAWE,EAAUI,EAAaxR,GAE5F,WAAQA,EAAQ4U,eAAgB,KACtC,CAAChC,GAAiBC,GAAevb,GAAOiB,GAASyZ,IAyBlD,yBAAK6C,UAAU,OACb,yBAAKA,UAAU,WACb,yBAAKA,UAAU,YACb,4BAAQC,QAAS,kBAAMnB,IAAM,EAAE,KAA/B,UACA,4BAAQmB,QAAS,kBAAMnB,GAAK,EAAE,KAA9B,UACA,4BAAQmB,QAAS,kBAAMnB,GAAK,EAAE,KAA9B,UACA,4BAAQmB,QAAS,kBAAMnB,GAAK,GAAG,KAA/B,UACA,4BAAQmB,QAAS,kBAAMxE,GAAS4D,GAAQjV,EAAO,MAA/C,UACA,4BAAQ6V,QAAS,kBAAMxE,GAAS4D,GAAQjV,EAAO,MAA/C,UACEe,GAAW,4BAAQ8U,QAAS,kBAAMzE,EAAU,GAAD,OAAIrQ,EAAQC,OAAOE,UAAnB,YAAgCH,EAAQC,OAAOG,aAA/E,gBACb,4BAAQ0U,QAAS,kBAAMX,GAAe,QAAQY,SAAU1D,GAAxD,cACA,4BAAQyD,QAAS,kBAAMX,GAAe,QAAQY,SAAU1D,GAAxD,eAEF,yCAAc,2BAAOrb,MAAOgE,EAAQoV,SAAU,SAAA7a,GAAC,OAAI8b,EAAU9b,EAAEkV,OAAOzT,WACtE,uCAAY,2BAAOlB,KAAK,SAASkB,MAAOiJ,EAAMmQ,SAAU,SAAA7a,GAAC,OAAI+b,GAAS/b,EAAEkV,OAAOzT,WAC/E,kBAACmZ,GAAD,CAAUnZ,MAAOma,EAAOf,SAAUgB,EAAUD,MAAO,CAAC6E,KAAK,GAAIC,YAAY,IACzE,yBAAKJ,UAAU,eACX3G,GAAU,2BAAIA,GACdqD,EAAW,GAAK,8BAAUvb,MAAOub,IACjCJ,GAAS,uBAAGhB,MAAO,CAAC+E,MAAM,QAAS/D,IAErCoB,GAAkB,kBAAC,KAAD,CAASha,QAASmZ,EAAgB1R,QAASmQ,MAAO,CAAEgF,UAAW,QAErF,4BAAQ/H,IAAK2D,M,8CAiBnB,WAA4BxY,EAAS4X,EAAOiF,GAA5C,yCAAA5b,EAAA,sDAAsD8Z,EAAtD,+BAA+D,KACvDhc,EAAQgB,EAAY6X,EAAM7Y,MAAOiB,GAEjClD,EAAMiC,EAAMjC,KAAI,SAAAmD,GACpB,MAAO,CACLA,OACA6c,QAASD,EAAS9G,YAAY9V,EAAK5C,cAIvCsQ,GAAgBkB,qBAAqBqE,QAE/B6J,EAAY,IAAI7M,GAAUlQ,EAAQ2B,MAAO3B,EAAQ4B,QAZzD,cAcqB9E,GAdrB,gEAcakgB,EAdb,kBAe2BA,EAAKF,QAfhC,QAeU9V,EAfV,OAgBI+V,EAAUE,WAAWjd,EAASgd,EAAK/c,KAAM+G,GAhB7C,+IAoBEgV,GADae,EAAUjB,SACJ,WAEff,GAAUA,IAtBhB,iE,sBAyBA,SAASiB,GAAcD,EAAMmB,GAC3B,IAAM5Q,EAAM6Q,IAAIC,gBAAgBrB,GAC1B9a,EAAIia,SAASmC,cAAc,KACjCpc,EAAEqc,SAAWJ,EACbjc,EAAEsc,KAAOjR,EACT4O,SAASsC,KAAKC,YAAYxc,GAC1BA,EAAEyc,QACFxC,SAASsC,KAAKG,YAAY1c,GAC1Bkc,IAAIS,gBAAgBtR,GAMtB,SAASqP,GAASzU,GAChB,OAAOA,EAAEJ,QAAQ,GAAGpB,QAAQ,WAAY,I,8CAmB1C,WAAuB3G,EAAO8d,EAAUgB,EAAU7d,EAAS2Y,EAAWE,EAAUI,EAAaxR,GAA7F,6BAAAxG,EAAA,6DACE0X,EAAU,eACVE,EAAS,IAFX,kBAKwBgE,EAASiB,gBAAgB/e,EAAMjC,KAAI,SAAAyO,GAAC,OAAIA,EAAElO,aALlE,UAKUmV,EALV,OAOS/K,EAAQ4U,cAPjB,sDAUQ7J,EAAQ,GAVhB,sDAaMmG,EADY,IAAVnG,EACQ,eAEA,aAAD,OAAcA,EAAd,iBAEL1V,EAAMiC,EAAMjC,KAAI,SAAAmD,GACpB,MAAO,CACLA,OACA6c,QAASe,aAAoB1B,GAAe9a,QAAQC,UAAYub,EAAS9G,YAAY9V,EAAK5C,cAI9FsQ,GAAgBkB,qBAAqBqE,SAEjC2K,EA1BR,oBA2BWpW,EAAQ4U,cA3BnB,mDA6BMwB,EAAS3K,MAAMlT,GAEXwS,EAAQ,EA/BlB,cAkCyB1V,GAlCzB,kEAkCiBkgB,EAlCjB,QAmCce,EAnCd,YAmC4BvL,EAnC5B,YAmCqC1V,EAAIU,QAEjCyB,QAAQ6T,MAAR,UAAiBiL,EAAjB,iCAAgDf,EAAK/c,KAAK5C,WArClE,UAsC+B2f,EAAKF,QAtCpC,WAsCc9V,EAtCd,OAwCaS,EAAQ4U,cAxCrB,mDA0CQpd,QAAQ6T,MAAR,UAAiBiL,EAAjB,sBAAqCf,EAAK/c,KAAK5C,WAE/CwgB,EAASZ,WAAWjd,EAASgd,EAAK/c,KAAM+G,GA5ChD,iJAkDM/H,QAAQ6T,MAAR,aAlDN,QAqDI6F,EAAU,MArDd,kDAuDIE,EAAS,kBACTF,EAAU,MACV1Z,QAAQC,IAAR,MAzDJ,yE,sBE7OoB8e,QACW,cAA7BpE,OAAOC,SAASoE,UAEe,UAA7BrE,OAAOC,SAASoE,UAEhBrE,OAAOC,SAASoE,SAAS7f,MACvB,2DCZN8f,IAASvE,OACP,kBAAC,IAAMwE,WAAP,KACE,kBAAC,GAAD,OAEFjD,SAASkD,eAAe,SDyHpB,kBAAmBlG,WACrBA,UAAUmG,cAAcC,MACrBlK,MAAK,SAAAmK,GACJA,EAAaC,gBAEd1I,OAAM,SAAA8C,GACL3Z,QAAQ2Z,MAAMA,EAAM6F,c","file":"static/js/main.8585c58f.chunk.js","sourcesContent":["\r\nexport const API_ROOT = \"https://overpass-api.de/api/interpreter\";","import React from 'react';\r\n\r\n/**\r\n * @template T\r\n * @param {string} key \r\n * @param {T} initalState \r\n * @returns {[ T, (newState: T) => void ]}\r\n */\r\nexport default function useSavedState (key, initalState) {\r\n    const [ state, setState ] = React.useState(() => {\r\n        const saved = localStorage.getItem(key);\r\n    \r\n        if (saved) {\r\n            try {\r\n                initalState = JSON.parse(saved);\r\n            } catch (e) {}\r\n        }\r\n\r\n        return initalState;\r\n    });\r\n\r\n    return [\r\n        state,\r\n        newState => {\r\n            localStorage.setItem(key, JSON.stringify(newState));\r\n            setState(newState);\r\n        }\r\n    ]\r\n}","/**\r\n * @typedef StyleRule\r\n * @property {\"rule\"} type\r\n * @property {StyleSelector} [selector]\r\n * @property {StyleSelector[]} [selectors]\r\n * @property {{ [key: string]: string }} declarations\r\n */\r\n\r\n/**\r\n * @typedef MediaQuery\r\n * @property {\"query\"} type\r\n * @property {Predicate} predicate\r\n * @property {StyleRule[]} rules\r\n */\r\n\r\n/**\r\n * @typedef Predicate\r\n * @property {string|number|Predicate} left\r\n * @property {string} operator\r\n * @property {string|number|Predicate} right\r\n */\r\n\r\nexport class StyleSelector {\r\n    /**\r\n     * @param {string} type\r\n     * @param {{ [key: string]: string }} tags\r\n     * @param {{ name: string, params: (string|Predicate)[] }[]} pseudoClasses\r\n     * @param {string} [pseudoElement]\r\n     */\r\n    constructor (type, tags, pseudoClasses=[], pseudoElement=null) {\r\n      this.type = type;\r\n      this.tags = tags;\r\n      this.pseudoClasses = pseudoClasses;\r\n      this.pseudoElement = pseudoElement;\r\n    }\r\n\r\n    toString () {\r\n      return `${this.type}${Object.entries(this.tags).map(([k,v]) => {\r\n        const op = /^[<=>]/.test(v) ? \"\" : \"=\";\r\n        return `[${k}${op}${v}]`;\r\n      }).join(\"\")}`;\r\n    }\r\n}\r\n\r\nStyleSelector.parse = /**\r\n * @param {string} text\r\n */\r\nfunction (text) {\r\n    const re = /^\\s*([a-z]+)/;\r\n    const m = re.exec(text);\r\n\r\n    if (!m) return null;\r\n\r\n    let type = m[1];\r\n\r\n    if (type === \"rel\") {\r\n      type = \"relation\";\r\n    }\r\n\r\n    /** @type {{ [key: string]: string }} */\r\n    const tags = {};\r\n\r\n    let tagText = text.substring(m[0].length).trim();\r\n\r\n    const re2 = /^\\[([a-z0-9_-]+)(?:(=|<=|>=|<|>)([^[\\]]+))?\\]/i;\r\n\r\n    while (true) {\r\n      const m2 = re2.exec(tagText);\r\n\r\n      if (!m2) break;\r\n\r\n      const op = m2[2] === \"=\" ? \"\" : m2[2];\r\n\r\n      tags[m2[1]] = m2[3] ? op + m2[3] : \"*\";\r\n\r\n      tagText = tagText.substring(m2[0].length);\r\n    }\r\n\r\n    /** @type {{ name: string, params: (string|Predicate)[] }[]} */\r\n    const pseudoClasses = [];\r\n\r\n    const re3 = /^:([a-z-]+)(?:\\(([^)]+)\\))?/;\r\n\r\n    while (true) {\r\n      const m3 = re3.exec(tagText);\r\n\r\n      if (!m3) break;\r\n\r\n      const re = /^\\s*([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?/;\r\n      const params = m3[2] ? m3[2].split(\",\").map(s => re.test(s) ? makePredicate(re.exec(s)) : s) : [];\r\n      pseudoClasses.push({ name: m3[1], params });\r\n\r\n      tagText = tagText.substring(m3[0].length);\r\n    }\r\n\r\n    let pseudoElement = null;\r\n\r\n    const re4 = /^::([a-z-]+)?/;\r\n\r\n    if (re4.test(tagText)) {\r\n      const m4 = re4.exec(tagText);\r\n\r\n      pseudoElement = m4[1];\r\n\r\n      tagText = tagText.substring(m4[0].length);\r\n    }\r\n\r\n    if (tagText.length) {\r\n      console.log(`Invalid selector: ${text} unexpected part: '${tagText}'`);\r\n      return null;\r\n    }\r\n\r\n    return new StyleSelector(type, tags, pseudoClasses, pseudoElement);\r\n};\r\n\r\n/**\r\n *\r\n * @param {string} text\r\n */\r\nStyleSelector.parseMultiple = function (text) {\r\n    return text.split(\",\").map(StyleSelector.parse).filter(x => x);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{ rules: StyleRule[] }} style\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @returns {StyleRule}\r\n */\r\nexport function matchRule (style, element) {\r\n    for (const rule of style.rules) {\r\n      for (const selector of rule.selectors) {\r\n        if (matchSelector(selector, element))  return rule;\r\n      }\r\n    }\r\n}\r\n\r\n/**\r\n * @param {StyleSelector} selector\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n */\r\nexport function matchSelector (selector, element, inequalities=true) {\r\n  if (element.type !== selector.type && !(selector.type === \"area\" && element.type === \"way\")) return false;\r\n\r\n  const entries = Object.entries(selector.tags);\r\n  if (entries.length && typeof element.tags === \"undefined\") return false;\r\n\r\n  for (const [key, value] of entries) {\r\n    if (typeof element.tags[key] === \"undefined\") return false;\r\n\r\n    const m = /^[<=>]+/.exec(value);\r\n    if (m) {\r\n      // Only test if inequalities are enabled\r\n      if (inequalities) {\r\n        const op = m[0];\r\n        const cmp = COMPARE[op];\r\n        // Skip if invalid operator\r\n        if (!cmp) continue;\r\n        const v = value.substr(m[0].length);\r\n        // String compare or numeric compare\r\n        const res = isNaN(+v) ? cmp(element.tags[key].localeCompare(v), 0) : cmp(+element.tags[key], +v);\r\n\r\n        if (!res) return false;\r\n      }\r\n      // If inequalities are disabled then this tag gets a pass\r\n    }\r\n    else if (value !== \"*\" && element.tags[key] !== value) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * @param {string} styleText\r\n */\r\nexport function parseStyle (styleText) {\r\n  /** @type {{ rules: (StyleRule|MediaQuery)[] }} */\r\n  const out = { rules: [] };\r\n\r\n  let length = styleText.length;\r\n\r\n  while (length > 0) {\r\n\r\n    // Try parsing rule list\r\n    const rulesResult = parseRules(styleText);\r\n    out.rules.push(...rulesResult.rules);\r\n    styleText = styleText.substring(rulesResult.index).trim();\r\n\r\n    // Try parsing media query\r\n    const mediaResult = parseMedia(styleText);\r\n    out.rules.push(...mediaResult.mediaQueries);\r\n    styleText = styleText.substring(mediaResult.index).trim();\r\n\r\n    if (styleText.length === length) {\r\n      console.log(\"Got stuck parsing style at: \" + styleText);\r\n      break;\r\n    }\r\n\r\n    length = styleText.length;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * @param {string} mediaText\r\n */\r\nfunction parseMedia (mediaText) {\r\n  const re = /^\\s*@match\\s*\\(([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?\\)\\s*{/;\r\n  /** @type {{ mediaQueries: MediaQuery[], index: number }} */\r\n  const out = { mediaQueries: [], index: 0 };\r\n  let match;\r\n\r\n  const re2 = /^\\s*}/;\r\n  let match2;\r\n\r\n  while (match = re.exec(mediaText)) {\r\n    const predicate = makePredicate(match);\r\n\r\n    out.index += match[0].length;\r\n\r\n    mediaText = mediaText.substring(match[0].length);\r\n\r\n    const { rules, index } = parseRules(mediaText);\r\n\r\n    out.index += index;\r\n\r\n    mediaText = mediaText.substring(index);\r\n\r\n    match2 = re2.exec(mediaText);\r\n\r\n    if (match2) {\r\n      out.mediaQueries.push({\r\n        type: \"query\",\r\n        predicate,\r\n        rules,\r\n      });\r\n\r\n      out.index += match2[0].length;\r\n\r\n    } else {\r\n      console.log(\"Unterminated media query\");\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nfunction parseRules (ruleText) {\r\n  const re = /^\\s*([^{}]+)\\s*{([^{}]*)}/;\r\n  let match;\r\n  /** @type {{ rules: StyleRule[], index: number }} */\r\n  const out = { rules: [], index: 0 };\r\n\r\n  while(match = re.exec(ruleText)) {\r\n    /** @type {{ [key: string]: string }} */\r\n    const declarations = {};\r\n\r\n    match[2].split(\";\").map(s => s.trim()).filter(s => s).forEach(s => {\r\n      // s.split(\":\", 2) is not the same as PHP\r\n      const i = s.indexOf(\":\");\r\n      const property = s.substring(0,i).trim();\r\n      const value = s.substring(i+1).trim();\r\n      declarations[property] = value;\r\n    });\r\n\r\n    const selectors = StyleSelector.parseMultiple(match[1]);\r\n\r\n    if (selectors.length) {\r\n      out.rules.push({\r\n        type: \"rule\",\r\n        selectors,\r\n        declarations,\r\n      });\r\n    }\r\n\r\n    out.index += match[0].length;\r\n\r\n    ruleText = ruleText.substring(match[0].length);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n *\r\n * @param {(StyleRule|MediaQuery)[]} rules\r\n * @param {object} context\r\n * @returns {StyleRule[]}\r\n */\r\nexport function expandRules (rules, context) {\r\n  /** @type {StyleRule[]} */\r\n  const out = [];\r\n  for (const rule of rules) {\r\n    if (rule.type === \"rule\") {\r\n      const { declarations } = rule;\r\n      for (const selector of rule.selectors) {\r\n        out.push({ type: \"rule\", selector, declarations });\r\n      }\r\n    } else {\r\n      if (testPredicate(rule.predicate, context)) {\r\n        out.push(...expandRules(rule.rules, context));\r\n      }\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction makePredicate(match) {\r\n  let predicate;\r\n\r\n  if (match[4]) {\r\n    // MediaQueries4 syntax:\r\n    //  @match (10 < zoom <= 14)\r\n    predicate = {\r\n      left: { left: match[1], operator: match[2], right: match[3] },\r\n      operator: \"and\",\r\n      right: { left: match[3], operator: match[4], right: match[5] },\r\n    };\r\n  }\r\n  else {\r\n    // MediaQueries4 syntax:\r\n    //  @match (zoom <= 14)\r\n    // MediaQueries3 syntax:\r\n    //  @match (max-zoom: 14) [TODO - it's parsed just not handled correctly]\r\n    predicate = {\r\n      left: match[1],\r\n      operator: match[2],\r\n      right: match[3],\r\n    };\r\n  }\r\n  return predicate;\r\n}\r\n\r\n/**\r\n *\r\n * @param {Predicate} predicate\r\n * @param {object} [context]\r\n * @returns {boolean}\r\n */\r\nexport function testPredicate (predicate, context={}) {\r\n  let left = typeof predicate.left === \"string\" || typeof predicate.left === \"number\" ?\r\n    predicate.left : testPredicate(predicate.left, context);\r\n  let right = typeof predicate.right === \"string\" || typeof predicate.right === \"number\"  ?\r\n    predicate.right : testPredicate(predicate.right, context);\r\n\r\n  if (typeof left === \"string\" && left in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[left] instanceof Function)\r\n      context[left] = context[left]();\r\n\r\n    left = context[left];\r\n  }\r\n\r\n  if (typeof right === \"string\" && right in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[right] instanceof Function)\r\n      context[right] = context[right]();\r\n\r\n    right = context[right];\r\n  }\r\n\r\n  const op = COMPARE[predicate.operator];\r\n\r\n  if (!op) return false;\r\n\r\n  return op(left, right);\r\n}\r\n\r\nconst COMPARE = {\r\n  \":\": (a,b) => a == b,\r\n  \"=\": (a,b) => a == b,\r\n  \">\": (a,b) => a > b,\r\n  \"<\": (a,b) => a < b,\r\n  \">=\": (a,b) => a >= b,\r\n  \"<=\": (a,b) => a <= b,\r\n  \"and\": (a,b) => a && b,\r\n  \"or\": (a,b) => a || b,\r\n}","/**\r\n * Promise based timeout\r\n * @param {number} duration\r\n */\r\nexport function timeout (duration) {\r\n    return new Promise(resolve => setTimeout(resolve, duration));\r\n}\r\n\r\n/**\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n * @param {number} minLon\r\n * @param {number} minLat\r\n * @param {number} maxLon\r\n * @param {number} maxLat\r\n * @param {number} width\r\n * @param {number} height\r\n */\r\nexport function flatProjection(minLon, minLat, maxLon, maxLat, width, height) {\r\n    const xScale = width / (maxLon - minLon);\r\n    const yScale = height / (maxLat - minLat);\r\n    const scale = Math.max(xScale, yScale);\r\n    return ((lon, lat) => [(lon - minLon) * scale, height - (lat - minLat) * scale]);\r\n}\r\n/**\r\n * @param {[number, number]} centre\r\n * @param {number} scale\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n */\r\nexport function mercatorProjection(centre, scale, width, height) {\r\n    const baseTileSize = 256;\r\n\r\n    const [cLon, cLat] = centre;\r\n\r\n    const tileCount = Math.pow(2, scale);\r\n    const degPerTileH = 180 / tileCount;\r\n    const degPerTileV = 180 / tileCount;\r\n\r\n    const hPixelsPerDeg = baseTileSize / degPerTileH;\r\n    const vPixelsPerDeg = baseTileSize / degPerTileV;\r\n\r\n    const QUARTER_PI = Math.PI / 4;\r\n\r\n    const cX = width / 2;\r\n    const cY = height / 2;\r\n\r\n    const cLatPrime = Math.log(Math.tan(QUARTER_PI + (cLat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n    return (lon, lat) => {\r\n        const E = lon;\r\n        const N = Math.log(Math.tan(QUARTER_PI + (lat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n        const dLon = E - cLon;\r\n        const dLat = N - cLatPrime;\r\n\r\n        const dX = dLon * hPixelsPerDeg;\r\n        const dY = dLat * vPixelsPerDeg;\r\n\r\n        return [cX + dX, cY - dY];\r\n    };\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n */\r\n\r\nexport function getAveragePoint(points) {\r\n    const sum = points.reduce((sum, p) => [sum[0] + p[0], sum[1] + p[1]], [0, 0]);\r\n    /** @type {[number, number]} */\r\n    const avg = (sum.map(x => x / points.length));\r\n    return avg;\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n * @returns {[number, number]}\r\n */\r\n\r\nexport function getCentrePoint(points) {\r\n    const boundingBox = getBoundingBox(points);\r\n\r\n    return [\r\n        boundingBox[0] + boundingBox[2] / 2,\r\n        boundingBox[1] + boundingBox[3] / 2,\r\n    ];\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n * @returns {[number, number]}\r\n */\r\n\r\nexport function getMidPoint(points) {\r\n    return points[Math.floor((points.length - 1) / 2)];\r\n}\r\n/**\r\n * @param {[number, number][]} points\r\n * @returns {[number, number, number, number]} (x, y, width, height)\r\n */\r\n\r\nexport function getBoundingBox(points) {\r\n    const minMax = points.reduce((minMax, point) => {\r\n        return [\r\n            Math.min(minMax[0], point[0]),\r\n            Math.min(minMax[1], point[1]),\r\n            Math.max(minMax[2], point[0]),\r\n            Math.max(minMax[3], point[1]),\r\n        ];\r\n    }, [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]);\r\n\r\n    return [\r\n        minMax[0],\r\n        minMax[1],\r\n        minMax[2] - minMax[0],\r\n        minMax[3] - minMax[1],\r\n    ];\r\n}\r\n","\r\n/**\r\n * \r\n * @param {number} x \r\n * @param {number} y \r\n * @param {number} width \r\n * @param {number} height \r\n * @returns {[number, number][]}\r\n */\r\nexport function rectToPoints(x, y, width, height) {\r\n    /** @type {[number, number][]} */\r\n    return [\r\n        [x, y],\r\n        [x, y + height],\r\n        [x + width, y + height],\r\n        [x + width, y],\r\n    ];\r\n}\r\n\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points \r\n */\r\nexport function getCrossProductArea (points) {\r\n    let sum = 0;\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n        sum += points[i][0] * points[i+1][1] - points[i+1][0] * points[i][1];\r\n    }\r\n    return sum / 2;\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getArea (points) {\r\n    return Math.abs(getCrossProductArea(points));\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isAntiClockwise (points) {\r\n    return getCrossProductArea(points) > 0;\r\n}\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points\r\n */\r\nexport function isConvex (points) {\r\n    const l = points.length;\r\n    if (l < 3) return;\r\n\r\n    let sign = 0;\r\n    for (let i = 1; i < l; i++) {\r\n        const a = points[i-1];\r\n        const b = points[i];\r\n        const c = points[(i+1) % l];\r\n        \r\n        const next = Math.sign((b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]));\r\n\r\n        if (sign === 0) sign = next;\r\n        else if (next !== 0 && sign !== next) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isSelfClosing (points) {\r\n    const f = points[0];\r\n    const l = points[points.length - 1]; \r\n    return f[0] === l[0] && f[1] === l[1];\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getLength (points) {\r\n    let sum = 0;\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n        const dx = points[i][0] - points[i-1][0];\r\n        const dy = points[i][1] - points[i-1][1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    return sum;\r\n}","import { getArea, isConvex, isAntiClockwise, getLength } from \"./geometry\";\r\nimport { testPredicate } from \"./Style\";\r\nimport { getBoundingBox } from \"./util\";\r\n\r\n/** @typedef {import(\"./Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"./Overpass\").OverpassElement} OverpassElement */\r\n\r\n\r\n/**\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @param {import(\"./Overpass\").OverpassElement[]} nodes\r\n */\r\nexport function matchPseudoClasses(rule, points, element=null, nodes = null) {\r\n    const { selector } = rule;\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"convex\")) {\r\n        if (!isConvex(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"concave\")) {\r\n        if (isConvex(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"clockwise\")) {\r\n        if (isAntiClockwise(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"anti-clockwise\")) {\r\n        if (!isAntiClockwise(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"self-closing\")) {\r\n        if (nodes[0] !== nodes[points.length - 1])\r\n            return false;\r\n    }\r\n\r\n    const hasPseudoClasses = selector.pseudoClasses.filter(c => c.name === \"has\");\r\n\r\n    for (const pc of hasPseudoClasses) {\r\n        if (typeof pc.params[0] === \"string\")\r\n            return false;\r\n\r\n        const predicate = pc.params[0];\r\n\r\n        // Functions for lazy evaluation\r\n        const elementContext = {\r\n            area: () => getArea(points),\r\n            length: () => getLength(points),\r\n            width: () => getBoundingBox(points)[2],\r\n            height: () => getBoundingBox(points)[3],\r\n        };\r\n\r\n        const match = testPredicate(predicate, elementContext);\r\n\r\n        if (!match) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * @todo Add support for more than one paramater\r\n * @param {import(\"./Overpass\").StyleSelector} selector\r\n * @param {string} name\r\n * @param  {...string} params\r\n */\r\nfunction includesPseudoClass (selector, name, ...params) {\r\n    return selector.pseudoClasses.some(c => c.name === name && c.params[0] === params[0]);\r\n}","/**\r\n * @param {import(\"./Style\").StyleRule} rule\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @param {import(\"./MapRenderer\").MapContext} context\r\n */\r\n\r\nexport function getContent(rule, element, context) {\r\n    let content = rule.declarations[\"content\"];\r\n\r\n    if (!content)\r\n        return \"\";\r\n\r\n    let index = 0;\r\n    /** @type {string[]} */\r\n    const out = [];\r\n\r\n    while (index < content.length) {\r\n        const c = content.substr(index);\r\n\r\n        let m = /^\\s+/.exec(c);\r\n        if (m) {\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        m = /^\"(.*?[^\\\\])\"/.exec(c);\r\n        if (m) {\r\n            out.push(m[1].replace(/\\\\\"/g, `\"`).replace(/\\\\n/g, `\\n`));\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        m = /^tag\\(([^)]+)\\)/.exec(c);\r\n        if (m) {\r\n            out.push(element.tags[m[1]] || \"\");\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        m = /^debug\\(([^)]+)\\)/.exec(c);\r\n        if (m) {\r\n            if (m[1] === \"type\") out.push(element.type);\r\n            else if (m[1] === \"tags\") out.push(Object.entries(element.tags).map(([key, value]) => `[${key}=${value}]`).join(\"\\n\"));\r\n            else if (m[1] === \"location\" && element.type === \"node\") out.push(`(${element.lon},${element.lat})`);\r\n            else if (m[1] === \"node_count\" && (element.type === \"way\" || element.type === \"area\")) out.push(element.nodes.length.toString());\r\n            // else if (m[1] === \"length\" && (element.type === \"way\" || element.type === \"area\")) out.push(getLength(element.).toString())\r\n            // else if (m[1] === \"area\" && (element.type === \"way\" || element.type === \"area\")) out.push(getArea(element.).toString())\r\n            else if (m[1] === \"scale\") out.push(context.scale.toString());\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        // Shouldn't get here\r\n        return \"?\";\r\n    }\r\n\r\n    return out.join(\"\");\r\n}\r\n","\r\n/**\r\n * Can the string be considered a valid bbox?\r\n * - Are there four parts?\r\n * - Are they all numberic?\r\n * - Are they in the correct order?\r\n * @param {string} bbox\r\n */\r\nexport function isValid (bbox) {\r\n    const parts = bbox.split(\",\");\r\n\r\n    if (parts.length !== 4) return false;\r\n\r\n    if (parts.some(p => isNaN(+p))) return false;\r\n\r\n    return +parts[0] < +parts[2] && +parts[1] < +parts[3];\r\n}\r\n\r\n/**\r\n * Determines whether or not areaB is entirely contained\r\n * within areaA\r\n * @param {string} areaA\r\n * @param {string} areaB\r\n * @returns {boolean}\r\n */\r\nexport function contains (areaA, areaB) {\r\n    const [Ax1,Ay1,Ax2,Ay2] = areaA.split(\",\");\r\n    const [Bx1,By1,Bx2,By2] = areaB.split(\",\");\r\n\r\n    return (Bx1 >= Ax1 && By1 >= Ay1 && Bx2 <= Ax2 && By2 <= Ay2);\r\n}\r\n\r\n/**\r\n * Compute simple area\r\n * @param {string} bbox\r\n */\r\nexport function getArea (bbox) {\r\n    const parts = bbox.split(\",\");\r\n    return (+parts[2] - +parts[0]) * (+parts[3] - +parts[1]);\r\n}\r\n\r\n/**\r\n *\r\n * @param {[number, number]} centre\r\n * @param {number} zoom\r\n * @param {[number, number]} size\r\n */\r\nexport function makeBBox (centre, zoom, size) {\r\n    const baseTileSize = 256;\r\n\r\n    const [ lon, lat ] = centre;\r\n    const [ width, height ] = size;\r\n\r\n    const tileCount = Math.pow(2, zoom)\r\n    const xSpan = 180 / tileCount;\r\n    const ySpan = 180 / tileCount;\r\n\r\n    const hTileCount = width / baseTileSize;\r\n    const vTileCount = height / baseTileSize;\r\n\r\n    const dLon = xSpan * hTileCount;\r\n    const dLat = ySpan * vTileCount;\r\n\r\n    return [ lon - dLon, lat - dLat, lon + dLon, lat + dLat ].map(p => p.toFixed(3)).join(\",\");\r\n}","import { mercatorProjection, getCentrePoint, getMidPoint, getAveragePoint, getBoundingBox } from \"./util\";\r\nimport { rectToPoints, isSelfClosing } from \"./geometry\";\r\nimport { matchPseudoClasses } from \"./matchPseudoClasses\";\r\nimport { getContent } from \"./getContent\";\r\nimport { makeBBox } from \"./bbox\";\r\nimport { matchSelector } from \"./Style\";\r\n\r\n/** @typedef {{ centre: [number, number], zoom: number, bbox: string, current?: { longitude: number, latitude: number }, width: number, height: number, scale: number }} MapContext */\r\n\r\nexport default class MapRenderer {\r\n\r\n    /**\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {import(\"./Overpass\").OverpassElement[]} elements\r\n     */\r\n    renderRule (context, rule, elements=[]) {\r\n        // Prepare node map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n        const nodeMap = {};\r\n        elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n        // Prepare way map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n        const wayMap = {};\r\n        elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n        const { centre, zoom, width, height } = context;\r\n\r\n        /** @type {(lon: number, lat: number) => [number, number]} */\r\n        const projection = mercatorProjection(centre, zoom, width, height);\r\n\r\n        // Set up global context options\r\n        this.globalSetup(context, rule);\r\n\r\n        const { type } = rule.selector;\r\n\r\n        // Non-Overpass Types first\r\n        switch (type) {\r\n            case \"map\": {\r\n                const points = rectToPoints(0, 0, width, height);\r\n                if (rule.selector.pseudoElement)\r\n                    this.renderPseudoElement(context, rule, points, null, null);\r\n                else\r\n                    this.renderArea(context, rule, points, null);\r\n                break;\r\n            }\r\n            case \"current\": {\r\n                if (context.current) {\r\n                    const coords = context.current;\r\n                    this.renderPoint(context, rule, projection(coords.longitude, coords.latitude));\r\n                }\r\n                break;\r\n            }\r\n            case \"gridlines\": {\r\n                this.renderGridlines(context, rule, projection);\r\n                break;\r\n            }\r\n            case \"dummy\": {\r\n                this.renderPoint(context, rule, [0, 0]);\r\n                break;\r\n            }\r\n            default:\r\n                // Then iterate all elements\r\n                for (const el of elements) {\r\n                    if (!matchSelector(rule.selector, el)) continue;\r\n\r\n                    switch (type) {\r\n                        case \"node\": {\r\n                            if (el.type !== \"node\") continue;\r\n\r\n                            const point = projection(el.lon, el.lat);\r\n\r\n                            if (rule.selector.pseudoElement) {\r\n                                this.renderPseudoElement(context, rule, [point], el, [el]);\r\n                            }\r\n                            else {\r\n                                this.renderPoint(context, rule, point, el);\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"way\":\r\n                        case \"area\": {\r\n                            if (el.type !== \"way\") continue;\r\n\r\n                            /** @type {import(\"./Overpass\").OverpassNodeElement[]} */\r\n                            const nodes = el.nodes.map(id => nodeMap[id]);\r\n                            const points = nodes.map(n => projection(n.lon, n.lat));\r\n\r\n                            if (!matchPseudoClasses(rule, points, el, nodes)) continue;\r\n\r\n                            if (rule.selector.pseudoElement) {\r\n                                this.renderPseudoElement(context, rule, points, el, nodes);\r\n                            }\r\n                            else {\r\n                                // Render actual way/area\r\n                                if (type === \"area\") {\r\n                                    this.renderArea(context, rule, points, el);\r\n                                } else {\r\n                                    this.renderLine(context, rule, points, el);\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"relation\": {\r\n                            if (el.type !== \"relation\") continue;\r\n\r\n                            // this.renderRelation(rule, el, wayMap, nodeMap, projection, context);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n        }\r\n    }\r\n\r\n    renderPoint (context, rule, point, element=null) {}\r\n\r\n    renderLine (context, rule, points, element=null) {\r\n        this.renderAreaLine(context, rule, points, getMidPoint, element);\r\n    }\r\n\r\n    renderArea (context, rule, points, element=null) {\r\n        if (points.length === 0)\r\n            return;\r\n\r\n        if (!isSelfClosing(points)) {\r\n            points = [ ...points, points[0] ];\r\n        }\r\n\r\n        this.renderAreaLine(context, rule, points, getCentrePoint, element);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {}\r\n\r\n    /**\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {[number, number][]} points\r\n     * @param {import(\"./Overpass\").OverpassElement} [element]\r\n     * @param {import(\"./Overpass\").OverpassNodeElement[]} [nodes]\r\n     */\r\n    renderPseudoElement(context, rule, points, element=null, nodes=null) {\r\n        switch (rule.selector.pseudoElement) {\r\n            case \"centre\":\r\n            case \"center\": {\r\n                // Centre of bounding box\r\n                const centrePoint = getCentrePoint(points);\r\n                this.renderPoint(context, rule, centrePoint, element);\r\n                break;\r\n            }\r\n            case \"mid-point\": {\r\n                // N/2th point (median point)\r\n                const midPoint = getMidPoint(points);\r\n                this.renderPoint(context, rule, midPoint, element);\r\n                break;\r\n            }\r\n            case \"average-point\": {\r\n                // Average of all points\r\n                const avgPoint = getAveragePoint(points);\r\n                this.renderPoint(rule, avgPoint, element, context);\r\n                break;\r\n            }\r\n            case \"start\": {\r\n                // First point\r\n                this.renderPoint(context, rule, points[0], element);\r\n                break;\r\n            }\r\n            case \"end\": {\r\n                // Last point\r\n                this.renderPoint(context, rule, points[points.length - 1], element);\r\n                break;\r\n            }\r\n            case \"centre-of-mass\": {\r\n                // TODO: calculate centre-of-mass\r\n                // const avgPoint = getCOMPoint(points);\r\n                // renderPoint(ctx, rule, avgPoint, element);\r\n                break;\r\n            }\r\n            case \"bounding-box\": {\r\n                const bounding = getBoundingBox(points);\r\n\r\n                const boundingPoints = rectToPoints(...bounding);\r\n\r\n                this.renderArea(context, rule, boundingPoints, element);\r\n                break;\r\n            }\r\n            case \"content-box\": {\r\n                const { scale } = context;\r\n                let [ x, y ] = points[0];\r\n\r\n                const content = getContent(rule, element, context);\r\n\r\n                if (!content) return;\r\n\r\n                let width = Number.NEGATIVE_INFINITY;;\r\n                let top = Number.NaN;\r\n                let bottom;\r\n                let baseline = y;\r\n                for (const line of content.split(\"\\n\")) {\r\n                    const size = this.measureText(context, rule, line);\r\n\r\n                    width = Math.max(width, size.width);\r\n\r\n                    if (isNaN(top)) top = y - size.ascending;\r\n\r\n                    bottom = baseline + size.descending;\r\n\r\n                    baseline += size.height;\r\n                }\r\n\r\n                const padding = rule.declarations[\"padding\"] ? parseFloat(rule.declarations[\"padding\"]) * scale : 0;\r\n\r\n                if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n                    x -= width / 2;\r\n                }\r\n                else if (rule.declarations[\"text-align\"] === \"right\") {\r\n                    x -= width;\r\n                }\r\n\r\n                /** @type {[number, number][]} */\r\n                const boundPoints = [\r\n                    [ x - padding,           top - padding ],     // Top Left\r\n                    [ x - padding,           bottom + padding ],    // Bottom left\r\n                    [ x + width + padding,   bottom + padding ],    // Bottom right\r\n                    [ x + width + padding,   top - padding ],     // Top Right\r\n                ];\r\n\r\n                // Close self\r\n                boundPoints.push(boundPoints[0]);\r\n\r\n                this.renderAreaLine(context, rule, boundPoints, () => points[0], element);\r\n                break;\r\n            }\r\n            case \"decimate\": {\r\n                if (rule.selector.type === \"way\") {\r\n                    const l = points.length - 1;\r\n                    const decimatedPoints = points.filter((p, i) => i % 10 === 0 || i === l);\r\n                    this.renderLine(context, rule, decimatedPoints, element);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    renderGridlines (context, rule, projection) {\r\n        const vertical = rule.selector.pseudoClasses.find(p => p.name === \"vertical\");\r\n        const horizontal = rule.selector.pseudoClasses.find(p => p.name === \"horizontal\");\r\n\r\n        const { width, height, centre, zoom } = context;\r\n\r\n        const bbox = makeBBox(centre, zoom, [width, height]);\r\n        const parts = bbox.split(\",\");\r\n\r\n        if (vertical) {\r\n            const step = parseFloat(vertical.params[0]);\r\n\r\n            const round = 1 / step;\r\n\r\n            const sigFigs = Math.ceil(Math.log10(round));\r\n\r\n            const xmin = Math.floor(+parts[0] * round) / round;\r\n            const xmax = Math.ceil(+parts[2] * round) / round;\r\n            const ymin = Math.floor(+parts[1] * round) / round;\r\n            const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n            for (let i = xmin; i <= xmax; i += step) {\r\n                const points = [ projection(i, ymin),  projection(i, (ymin + ymax) / 2), projection(i, ymax) ];\r\n                this.renderLine(context, rule, points, { type: \"way\", id: 0, nodes: [], tags: { name: i.toFixed(sigFigs) }});\r\n            }\r\n        }\r\n\r\n        if (horizontal) {\r\n            const step = parseFloat(horizontal.params[0]);\r\n\r\n            const round = 1 / step;\r\n\r\n            const sigFigs = Math.ceil(Math.log10(round));\r\n\r\n            const xmin = Math.floor(+parts[0] * round) / round;\r\n            const xmax = Math.ceil(+parts[2] * round) / round;\r\n            const ymin = Math.floor(+parts[1] * round) / round;\r\n            const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n            for (let j = ymin; j <= ymax; j += step) {\r\n                const points = [ projection(xmin, j), projection((xmin + xmax) / 2, j), projection(xmax, j) ];\r\n                this.renderLine(context, rule, points, { type: \"way\", id: 0, nodes: [], tags: { name: j.toFixed(sigFigs) }});\r\n            }\r\n        }\r\n    }\r\n\r\n    clear (context) {}\r\n\r\n    globalSetup (context, rule) { }\r\n\r\n    /**\r\n     *\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {string} text\r\n     * @return {{ width: number, ascending: number, descending: number, height: number }}\r\n     */\r\n    measureText (context, rule, text) {\r\n        return { width: 0, ascending: 0, descending: 0, height: 0 };\r\n    }\r\n}","export function parseStrokeFill(rule, scale) {\r\n    const fillStyle = rule.declarations[\"fill\"];\r\n    let strokeStyle = rule.declarations[\"stroke\"];\r\n    let lineWidth;\r\n\r\n    if (strokeStyle) {\r\n        // Numbers in e.g. rgba(128,64,0,0.2) confuse it\r\n        let mutedStyle = strokeStyle.replace(/\\([^)]*\\)/g, ss => \" \".repeat(ss.length));\r\n\r\n        // So would hex colour strings\r\n        mutedStyle = mutedStyle.replace(/#[0-9a-f]{3}/i, \"    \");\r\n        mutedStyle = mutedStyle.replace(/#[0-9a-f]{6}/i, \"       \");\r\n\r\n        /**\r\n         * @todo A better parser would probably be nice\r\n         */\r\n        const swRe = /(\\d+(?:\\.\\d+)?)\\s*(?:px)?/;\r\n        const sm = swRe.exec(mutedStyle);\r\n        if (sm) {\r\n            lineWidth = +sm[1] * scale;\r\n            strokeStyle = strokeStyle.replace(sm[0], \"\");\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"stroke-width\"]) {\r\n        lineWidth = +rule.declarations[\"stroke-width\"] * scale;\r\n    }\r\n\r\n    return {\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth,\r\n    };\r\n}","import { parseStrokeFill } from '../parseStrokeFill';\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {import(\"../Style\").StyleRule} rule\r\n */\r\nexport function setStrokeFill (ctx, rule, scale) {\r\n    const { fillStyle, strokeStyle, lineWidth } = parseStrokeFill(rule, scale);\r\n\r\n    ctx.fillStyle = fillStyle;\r\n    ctx.strokeStyle = strokeStyle;\r\n    ctx.lineWidth = lineWidth;\r\n}","/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\nimport { setStrokeFill } from \"./setStrokeFill\";\r\nimport { getContent } from \"../getContent\";\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} param2\r\n * @param {OverpassElement} [element]\r\n */\r\nexport function renderText(ctx, rule, [x, y], element = null, context) {\r\n    setStrokeFill(ctx, rule, context.scale);\r\n\r\n    let content = getContent(rule, element, context);\r\n\r\n    setFont(ctx, rule, context.scale);\r\n\r\n    for (const line of content.split(\"\\n\")) {\r\n        y += renderLine(ctx, rule, line, x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {string} content\r\n * @param {number} x\r\n * @param {number} y\r\n */\r\nfunction renderLine(ctx, rule, content, x, y) {\r\n    const size = ctx.measureText(content);\r\n\r\n    if (rule.declarations[\"text-align\"]) {\r\n        const textWidth = size.width;\r\n\r\n        if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n            x -= textWidth / 2;\r\n        }\r\n        else if (rule.declarations[\"text-align\"] === \"right\") {\r\n            x -= textWidth;\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"text-stroke\"]) {\r\n        ctx.strokeStyle = rule.declarations[\"text-stroke\"];\r\n        ctx.strokeText(content, x, y);\r\n    }\r\n\r\n    if (rule.declarations[\"text-color\"] || !rule.declarations[\"text-stroke\"]) {\r\n        ctx.fillStyle = rule.declarations[\"text-color\"];\r\n        ctx.fillText(content, x, y);\r\n    }\r\n\r\n    const height = size.actualBoundingBoxAscent + size.actualBoundingBoxDescent;\r\n    return height;\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {number} scale\r\n */\r\nexport function setFont(ctx, rule, scale) {\r\n    let fontSize = `${10 * scale}px`;\r\n    let fontWeight = \"normal\";\r\n    let fontFamily = \"sans-serif\";\r\n\r\n    if (rule.declarations[\"font\"]) {\r\n        // It would be nice for the specific properties to override the\r\n        // shorthand, but it would complicate things a bit.\r\n        ctx.font = rule.declarations[\"font\"].replace(/\\d+(?:\\.\\d+)?/, s => `${+s * scale}`);\r\n    }\r\n    else {\r\n        if (rule.declarations[\"font-size\"]) {\r\n            fontSize = rule.declarations[\"font-size\"].replace(/^\\d[\\d.]*/, m => `${+m * scale}`);\r\n        }\r\n\r\n        if (rule.declarations[\"font-weight\"]) {\r\n            fontWeight = rule.declarations[\"font-weight\"];\r\n        }\r\n\r\n        if (rule.declarations[\"font-family\"]) {\r\n            fontFamily = rule.declarations[\"font-family\"];\r\n        }\r\n\r\n        ctx.font = `${fontWeight} ${fontSize} ${fontFamily}`;\r\n    }\r\n}\r\n","/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n */\r\nexport function applyTransform(ctx, rule, scale) {\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        const r = /\\s*([a-z]+)\\(([^)]*)\\)\\s*/g;\r\n        const t = rule.declarations[\"transform\"];\r\n        let m;\r\n        while (m = r.exec(t)) {\r\n            const trans = m[1];\r\n            const params = m[2].split(\",\").map(s => ({ value: parseFloat(s) * scale, unit: s.replace(/[-\\d.\\s]/g, \"\") }));\r\n            switch (trans) {\r\n                case \"matrix\":\r\n                    // @ts-ignore\r\n                    ctx.transform(...params.map(p => p.value));\r\n                    break;\r\n                case \"rotate\": {\r\n                    let { value, unit } = params[0];\r\n\r\n                    if (unit === \"deg\") {\r\n                        value *= Math.PI / 180;\r\n                    } else if (unit === \"turn\") {\r\n                        value *= Math.PI * 2;\r\n                    }\r\n\r\n                    ctx.rotate(value);\r\n                    break;\r\n                }\r\n                case \"scale\":\r\n                    const x = params[0].value;\r\n                    const y = params[1] ? params[1].value : x;\r\n                    ctx.scale(x, y);\r\n                    break;\r\n                case \"translate\":\r\n                    // @ts-ignore\r\n                    ctx.translate(...params.map(p => p.value));\r\n                    break;\r\n                case \"skew\":\r\n                    let { value, unit } = params[0];\r\n\r\n                    if (unit === \"rad\")\r\n                        value = Math.tan(value);\r\n                    else if (unit === \"deg\")\r\n                        value = Math.tan(value * Math.PI / 180);\r\n\r\n                    let valueY = 0;\r\n\r\n                    if (params[1]) {\r\n                        let { value, unit } = params[1];\r\n\r\n                        if (unit === \"rad\")\r\n                            value = Math.tan(value);\r\n                        else if (unit === \"deg\")\r\n                            value = Math.tan(value * Math.PI / 180);\r\n\r\n                        valueY = value;\r\n                    }\r\n\r\n                    ctx.transform(1, valueY, value, 1, 0, 0);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { renderText } from \"./renderText\";\r\nimport { setStrokeFill } from \"./setStrokeFill\";\r\nimport { applyTransform } from \"./transform\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} position\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderPoint(ctx, rule, [x, y], element = null, context = {}) {\r\n    ctx.save();\r\n\r\n    const { scale } = context;\r\n\r\n    setStrokeFill(ctx, rule, scale);\r\n\r\n    if (rule.declarations[\"position\"] === \"absolute\") {\r\n        x = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n        y = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n    }\r\n    ctx.translate(x, y);\r\n\r\n    applyTransform(ctx, rule, scale);\r\n\r\n    if (rule.declarations[\"size\"]) {\r\n        ctx.beginPath();\r\n\r\n        const r = +rule.declarations[\"size\"] * scale;\r\n\r\n        ctx.ellipse(0, 0, r, r, 0, 0, Math.PI * 2);\r\n\r\n        rule.declarations[\"fill\"] && ctx.fill();\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    if (rule.declarations[\"path\"]) {\r\n        ctx.beginPath();\r\n\r\n        drawPath(ctx, rule.declarations[\"path\"], scale);\r\n\r\n        rule.declarations[\"fill\"] && ctx.fill();\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    // Syntax:\r\n    //  url(<URL>) [<width> [<height>]]\r\n    //  url(https://ijmacd.github.io/map-maker/logo192.png) 90px 120px;\r\n    const urlRe = /url\\(([^)]+)\\)(?:\\s+([^\\s]+)(?:\\s+([^\\s]+))?)?/;\r\n    if (urlRe.test(rule.declarations[\"icon\"])) {\r\n        const m = urlRe.exec(rule.declarations[\"icon\"]);\r\n        const url = m[1];\r\n        const img = new Image();\r\n        img.src = url;\r\n        const w = parseFloat(m[2]);\r\n        const h = parseFloat(m[3]);\r\n\r\n\r\n        img.addEventListener(\"load\", () => {\r\n            // The image is drawn in a callback so the render context state is lost\r\n            ctx.save();\r\n            // globalSetup(ctx, rule);\r\n\r\n            ctx.translate(x, y);\r\n\r\n            // applyTransform(ctx, rule);\r\n\r\n            if (w) {\r\n                const height = !isNaN(h) ? h : img.height * (w / img.width);\r\n                ctx.drawImage(img, 0, 0, w * scale, height * scale);\r\n            }\r\n            else {\r\n                ctx.drawImage(img, 0, 0);\r\n            }\r\n\r\n            ctx.restore();\r\n        });\r\n    }\r\n\r\n    if (rule.declarations[\"content\"]) {\r\n        renderText(ctx, rule, [0, 0], element, context);\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {string} pathSpec\r\n */\r\nfunction drawPath (ctx, pathSpec, scale) {\r\n    const segs = /([MLQCVHZ])\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?/ig;\r\n    let match;\r\n    /** @type {[number, number]} */\r\n    let first;\r\n    /** @type {[number, number]} */\r\n    let prev;\r\n\r\n    while (match = segs.exec(pathSpec)) {\r\n        const x = parseFloat(match[2]) * scale;\r\n        const y = parseFloat(match[3]) * scale;\r\n        const x2 = parseFloat(match[4]) * scale;\r\n        const y2 = parseFloat(match[5]) * scale;\r\n        const x3 = parseFloat(match[6]) * scale;\r\n        const y3 = parseFloat(match[7]) * scale;\r\n\r\n        if (!first) first = [x,y];\r\n\r\n        if (match[1] === \"M\") {\r\n            prev = [x,y];\r\n            ctx.moveTo(x, y);\r\n        }\r\n        else if (match[1] === \"L\") {\r\n            prev = [x,y];\r\n            ctx.lineTo(x, y);\r\n        }\r\n        else if (match[1] === \"Q\") {\r\n            prev = [x2,y2];\r\n            ctx.quadraticCurveTo(x, y, x2, y2);\r\n        }\r\n        else if (match[1] === \"C\") {\r\n            prev = [x3,y3];\r\n            ctx.bezierCurveTo(x, y, x2, y2, x3, y3);\r\n        }\r\n        else if (match[1] === \"Z\") {\r\n            prev = first;\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"V\") {\r\n            prev = [prev[0], x];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"H\") {\r\n            prev = [x, prev[1]];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"m\") {\r\n            prev = [prev[0] + x, prev[1] + y];\r\n            ctx.moveTo(...prev);\r\n        }\r\n        else if (match[1] === \"l\") {\r\n            prev = [prev[0] + x, prev[1] + y];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"q\") {\r\n            ctx.quadraticCurveTo(prev[0] + x, prev[1] + y, prev[0] + x2, prev[1] + y2);\r\n            prev = [prev[0] + x2, prev[1] + y2];\r\n        }\r\n        else if (match[1] === \"c\") {\r\n            prev = [x3,y3];\r\n            ctx.bezierCurveTo(prev[0] + x, prev[1] + y, prev[0] + x2, prev[1] + y2, prev[0] + x3, prev[1] + y3);\r\n            prev = [prev[0] + x3, prev[1] + y3];\r\n        }\r\n        else if (match[1] === \"z\") {\r\n            prev = first;\r\n            ctx.lineTo(...first);\r\n        }\r\n        else if (match[1] === \"v\") {\r\n            prev = [prev[0], prev[1] + x];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"h\") {\r\n            prev = [prev[0] + x, prev[1]];\r\n            ctx.lineTo(...prev);\r\n        }\r\n    }\r\n}","export default class CollisionSystem {\r\n    /** @type {CollisionSystem} */\r\n    static singleton;\r\n\r\n    constructor () {\r\n        /** @type {{ [name: string]: [number, number, number, number][] }} */\r\n        this.sets = {}\r\n    }\r\n\r\n    clear () {\r\n        this.sets = {};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} set\r\n     * @param {[number, number, number, number]} box\r\n     */\r\n    add (set, box) {\r\n        if (!this.sets[set]) this.sets[set] = [];\r\n\r\n        for (const other of this.sets[set]) {\r\n            if (intersects(box, other)) return false;\r\n        }\r\n\r\n        this.sets[set].push(box);\r\n\r\n        return true;\r\n    }\r\n\r\n    static getCollisionSystem () {\r\n        if (!this.singleton) {\r\n            this.singleton = new CollisionSystem();\r\n        }\r\n\r\n        return this.singleton;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * [x , y, width, height]\r\n * @param {[number, number, number, number]} boxA\r\n * @param {[number, number, number, number]} boxB\r\n */\r\nfunction intersects (boxA, boxB) {\r\n    const ax1 = boxA[0];\r\n    const ay1 = boxA[1];\r\n    const ax2 = boxA[0] + boxA[2];\r\n    const ay2 = boxA[1] + boxA[3];\r\n    const bx1 = boxB[0];\r\n    const by1 = boxB[1];\r\n    const bx2 = boxB[0] + boxB[2];\r\n    const by2 = boxB[1] + boxB[3];\r\n    return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;\r\n}","import { renderPoint } from \"./renderPoint\";\r\nimport { applyTransform } from \"./transform\";\r\nimport { setStrokeFill } from \"./setStrokeFill\";\r\nimport { getBoundingBox } from \"../util\";\r\nimport CollisionSystem from \"../CollisionSystem\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {(points: [number, number][]) => [number, number]} getPoint\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderAreaLine(ctx, rule, points, getPoint, element = null, context = {}) {\r\n    if (points.length === 0)\r\n        return;\r\n\r\n\r\n    if (rule.declarations[\"collision-set\"]) {\r\n        const box = getBoundingBox(points);\r\n\r\n        if (rule.declarations[\"collision-size\"]) {\r\n            const s = /(\\d+\\.?\\d*)%/.exec(rule.declarations[\"collision-size\"]);\r\n\r\n            const scaleFactor = +s[1] / 100;\r\n            const w = box[2];\r\n            const h = box[3];\r\n\r\n            box[0] += (1 - scaleFactor) * w / 2;\r\n            box[1] += (1 - scaleFactor) * h / 2;\r\n            box[2] = w * scaleFactor;\r\n            box[3] = h * scaleFactor;\r\n        }\r\n\r\n        const collisionSystem = CollisionSystem.getCollisionSystem();\r\n\r\n        if (!collisionSystem.add(rule.declarations[\"collision-set\"], box)) {\r\n            const policy = rule.declarations[\"collision-policy\"] || \"hide\";\r\n\r\n            if (policy === \"hide\") {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    ctx.save();\r\n\r\n    setStrokeFill(ctx, rule, context.scale);\r\n\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        // Extra work required if we're transforming\r\n\r\n        // First get transform origin;\r\n        const cp = getPoint(points);\r\n\r\n        // Set offset to adjust all points later\r\n        offsetX = cp[0];\r\n        offsetY = cp[1];\r\n\r\n        // Translate the canvas\r\n        ctx.translate(offsetX, offsetY);\r\n\r\n        // Apply the transformation\r\n        applyTransform(ctx, rule, context.scale);\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(points[0][0] - offsetX, points[0][1] - offsetY);\r\n    for (let i = 1; i < points.length; i++) {\r\n        ctx.lineTo(points[i][0] - offsetX, points[i][1] - offsetY);\r\n    }\r\n\r\n    rule.declarations[\"fill\"] && ctx.fill();\r\n    rule.declarations[\"stroke\"] && ctx.stroke();\r\n\r\n    ctx.restore();\r\n\r\n    // Text Handling, Icons etc.\r\n    if (rule.declarations[\"content\"] || rule.declarations[\"size\"] || rule.declarations[\"path\"] || rule.declarations[\"icon\"]) {\r\n        ctx.save();\r\n        renderPoint(ctx, rule, getPoint(points), element, context);\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\n\r\n","import MapRenderer from \"../MapRenderer\";\r\nimport { renderPoint } from \"./renderPoint\";\r\nimport { setFont } from \"./renderText\";\r\nimport { renderAreaLine } from \"./renderAreaLine\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n\r\nexport default class CanvasRender extends MapRenderer {\r\n\r\n    /**\r\n     * @param {HTMLCanvasElement|OffscreenCanvas} canvas\r\n     */\r\n    constructor (canvas) {\r\n        super();\r\n        this.canvas = canvas;\r\n    }\r\n\r\n    clear (context) {\r\n        const { width, height } = context;\r\n\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n    }\r\n\r\n    renderRule (context, rule, elements=[]) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        ctx.save();\r\n        super.renderRule(context, rule, elements);\r\n        ctx.restore();\r\n    }\r\n\r\n    globalSetup({ scale }, rule) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n\r\n        if (rule.declarations[\"opacity\"])\r\n            ctx.globalAlpha = +rule.declarations[\"opacity\"];\r\n\r\n        if (rule.declarations[\"position\"] === \"relative\") {\r\n            const top = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n            const left = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n\r\n            ctx.translate(left, top);\r\n        }\r\n    }\r\n\r\n    renderPoint (context, rule, point, element=null) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        renderPoint(ctx, rule, point, element, context);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        renderAreaLine(ctx, rule, points, getPoint, element, context);\r\n    }\r\n\r\n    measureText (context, rule, text) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        const { scale } = context;\r\n        setFont(ctx, rule, scale);\r\n        const size = ctx.measureText(text);\r\n        const { width, actualBoundingBoxDescent: descending, actualBoundingBoxAscent: ascending } = size;\r\n\r\n        return {\r\n            width,\r\n            ascending,\r\n            descending,\r\n            height: ascending + descending,\r\n        };\r\n    }\r\n}\r\n\r\n","export default function() {\n  return new Worker(__webpack_public_path__ + \"static/js/render-worker.bc6cf0f4.worker.js\");\n}\n","// @ts-ignore\nimport RenderWorker from 'worker-loader!./render-worker'; // eslint-disable-line import/no-webpack-loader-syntax\nimport MapRenderer from './MapRenderer';\n\nexport default class WorkerRenderer extends MapRenderer {\n    /**\n     * @param {HTMLCanvasElement} canvas\n     */\n    constructor (canvas) {\n        super();\n\n        this.canvas = canvas.transferControlToOffscreen();\n        /** @type {Worker} */\n        this.worker = new RenderWorker();\n\n        this.worker.postMessage({ canvas: this.canvas }, [ this.canvas ]);\n    }\n\n    clear (context) {\n        this.worker.postMessage({ method: \"clear\", context });\n    }\n\n    renderRule (context, rule, _elements) {\n        this.worker.postMessage({ method: \"renderRule\", context, rule });\n    }\n}","// import { renderPoint } from \"./renderPoint\";\r\n// import { applyTransform } from \"./transform\";\r\nimport { parseStrokeFill } from \"../parseStrokeFill\";\r\nimport { getBoundingBox } from \"../util\";\r\nimport CollisionSystem from \"../CollisionSystem\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {{ elements: { type: string, [key: string]: string }[] }} layer\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {(points: [number, number][]) => [number, number]} getPoint\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderAreaLine(layer, rule, points, getPoint, element = null, context = {}) {\r\n    if (points.length === 0)\r\n        return;\r\n\r\n\r\n    if (rule.declarations[\"collision-set\"]) {\r\n        const box = getBoundingBox(points);\r\n\r\n        const collisionSystem = CollisionSystem.getCollisionSystem();\r\n\r\n        if (!collisionSystem.add(rule.declarations[\"collision-set\"], box)) {\r\n            const policy = rule.declarations[\"collision-policy\"] || \"hide\";\r\n\r\n            if (policy === \"hide\") {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    const path = { type: \"path\" };\r\n\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        // Extra work required if we're transforming\r\n\r\n        // First get transform origin;\r\n        const cp = getPoint(points);\r\n\r\n        // Set offset to adjust all points later\r\n        offsetX = cp[0];\r\n        offsetY = cp[1];\r\n\r\n        // Translate the canvas\r\n        // ctx.translate(offsetX, offsetY);\r\n\r\n        // Apply the transformation\r\n        // applyTransform(path, rule);\r\n\r\n        path.transform = rule.declarations[\"transform\"];\r\n    }\r\n\r\n    const d = [];\r\n\r\n    d.push(`M ${(points[0][0] - offsetX).toFixed(2)} ${(points[0][1] - offsetY).toFixed(2)}`);\r\n    for (let i = 1; i < points.length; i++) {\r\n        d.push(`L ${(points[i][0] - offsetX).toFixed(2)} ${(points[i][1] - offsetY).toFixed(2)}`);\r\n    }\r\n\r\n    path.d = d.join(\" \");\r\n\r\n    layer.elements.push(path);\r\n\r\n    // Text Handling, Icons etc.\r\n    if (rule.declarations[\"content\"] || rule.declarations[\"size\"] || rule.declarations[\"path\"] || rule.declarations[\"icon\"]) {\r\n        // this.renderPoint(context, rule, getPoint(points), element);\r\n    }\r\n}\r\n\r\n\r\n","import MapRenderer from \"../MapRenderer\";\r\nimport { renderAreaLine } from \"./renderAreaLine\";\r\nimport { parseStrokeFill } from \"../parseStrokeFill\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\nexport default class SVGRender extends MapRenderer {\r\n    /**\r\n     * @param {number} width\r\n     * @param {number} height\r\n     */\r\n    constructor (width, height) {\r\n        super();\r\n        this.layers = [];\r\n        this.width = width;\r\n        this.height = height;\r\n        this.currentLayer = null;\r\n    }\r\n\r\n    clear () {\r\n        this.layers.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @param {import(\"../MapRenderer\").MapContext} context\r\n     * @param {import(\"../Style\").StyleRule} rule\r\n     * @param {import(\"../Overpass\").OverpassElement[]} elements\r\n     */\r\n    renderRule (context, rule, elements=[]) {\r\n        this.currentLayer = { elements: [] };\r\n\r\n        const colours = parseStrokeFill(rule);\r\n\r\n        this.currentLayer.stroke = colours.strokeStyle;\r\n        this.currentLayer.fill = colours.fillStyle || \"none\";\r\n\r\n        // Set up global context options\r\n        layerSetup(this.currentLayer, rule, context.scale);\r\n\r\n        super.renderRule(context, rule, elements);\r\n\r\n        this.layers.push(this.currentLayer);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {\r\n        renderAreaLine(this.currentLayer, rule, points, getPoint, element, context);\r\n    }\r\n\r\n    toString () {\r\n        return this.getTextParts().join(\"\");\r\n    }\r\n\r\n    toBlob () {\r\n        return new Blob(this.getTextParts());\r\n    }\r\n\r\n    getTextParts() {\r\n        const parts = [];\r\n\r\n        parts.push(`<svg version=\"1.1\" viewBox=\"0 0 ${this.width} ${this.height}\" width=\"${this.width}\" height=\"${this.height}\" xmlns=\"http://www.w3.org/2000/svg\">\\n`);\r\n\r\n        for (const layer of this.layers) {\r\n            const { elements, ...attr } = layer;\r\n\r\n            parts.push(`<g ${attributes(attr)}>\\n`);\r\n\r\n            for (const element of elements) {\r\n                const { type, ...attr } = element;\r\n                parts.push(`<${type} ${attributes(attr)} />\\n`);\r\n            }\r\n\r\n            parts.push(`</g>\\n`);\r\n        }\r\n\r\n        parts.push(`</svg>`);\r\n        return parts;\r\n    }\r\n}\r\n\r\nfunction attributes(attr) {\r\n    return Object.entries(attr).filter(([key, value]) => typeof value !== \"undefined\").map(([key, value]) => `${key}=\"${value}\"`).join(\" \");\r\n}\r\n\r\nexport function layerSetup(layer, rule, scale) {\r\n    if (rule.declarations[\"opacity\"])\r\n        layer.opacity = +rule.declarations[\"opacity\"];\r\n\r\n    if (rule.declarations[\"position\"] === \"relative\") {\r\n        const top = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n        const left = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n\r\n        layer.translate = [left, top];\r\n    }\r\n}\r\n","import { contains, getArea } from \"./bbox\";\r\n\r\nexport default class IDBElementDatabase {\r\n    constructor (name=\"OverpassElements\") {\r\n        const request = indexedDB.open(name);\r\n\r\n        request.addEventListener(\"upgradeneeded\", ev => {\r\n            /** @type {IDBOpenDBRequest} */\r\n            const request = (ev.target);\r\n            const db = request.result;\r\n            db.createObjectStore(\"nodes\", { keyPath: \"id\" });\r\n\r\n            const store = db.createObjectStore(\"elements\");\r\n            store.createIndex(\"selectorIndex\", [\"selector\", \"area\", \"bbox\"], { unique: false });\r\n        });\r\n\r\n        /** @type {Promise<IDBDatabase>} */\r\n        this.db = new Promise((resolve, reject) => {\r\n            request.addEventListener(\"success\", ev => {\r\n                /** @type {IDBOpenDBRequest} */\r\n                const request = (ev.target);\r\n                resolve(request.result);\r\n            });\r\n\r\n            request.addEventListener(\"error\", reject);\r\n        })\r\n\r\n    }\r\n\r\n    async saveNodes (nodes) {\r\n        const db = await this.db;\r\n        const store = db.transaction(\"nodes\", \"readwrite\").objectStore(\"nodes\");\r\n        for (const n of nodes) {\r\n            store.put(n);\r\n        }\r\n    }\r\n\r\n    async getNode (id) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const store = db.transaction(\"nodes\", \"readonly\").objectStore(\"nodes\");\r\n            const request = store.get(id);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", e => reject(e));\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number[]} ids\r\n     */\r\n    getNodes (ids) {\r\n        return Promise.all(ids.map(id => this.getNode(id)));\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} bbox\r\n     * @param {string} selector\r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    getElements (bbox, selector) {\r\n        const key = makeKey(bbox, selector);\r\n        return this.getElementsByKey(key);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} key\r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    async getElementsByKey (key) {\r\n        const db = await this.db;\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const request = objectStore.get(key);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} bbox\r\n     * @param {string} selector\r\n     * @returns {Promise<string>}\r\n     */\r\n    async searchElements (bbox, selector) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const index = objectStore.index(\"selectorIndex\");\r\n            const range = IDBKeyRange.bound([selector,0,\"0\"], [selector,Number.MAX_VALUE,\"999999999999999999\"]);\r\n            const request = index.openKeyCursor(range);\r\n            let count = 0;\r\n            const bboxOversizeArea = getArea(bbox) * 9;\r\n            request.addEventListener(\"success\", e => {\r\n                const cursor = request.result;\r\n\r\n                if (cursor) {\r\n                    const { key, primaryKey } = cursor;\r\n                    const keyBBox = key[2];\r\n                    const keyArea = key[1];\r\n                    count++;\r\n                    console.debug(`Checking index #${count} for ${selector}`);\r\n                    if (contains(keyBBox, bbox) && keyArea < bboxOversizeArea) {\r\n                        console.debug(`${selector} found after checking ${count} records`);\r\n                        resolve(primaryKey.toString());\r\n                        return;\r\n                    }\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    console.debug(`${selector} not found after checking ${count} records`);\r\n                    resolve(null);\r\n                }\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} bbox\r\n     * @param {string} selector\r\n     * @param {{ elements: import(\"./Overpass\").OverpassElement[], cached: number }} record\r\n     */\r\n    async saveElements (bbox, selector, record) {\r\n        const db = await this.db;\r\n        const key = makeKey(bbox, selector);\r\n        const area = getArea(bbox);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readwrite\").objectStore(\"elements\");\r\n            const request = objectStore.put({ selector, bbox, area, ...record }, key);\r\n            request.addEventListener(\"success\", () => {\r\n                console.debug(`Saved ${selector}/${bbox} to database with ${record.elements.length} elements`);\r\n                resolve();\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    // Delete all saved nodes\r\n    async clear () {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const req = db.transaction(\"elements\", \"readwrite\").objectStore(\"elements\").clear();\r\n            req.onsuccess = resolve;\r\n            req.onerror = reject;\r\n        });\r\n    }\r\n}\r\n\r\nfunction makeKey (bbox, selector) {\r\n    const bkey = bbox.split(\",\").map(p => (+p).toFixed(3)).join(\",\");\r\n    return `${selector}/${bkey}`;\r\n}\r\n","import IDBElementDatabase from \"./database.idb\";\r\nimport { contains } from \"./bbox\";\r\nimport { matchSelector } from \"./Style\";\r\nimport { timeout } from './util';\r\n\r\n/** @typedef {import(\"./Style\").StyleSelector} StyleSelector */\r\n\r\nconst API_ROOT = require(\"./const\").API_ROOT;\r\n\r\nconst overpassRe = /^(node|way|rel(?:ation)?|area)/;\r\nconst recurRe = /^(way|rel(?:ation)?|area)/;\r\n\r\nexport class Overpass {\r\n    /** @param {string} bbox */\r\n    constructor (bbox=null) {\r\n        /** @type {Map<string, Promise<OverpassElement[]>>} */\r\n        this.elements = new Map();\r\n        this.bbox = bbox;\r\n        this.database = new IDBElementDatabase();\r\n        /** @type {{ [url: string]: Promise<OverpassElement[]> }} */\r\n        this.fetchMap = {};\r\n        /** @type {Promise<any>} */\r\n        this.currentJob = Promise.resolve();\r\n    }\r\n\r\n    setBBox (bbox) {\r\n        // If the new bbox is completely contained within the\r\n        // old one then we don't need to clear our cache\r\n        if (this.bbox && !contains(this.bbox, bbox)) {\r\n            this.elements.clear();\r\n        }\r\n        this.bbox = bbox;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     */\r\n    async preLoadElements (selectors) {\r\n        return this.jobs(async () => {\r\n            const { bbox } = this;\r\n\r\n            if (!this.bbox) {\r\n                throw Error(\"No bounding box specified\");\r\n            }\r\n\r\n            // Create set of selectors\r\n            /** @type {{ [key: string]: StyleSelector }} */\r\n            const set = {};\r\n            selectors.forEach(s => set[mapSelector(s)] = s);\r\n\r\n            console.debug(`Preloading Elements: ${selectors.length} requested (${Object.keys(set).length} unique)`);\r\n\r\n            // Remove non-overpass selectors\r\n            for (const [key, selector] of Object.entries(set)) {\r\n                if (!overpassRe.test(selector.type)) delete set[key];\r\n            }\r\n            console.debug(`Preloading Elements: ${Object.keys(set).length} are Overpass Elements`);\r\n\r\n            // Remove selectors found in local hash map cache\r\n            for (const key of Object.keys(set)) {\r\n                if (this.elements.has(key)) delete set[key];\r\n            }\r\n            console.debug(`Preloading Elements: ${Object.keys(set).length} not in HashMap`);\r\n\r\n            // Remove selectors which were found in database\r\n            await Promise.all(Object.keys(set).map(s => {\r\n                return this.database.searchElements(bbox, s)\r\n                    .then(els => {\r\n                        if (els) delete set[s];\r\n                    });\r\n            }));\r\n            console.debug(`Preloading Elements: ${Object.keys(set).length} not in Database`);\r\n\r\n            if (Object.keys(set).length === 0) return 0;\r\n\r\n            const elements = await this.tryQuery(Object.values(set));\r\n\r\n            console.log(`Preloading Elements: Fetched ${elements.length} elements from Server`);\r\n\r\n            // Prepare node map\r\n            /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n            const nodeMap = {};\r\n            elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n            // Prepare way map\r\n            /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n            const wayMap = {};\r\n            elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n            await Promise.all(Object.values(set).map(selector => {\r\n                const out = elements.filter(el => matchSelector(selector, el, false));\r\n\r\n                if (selector.type === \"relation\") {\r\n                    /** @type {OverpassRelElement[]} */\r\n                    const rels = (out.slice());\r\n\r\n                    /** @type {OverpassWayElement[]} */\r\n                    const ways = [];\r\n\r\n                    for (const rel of rels) {\r\n                        const refs = rel.members.map(m => m.ref);\r\n                        ways.push(...refs.map(id => wayMap[id]));\r\n                    }\r\n\r\n                    out.push(...ways);\r\n\r\n                    for (const way of ways) {\r\n                        out.push(...way.nodes.map(id => nodeMap[id]));\r\n                    }\r\n\r\n                } else if (selector.type === \"way\" || selector.type === \"area\") {\r\n                    /** @type {OverpassWayElement[]} */\r\n                    const ways = (out.slice());\r\n\r\n                    for (const way of ways) {\r\n                        out.push(...way.nodes.map(id => nodeMap[id]));\r\n                    }\r\n                }\r\n\r\n                this.elements.set(mapSelector(selector), Promise.resolve(out));\r\n                return this.database.saveElements(bbox, mapSelector(selector), { elements: out, cached: Date.now() });\r\n            }));\r\n\r\n            return elements.length;\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    query (selectors) {\r\n        if (this.bbox.split(\",\").map(p => +p).some(isNaN)) throw Error(\"Invalid BBox\");\r\n\r\n        const sMap = selectors.map(mapSelectorForQuery);\r\n        const query = `[out:json][bbox];\\n(${sMap.join(\"\")}\\n);\\nout;`\r\n        const url = `${API_ROOT}?data=${query.replace(/\\s/,\"\")}&bbox=${clampBBox(this.bbox)}`;\r\n\r\n        if (!this.fetchMap[url]) {;\r\n            this.fetchMap[url] = fetch(url.toString()).then(r => r.ok ? r.json() : Promise.reject(r.status)).then(r => r.elements);\r\n\r\n            this.fetchMap[url].finally(() => delete this.fetchMap[url]);\r\n        }\r\n\r\n        return this.fetchMap[url];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     * @param {number} tries\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    tryQuery (selectors, tries=10) {\r\n        return this.query(selectors).catch(e => {\r\n            if (e !== 429) throw Error(\"Bad Response\");\r\n\r\n            if (tries > 0) {\r\n                return timeout(10000).then(() => this.tryQuery(selectors, tries - 1))\r\n            }\r\n\r\n            throw Error(\"Too many retries fetching data\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {import(\"./Style\").StyleSelector} selector\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    async getElements (selector) {\r\n        if (!overpassRe.test(selector.type)) return;\r\n\r\n        if (!this.bbox) return;\r\n\r\n        const s = mapSelector(selector);\r\n        if (this.elements.has(s)) return this.elements.get(s);\r\n\r\n        const dbResult = await this.database.getElements(this.bbox, s);\r\n\r\n        if (dbResult) {\r\n            const { elements } = dbResult;\r\n            this.elements.set(s, Promise.resolve(elements));\r\n            return elements;\r\n        }\r\n\r\n        const dbSearchResult = await this.database.searchElements(this.bbox, s);\r\n\r\n        if (dbSearchResult) {\r\n            const elements = this.database.getElementsByKey(dbSearchResult).then(r => r.elements);\r\n            this.elements.set(s, elements);\r\n            return elements;\r\n        }\r\n\r\n        const p = this.tryQuery([selector]);\r\n\r\n        this.elements.set(s, p);\r\n\r\n        p.catch(() => this.elements.delete(s));\r\n\r\n        p.then(elements => {\r\n            this.database.saveElements(this.bbox, s, { elements, cached: Date.now() });\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    jobs (fn) {\r\n        this.currentJob = this.currentJob.then(() => fn());\r\n\r\n        return this.currentJob;\r\n    }\r\n\r\n    // Delete everything from cache\r\n    clearCache (database = false) {\r\n        this.elements.clear();\r\n        if (database)\r\n            return this.database.clear();\r\n    }\r\n}\r\n\r\n/** @param {StyleSelector} selector */\r\nfunction mapSelectorForQuery (selector) {\r\n    const recur = recurRe.test(selector.type) ? \">;\" : \"\";\r\n    return `${mapSelector(selector)};${recur}`;\r\n}\r\n\r\n/** @param {StyleSelector} selector */\r\nfunction mapSelector (selector) {\r\n    const type = selector.type === \"area\" ? \"way\" : selector.type;\r\n    const tags = Object.entries(selector.tags).map(([k,v]) => {\r\n        return (/^[<=>]+/.test(v) || v === \"*\") ? `[${k}]` : `[${k}=${v}]`;\r\n    });\r\n    return `${type}${tags.join(\"\")}`;\r\n}\r\n\r\n/** @typedef {import('./Style.js').StyleRule} StyleRule */\r\n\r\n/**\r\n * @typedef {OverpassNodeElement|OverpassWayElement|OverpassAreaElement|OverpassRelElement} OverpassElement\r\n */\r\n\r\n/**\r\n * @typedef OverpassNodeElement\r\n * @property {number} id\r\n * @property {\"node\"} type\r\n * @property {number} lon\r\n * @property {number} lat\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassWayElement\r\n * @property {number} id\r\n * @property {\"way\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassAreaElement\r\n * @property {number} id\r\n * @property {\"area\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassRelElement\r\n * @property {number} id\r\n * @property {\"relation\"} type\r\n * @property {{ ref: number, role: \"inner\"|\"outer\", type: \"node\"|\"way\"|\"relation\" }[]} members\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\nfunction clampBBox (bbox) {\r\n    const p = bbox.split(\",\").map(p => +p);\r\n    return `${clamp(p[0], -180, 180)},${clamp(p[1], -90, 90)},${clamp(p[2], -180, 180)},${clamp(p[3], -90, 90)}`;\r\n}\r\n\r\nfunction clamp (v, min, max) {\r\n    return Math.max(min, Math.min(v, max));\r\n}","import { useState, useEffect } from 'react';\r\n\r\n/**\r\n * @link https://usehooks.com/useDebounce/\r\n * @param {any} value \r\n * @param {number} delay \r\n */\r\nexport function useDebounce(value, delay) {\r\n    // State and setters for debounced value\r\n    const [debouncedValue, setDebouncedValue] = useState(value);\r\n  \r\n    useEffect(\r\n      () => {\r\n        // Update debounced value after delay\r\n        const handler = setTimeout(() => {\r\n          setDebouncedValue(value);\r\n        }, delay);\r\n  \r\n        // Cancel the timeout if value changes (also on delay change or unmount)\r\n        // This is how we prevent debounced value from updating if value is changed ...\r\n        // .. within the delay period. Timeout gets cleared and restarted.\r\n        return () => {\r\n          clearTimeout(handler);\r\n        };\r\n      },\r\n      [value, delay] // Only re-call effect if value or delay changes\r\n    );\r\n  \r\n    return debouncedValue;\r\n  }","import React from 'react';\r\n\r\n/**\r\n * \r\n * @param {{ value: string, onChange: (event) => void, [key: string]: any }} param0 \r\n */\r\nexport default function Textarea ({ value, onChange, ...otherProps }) {\r\n    /**\r\n     * @param {React.KeyboardEvent<HTMLTextAreaElement>} event\r\n     */\r\n    function handleKeyDown (event) {\r\n        const { key, currentTarget, shiftKey } = event;\r\n    \r\n        if (key === \"Tab\") {\r\n            event.preventDefault();\r\n    \r\n            const i = currentTarget.selectionStart;\r\n            const lineStart = value.lastIndexOf(\"\\n\", i-1) + 1;\r\n\r\n            if (shiftKey) {\r\n                if (value.substr(lineStart, 4) === \"    \") {\r\n                    const newValue = value.substring(0,lineStart) + value.substring(lineStart + 4);\r\n                    onChange(newValue);\r\n                    \r\n                    setTimeout(() => currentTarget.setSelectionRange(i - 4, i - 4), 10);\r\n                }\r\n            } else {\r\n                const linePos = i - lineStart;\r\n                const x = 4 - linePos % 4;\r\n\r\n                const newValue = value.substring(0,i) + \"    \".substring(0,x) + value.substring(i);\r\n                onChange(newValue);\r\n                \r\n                setTimeout(() => currentTarget.setSelectionRange(i + x, i + x), 10);\r\n            }\r\n        }\r\n    \r\n        else if (key === \"Enter\") {\r\n            event.preventDefault();\r\n\r\n            const i = currentTarget.selectionStart;\r\n            const addIndent = value[i-1] === \"{\";\r\n            const lineStart = value.lastIndexOf(\"\\n\", i-1) + 1;\r\n            const match = value.substring(lineStart, i).match(/^ */);\r\n            const newPos = i + match[0].length + 1 + (addIndent ? 4 : 0);\r\n\r\n            const newValue = value.substring(0,i) + \"\\n\" + (addIndent ? \"    \" : \"\") + match[0] + value.substring(i);\r\n            onChange(newValue);\r\n\r\n            setTimeout(() => currentTarget.setSelectionRange(newPos, newPos), 10);\r\n        }\r\n    }\r\n\r\n    return <textarea value={value} onChange={e => onChange(e.target.value)} onKeyDown={handleKeyDown} {...otherProps} />;\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport useSavedState from './useSavedState';\r\nimport { parseStyle, expandRules } from './Style';\r\nimport CanvasRender from './canvas-render';\r\nimport WorkerRender from './WorkerRenderer';\r\nimport SVGRender from './svg-render';\r\nimport { Overpass } from './Overpass';\r\nimport { useDebounce } from './useDebounce';\r\nimport { makeBBox } from './bbox';\r\nimport useGeolocation from './useGeolocation';\r\nimport Textarea from './Textarea';\r\nimport useDeepCompareEffect from 'use-deep-compare-effect';\r\nimport CollisionSystem from './CollisionSystem';\r\nimport { Console } from 'app-console';\r\n\r\nimport 'app-console/dist/index.css';\r\n\r\nconst WORKER_ENABLED_KEY = \"worker-enabled\";\r\n/** @typedef {import('./MapRenderer').default} MapRenderer */\r\n\r\nfunction App() {\r\n  const [ style, setStyle ] = useSavedState(\"USER_STYLE\", \"node[amenity=post_box] {\\n\\tfill: black;\\n\\tsize: 2;\\n}\");\r\n  const [ centre, setCentre ] = useSavedState(\"USER_CENTRE\", \"7.1,50.7\");\r\n  const [ zoom, setZoom ] = useSavedState(\"USER_SCALE\", 14);\r\n  const current = useGeolocation();\r\n  /** @type {React.MutableRefObject<HTMLCanvasElement>} */\r\n  const canvasRef = React.useRef();\r\n  /** @type {React.MutableRefObject<Overpass>} */\r\n  const overpassRef = React.useRef(new Overpass());\r\n  /** @type {[ string, (string) => void ]} */\r\n  const [ status, setStatus ] = React.useState(null);\r\n  const [ error, setError ] = React.useState(\"\");\r\n  const [ downloading, setDownloading ] = React.useState(false);\r\n  const [ progress, setProgress ] = React.useState(0);\r\n  /** @type {React.MutableRefObject<MapRenderer>} */\r\n  const rendererRef = React.useRef();\r\n  const shellContextRef = React.useRef({\r\n    executables: {\r\n      \"clear-cache\": () => {\r\n        if (overpassRef.current) {\r\n          overpassRef.current.clearCache(true);\r\n        }\r\n      },\r\n    },\r\n  });\r\n  const [ renderPending, forceRender ] = useForceRender();\r\n  React.useEffect(() => {\r\n    const { current: { executables } } = shellContextRef;\r\n    executables.render = forceRender;\r\n    executables.get = name => {\r\n      if (name === \"centre\") return centre;\r\n      if (name === \"zoom\") return zoom;\r\n      if (name === \"myPos\") return `${current.coords.longitude},${current.coords.latitude}`;\r\n      return void 0;\r\n    };\r\n    executables.set = (name, value) => {\r\n      if (name === \"centre\") { setCentre(value); return true; }\r\n      if (name === \"zoom\") { setZoom(value); return true; }\r\n      return false;\r\n    };\r\n    executables[\"enable-worker\"] = () => {\r\n      localStorage.setItem(WORKER_ENABLED_KEY, \"on\");\r\n      window.location.reload();\r\n    };\r\n    executables[\"disable-worker\"] = () => {\r\n      localStorage.removeItem(WORKER_ENABLED_KEY);\r\n      window.location.reload();\r\n    };\r\n  }, [ forceRender, centre, zoom, setCentre, setZoom, current ]);\r\n  const [ consoleVisible, showConsole ] = React.useState(false);\r\n\r\n  const { clientWidth, clientHeight } = canvasRef.current || { clientWidth: 1000, clientHeight: 1000 };\r\n\r\n  const width = clientWidth * devicePixelRatio;\r\n  const height = clientHeight * devicePixelRatio;\r\n\r\n  const debouncedCentre = useDebounce(centre, 500);\r\n  const debouncedZoom = useDebounce(zoom, 500);\r\n\r\n  const bbox = React.useMemo(() => makeBBox(debouncedCentre.split(\",\").map(p => +p), debouncedZoom, [clientWidth, clientHeight]), [debouncedCentre, debouncedZoom, clientWidth, clientHeight]);\r\n\r\n  const debouncedStyle = useDebounce(style, 500);\r\n\r\n  const parsedStyle = React.useMemo(() => parseStyle(debouncedStyle), [debouncedStyle]);\r\n\r\n  React.useEffect(() => overpassRef.current.setBBox(bbox), [bbox]);\r\n\r\n  /** @type {[number, number]} */\r\n  const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\r\n\r\n  /** @type {import('./MapRenderer').MapContext} */\r\n  const context = { centre: centrePoint, zoom: debouncedZoom, bbox, scale: devicePixelRatio, width, height };\r\n  const rules = expandRules(parsedStyle.rules, context);\r\n\r\n  React.useEffect(() => {\r\n    /** @type {(e: KeyboardEvent) => void} */\r\n    const callback = e => e.key === \"k\" && e.ctrlKey && e.altKey && showConsole(!consoleVisible);\r\n\r\n    document.addEventListener(\"keyup\", callback);\r\n\r\n    return () => document.removeEventListener(\"keyup\", callback);\r\n  }, [consoleVisible]);\r\n\r\n  if (rules.some(r => r.selector.type === \"current\")) {\r\n    const { coords: { longitude, latitude } } = current || { coords: {} };\r\n    context.current = { longitude, latitude };\r\n  }\r\n\r\n  if (canvasRef.current && !rendererRef.current) {\r\n    if (window.Worker && canvasRef.current.transferControlToOffscreen && localStorage.getItem(WORKER_ENABLED_KEY)) {\r\n      rendererRef.current = new WorkerRender(canvasRef.current);\r\n    } else {\r\n      rendererRef.current = new CanvasRender(canvasRef.current);\r\n    }\r\n  }\r\n\r\n  // Refetch/Render map when bbox, or style change\r\n  useDeepCompareEffect(() => {\r\n    // Double pointer to update inside render function scope\r\n    let current = { currentEffect: true };\r\n\r\n    render(rules, overpassRef.current, rendererRef.current, context, setStatus, setError, setProgress, current);\r\n\r\n    return () => { current.currentEffect = false; };\r\n  }, [debouncedCentre, debouncedZoom, rules, context, renderPending]);\r\n\r\n  function move (dX, dY) {\r\n    /** @type {[number, number]} */\r\n    const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\r\n    const bb = bbox.split(\",\").map(p => +p);\r\n    const stepSizeX = (bb[2] - bb[0]) / 2;\r\n    const stepSizeY = (bb[3] - bb[1]) / 2;\r\n    const newCentre = [ cleanup(centrePoint[0] + dX * stepSizeX), cleanup(centrePoint[1] + dY * stepSizeY) ];\r\n    setCentre(newCentre.join(\",\"));\r\n  }\r\n\r\n  function handleDownload (type) {\r\n    if (!downloading) {\r\n      setDownloading(true);\r\n      const cb = () => setDownloading(false);\r\n      if (type === \"png\") {\r\n        downloadPNG(canvasRef.current, cb);\r\n      } else {\r\n        downloadSVG(context, parsedStyle, overpassRef.current, cb);\r\n      }\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"sidebar\">\r\n        <div className=\"controls\">\r\n          <button onClick={() => move(-1,0)}>⏴</button>\r\n          <button onClick={() => move(1,0)}>⏵</button>\r\n          <button onClick={() => move(0,1)}>⏶</button>\r\n          <button onClick={() => move(0,-1)}>⏷</button>\r\n          <button onClick={() => setZoom(+cleanup(zoom + 1))}>➕</button>\r\n          <button onClick={() => setZoom(+cleanup(zoom - 1))}>➖</button>\r\n          { current && <button onClick={() => setCentre(`${current.coords.longitude},${current.coords.latitude}`)}>📍</button> }\r\n          <button onClick={() => handleDownload(\"png\")} disabled={downloading}>⭳ PNG</button>\r\n          <button onClick={() => handleDownload(\"svg\")} disabled={downloading}>⭳ SVG</button>\r\n        </div>\r\n        <label>Centre <input value={centre} onChange={e => setCentre(e.target.value)} /></label>\r\n        <label>Zoom <input type=\"number\" value={zoom} onChange={e => setZoom(+e.target.value)} /></label>\r\n        <Textarea value={style} onChange={setStyle} style={{flex:1}} spellCheck={false} />\r\n        <div className=\"status-area\">\r\n          { status && <p>{status}</p> }\r\n          { progress > 0 && <progress value={progress} />}\r\n          { error && <p style={{color:\"red\"}}>{error}</p> }\r\n        </div>\r\n        { consoleVisible && <Console context={shellContextRef.current} style={{ maxHeight: 200 }} /> }\r\n      </div>\r\n      <canvas ref={canvasRef} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n/**\r\n * @param {HTMLCanvasElement} canvas\r\n */\r\nfunction downloadPNG (canvas, callback=null) {\r\n  canvas.toBlob(blob => {\r\n    blobDownload(blob, \"map.png\");\r\n    if (callback) callback();\r\n  });\r\n}\r\n\r\nasync function downloadSVG (context, style, overpass, callback=null) {\r\n  const rules = expandRules(style.rules, context);\r\n\r\n  const map = rules.map(rule => {\r\n    return {\r\n      rule,\r\n      promise: overpass.getElements(rule.selector),\r\n    }\r\n  });\r\n\r\n  CollisionSystem.getCollisionSystem().clear();\r\n\r\n  const svgRender = new SVGRender(context.width, context.height);\r\n\r\n  for (const item of map) {\r\n    const elements = await item.promise;\r\n    svgRender.renderRule(context, item.rule, elements);\r\n  }\r\n\r\n  const blob = svgRender.toBlob();\r\n  blobDownload(blob, \"map.svg\");\r\n\r\n  if (callback) callback();\r\n}\r\n\r\nfunction blobDownload (blob, filename) {\r\n  const url = URL.createObjectURL(blob);\r\n  const a = document.createElement(\"a\");\r\n  a.download = filename;\r\n  a.href = url;\r\n  document.body.appendChild(a);\r\n  a.click();\r\n  document.body.removeChild(a);\r\n  URL.revokeObjectURL(url);\r\n}\r\n\r\n/**\r\n * @param {number} n\r\n */\r\nfunction cleanup (n) {\r\n  return n.toFixed(5).replace(/^0+|0+$/g, \"\");\r\n}\r\n\r\nfunction useForceRender () {\r\n  const [ counter, setCounter ] = React.useState(0);\r\n\r\n  return [ counter, () => setCounter(c => c + 1) ];\r\n}\r\n\r\n/**\r\n * @param {import('./Style').StyleRule[]} [rules]\r\n * @param {Overpass} [overpass]\r\n * @param {MapRenderer} [renderer]\r\n * @param {import('./MapRenderer').MapContext} [context]\r\n * @param {(arg0: string) => void} [setStatus]\r\n * @param {(arg0: string) => void} [setError]\r\n * @param {(arg0: number) => void} [setProgress]\r\n * @param {{ currentEffect: any; }} [current]\r\n */\r\nasync function render (rules, overpass, renderer, context, setStatus, setError, setProgress, current) {\r\n  setStatus(\"Fetching...\");\r\n  setError(\"\");\r\n\r\n  try {\r\n    const count = await overpass.preLoadElements(rules.map(r => r.selector));\r\n\r\n    if (!current.currentEffect) return;\r\n\r\n    // Check if we're already preloading something\r\n    if (count < 0) return;\r\n\r\n    if (count === 0)\r\n      setStatus(`Rendering...`);\r\n    else\r\n      setStatus(`Rendering ${count} elements...`);\r\n\r\n    const map = rules.map(rule => {\r\n      return {\r\n        rule,\r\n        promise: renderer instanceof WorkerRender ? Promise.resolve() : overpass.getElements(rule.selector),\r\n      }\r\n    });\r\n\r\n    CollisionSystem.getCollisionSystem().clear();\r\n\r\n    if (renderer) {\r\n      if (!current.currentEffect) return;\r\n\r\n      renderer.clear(context);\r\n\r\n      let count = 0;\r\n      // setProgress(0);\r\n\r\n      for (const item of map) {\r\n        const prefix = `${++count}/${map.length}`;\r\n\r\n        console.debug(`${prefix} Loading elements for ${item.rule.selector}`);\r\n        const elements = await item.promise;\r\n\r\n        if (!current.currentEffect) return;\r\n\r\n        console.debug(`${prefix} Rendering ${item.rule.selector}`);\r\n\r\n        renderer.renderRule(context, item.rule, elements);\r\n\r\n        // setProgress(count/map.length);\r\n      }\r\n      // setProgress(0);\r\n\r\n      console.debug(`Rendered!`);\r\n    }\r\n\r\n    setStatus(null);\r\n  } catch (e) {\r\n    setError(\"Error Fetching\");\r\n    setStatus(null);\r\n    console.log(e);\r\n  }\r\n}","import React from 'react';\r\n\r\nexport default function useGeolocation () {\r\n    /** @type {[Position, (newPos: Position) => void]} */\r\n    const [ loc, setLoc ] = React.useState();\r\n\r\n    React.useEffect(() => { navigator.geolocation.getCurrentPosition(setLoc) }, []);\r\n\r\n    React.useEffect(() => {\r\n        const id = navigator.geolocation.watchPosition(setLoc);\r\n\r\n        return () => navigator.geolocation.clearWatch(id);\r\n    }, []);\r\n\r\n    return loc;\r\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}