{"version":3,"sources":["const.js","useSavedState.js","Style.js","bbox.js","geometry.js","render.js","database.idb.js","Overpass.js","useDebounce.js","Textarea.js","App.js","useGeolocation.js","serviceWorker.js","index.js"],"names":["API_ROOT","useSavedState","key","initalState","React","useState","saved","localStorage","getItem","JSON","parse","e","state","setState","newState","setItem","stringify","StyleSelector","type","tags","pseudoClasses","pseudoElement","this","Object","entries","map","k","v","join","matchSelector","selector","element","match","value","parseMedia","mediaText","match2","re","out","mediaQueries","index","re2","exec","predicate","makePredicate","length","parseRules","substring","rules","push","console","log","ruleText","declarations","split","s","trim","filter","forEach","i","indexOf","property","selectors","parseMultiple","expandRules","context","rule","testPredicate","left","operator","right","Function","op","COMPARE","text","m","tagText","m2","re3","m3","params","test","name","re4","m4","x","a","b","contains","areaA","areaB","Ax1","Ay1","Ax2","Ay2","Bx1","By1","Bx2","By2","getArea","bbox","parts","makeBBox","centre","scale","size","lon","lat","width","height","tileCount","Math","pow","dLon","dLat","p","toFixed","rectToPoints","y","getCrossProductArea","points","sum","abs","isAntiClockwise","isConvex","l","sign","c","next","isSelfClosing","f","getLength","dx","dy","sqrt","clearMap","canvas","clientWidth","clientHeight","devicePixelRatio","renderMap","elements","nodeMap","n","id","wayMap","ctx","getContext","projection","mercatorProjection","save","globalAlpha","top","parseFloat","translate","renderArea","current","coords","renderPoint","longitude","latitude","renderGridlines","el","nodes","some","hasPseudoClasses","pc","area","getBoundingBox","midPoint","getMidPoint","avgPoint","getAveragePoint","bounding","boundingPoints","renderLine","members","fillStyle","strokeStyle","lineWidth","beginPath","ways","ref","way","moveTo","lineTo","closePath","fill","stroke","restore","vertical","find","horizontal","step","round","xmin","floor","xmax","ceil","ymin","ymax","j","r","ellipse","PI","renderText","point","content","replace","fontSize","fontWeight","fontFamily","font","textWidth","measureText","fillText","strokeText","cLon","cLat","hPixelsPerDeg","vPixelsPerDeg","QUARTER_PI","cX","cY","cLatPrime","tan","E","N","reduce","boundingBox","minMax","min","max","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","IDBElementDatabase","request","indexedDB","open","addEventListener","ev","db","target","result","createObjectStore","keyPath","createIndex","unique","Promise","resolve","reject","store","transaction","objectStore","put","get","ids","all","getNode","makeKey","getElementsByKey","range","IDBKeyRange","bound","MAX_VALUE","openKeyCursor","count","cursor","primaryKey","keyBBox","debug","continue","record","bkey","require","overpassRe","recurRe","Overpass","Map","database","clear","set","toString","keys","has","searchElements","then","els","query","values","rels","slice","refs","saveElements","cached","Date","now","sMap","url","currentFetch","promise","fetch","ok","json","status","tries","d","setTimeout","tryElements","getElements","dbResult","dbSearchResult","catch","delete","useDebounce","delay","debouncedValue","setDebouncedValue","useEffect","handler","clearTimeout","Textarea","onChange","style","onKeyDown","event","currentTarget","preventDefault","selectionStart","lineStart","lastIndexOf","newValue","setSelectionRange","addIndent","newPos","App","setStyle","setCentre","setScale","loc","setLoc","navigator","geolocation","getCurrentPosition","watchPosition","clearWatch","useGeolocation","canvasRef","useRef","overpassRef","fetching","setFetching","error","setError","debouncedCentre","debouncedScale","useMemo","debouncedStyle","parsedStyle","styleText","rulesResult","mediaResult","parseStyle","move","dX","dY","centrePoint","stepSize","newCentre","setBBox","useDeepCompareEffect","zoom","preLoadElements","item","run","className","onClick","flex","color","Boolean","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.f38be9af.chunk.js","sourcesContent":["\r\nexport const API_ROOT = \"https://lz4.overpass-api.de/api/interpreter\";","import React from 'react';\r\n\r\n/**\r\n * @template T\r\n * @param {string} key \r\n * @param {T} initalState \r\n * @returns {[ T, (newState: T) => void ]}\r\n */\r\nexport default function useSavedState (key, initalState) {\r\n    const [ state, setState ] = React.useState(() => {\r\n        const saved = localStorage.getItem(key);\r\n    \r\n        if (saved) {\r\n            try {\r\n                initalState = JSON.parse(saved);\r\n            } catch (e) {}\r\n        }\r\n\r\n        return initalState;\r\n    });\r\n\r\n    return [\r\n        state,\r\n        newState => {\r\n            localStorage.setItem(key, JSON.stringify(newState));\r\n            setState(newState);\r\n        }\r\n    ]\r\n}","/** \r\n * @typedef StyleRule\r\n * @property {\"rule\"} type\r\n * @property {StyleSelector} [selector]\r\n * @property {StyleSelector[]} [selectors]\r\n * @property {{ [key: string]: string }} declarations\r\n */\r\n\r\n/**\r\n * @typedef MediaQuery\r\n * @property {\"query\"} type\r\n * @property {Predicate} predicate \r\n * @property {StyleRule[]} rules\r\n */\r\n\r\n/**\r\n * @typedef Predicate\r\n * @property {string|number|Predicate} left\r\n * @property {string} operator\r\n * @property {string|number|Predicate} right\r\n */\r\n\r\nexport class StyleSelector {\r\n    /**\r\n     * @param {string} type\r\n     * @param {{ [key: string]: string }} tags\r\n     * @param {{ name: string, params: (string|Predicate)[] }[]} pseudoClasses\r\n     * @param {string} [pseudoElement]\r\n     */\r\n    constructor (type, tags, pseudoClasses=[], pseudoElement=null) {\r\n      this.type = type;\r\n      this.tags = tags;\r\n      this.pseudoClasses = pseudoClasses;\r\n      this.pseudoElement = pseudoElement;\r\n    }\r\n  \r\n    toString () {\r\n      return `${this.type}${Object.entries(this.tags).map(([k,v]) => `[${k}=${v}]`).join(\"\")}`;\r\n    }\r\n}\r\n  \r\nStyleSelector.parse = /**\r\n * @param {string} text\r\n */\r\nfunction (text) {\r\n    const re = /^\\s*([a-z]+)/;\r\n    const m = re.exec(text);\r\n  \r\n    if (!m) return null;\r\n\r\n    let type = m[1];\r\n\r\n    if (type === \"rel\") {\r\n      type = \"relation\";\r\n    }\r\n\r\n    /** @type {{ [key: string]: string }} */\r\n    const tags = {};\r\n  \r\n    let tagText = text.substring(m[0].length).trim();\r\n  \r\n    const re2 = /^\\[([^[\\]=]+)=([^[\\]=]+)\\]/;\r\n\r\n    while (true) {\r\n      const m2 = re2.exec(tagText);\r\n\r\n      if (!m2) break;\r\n\r\n      tags[m2[1]] = m2[2];\r\n\r\n      tagText = tagText.substring(m2[0].length);\r\n    }\r\n\r\n    /** @type {{ name: string, params: (string|Predicate)[] }[]} */\r\n    const pseudoClasses = [];\r\n  \r\n    const re3 = /^:([a-z-]+)(?:\\(([^)]+)\\))?/;\r\n\r\n    while (true) {\r\n      const m3 = re3.exec(tagText);\r\n\r\n      if (!m3) break;\r\n\r\n      const re = /^\\s*([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?/;\r\n      const params = m3[2] ? m3[2].split(\",\").map(s => re.test(s) ? makePredicate(re.exec(s)) : s) : [];\r\n      pseudoClasses.push({ name: m3[1], params });\r\n\r\n      tagText = tagText.substring(m3[0].length);\r\n    }\r\n\r\n    let pseudoElement = null;\r\n  \r\n    const re4 = /^::([a-z-]+)?/;\r\n\r\n    if (re4.test(tagText)) {\r\n      const m4 = re4.exec(tagText);\r\n\r\n      pseudoElement = m4[1];\r\n\r\n      tagText = tagText.substring(m4[0].length);\r\n    }\r\n\r\n    if (tagText.length) {\r\n      console.log(`Invalid selector: ${text} unexpected part: '${tagText}'`);\r\n      return null;\r\n    }\r\n  \r\n    return new StyleSelector(type, tags, pseudoClasses, pseudoElement);\r\n};\r\n  \r\n/**\r\n * \r\n * @param {string} text \r\n */\r\nStyleSelector.parseMultiple = function (text) {\r\n    return text.split(\",\").map(StyleSelector.parse).filter(x => x);\r\n}\r\n\r\n/**\r\n * \r\n * @param {{ rules: StyleRule[] }} style \r\n * @param {import(\"./Overpass\").OverpassElement} element \r\n * @returns {StyleRule}\r\n */\r\nexport function matchRule (style, element) {\r\n    for (const rule of style.rules) {\r\n      for (const selector of rule.selectors) {\r\n        if (matchSelector(selector, element))  return rule;\r\n      }\r\n    }\r\n}\r\n\r\n/**\r\n * @param {StyleSelector} selector\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n */\r\nexport function matchSelector (selector, element) {\r\n  if (element.type !== selector.type) return false;\r\n\r\n  let match = true;\r\n\r\n  for (const [key, value] of Object.entries(selector.tags)) {\r\n    if (!element.tags || element.tags[key] !== value) {\r\n      match = false;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return match;\r\n}\r\n\r\n/**\r\n * @param {string} styleText\r\n */\r\nexport function parseStyle (styleText) {\r\n  /** @type {{ rules: (StyleRule|MediaQuery)[] }} */\r\n  const out = { rules: [] };\r\n\r\n  let length = styleText.length;\r\n\r\n  while (length > 0) {\r\n\r\n    // Try parsing rule list\r\n    const rulesResult = parseRules(styleText);\r\n    out.rules.push(...rulesResult.rules);\r\n    styleText = styleText.substring(rulesResult.index).trim();\r\n\r\n    // Try parsing media query\r\n    const mediaResult = parseMedia(styleText);\r\n    out.rules.push(...mediaResult.mediaQueries);\r\n    styleText = styleText.substring(mediaResult.index).trim();\r\n\r\n    if (styleText.length === length) {\r\n      console.log(\"Got stuck parsing style at: \" + styleText);\r\n      break;\r\n    }\r\n\r\n    length = styleText.length;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * @param {string} mediaText\r\n */\r\nfunction parseMedia (mediaText) {\r\n  const re = /^\\s*@match\\s*\\(([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?\\)\\s*{/;\r\n  /** @type {{ mediaQueries: MediaQuery[], index: number }} */\r\n  const out = { mediaQueries: [], index: 0 };\r\n  let match;\r\n\r\n  const re2 = /^\\s*}/;\r\n  let match2;\r\n\r\n  while (match = re.exec(mediaText)) {\r\n    const predicate = makePredicate(match);\r\n\r\n    out.index += match[0].length;\r\n\r\n    mediaText = mediaText.substring(match[0].length);\r\n\r\n    const { rules, index } = parseRules(mediaText);\r\n\r\n    out.index += index;\r\n\r\n    mediaText = mediaText.substring(index);\r\n\r\n    match2 = re2.exec(mediaText);\r\n    \r\n    if (match2) {\r\n      out.mediaQueries.push({\r\n        type: \"query\",\r\n        predicate,\r\n        rules,\r\n      });\r\n\r\n      out.index += match2[0].length;\r\n\r\n    } else {\r\n      console.log(\"Unterminated media query\");\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nfunction parseRules (ruleText) {\r\n  const re = /^\\s*([^{}]+)\\s*{([^{}]*)}/;\r\n  let match;\r\n  /** @type {{ rules: StyleRule[], index: number }} */\r\n  const out = { rules: [], index: 0 };\r\n\r\n  while(match = re.exec(ruleText)) {\r\n    /** @type {{ [key: string]: string }} */\r\n    const declarations = {};\r\n    \r\n    match[2].split(\";\").map(s => s.trim()).filter(s => s).forEach(s => {\r\n      // s.split(\":\", 2) is not the same as PHP\r\n      const i = s.indexOf(\":\");\r\n      const property = s.substring(0,i).trim();\r\n      const value = s.substring(i+1).trim();\r\n      declarations[property] = value;\r\n    });\r\n\r\n    const selectors = StyleSelector.parseMultiple(match[1]);\r\n\r\n    if (selectors.length) {\r\n      out.rules.push({\r\n        type: \"rule\",\r\n        selectors,\r\n        declarations,\r\n      });\r\n    }\r\n\r\n    out.index += match[0].length;\r\n\r\n    ruleText = ruleText.substring(match[0].length);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * \r\n * @param {(StyleRule|MediaQuery)[]} rules \r\n * @param {object} context \r\n */\r\nexport function expandRules (rules, context) {\r\n  const out = [];\r\n  for (const rule of rules) {\r\n    if (rule.type === \"rule\") {\r\n      const { declarations } = rule;\r\n      for (const selector of rule.selectors) {\r\n        out.push({ selector, declarations });\r\n      }\r\n    } else {\r\n      if (testPredicate(rule.predicate, context)) {\r\n        out.push(...expandRules(rule.rules, context));\r\n      }\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction makePredicate(match) {\r\n  let predicate;\r\n\r\n  if (match[4]) {\r\n    // MediaQueries4 syntax:\r\n    //  @match (10 < zoom <= 14)\r\n    predicate = {\r\n      left: { left: match[1], operator: match[2], right: match[3] },\r\n      operator: \"and\",\r\n      right: { left: match[3], operator: match[4], right: match[5] },\r\n    };\r\n  }\r\n  else {\r\n    // MediaQueries4 syntax:\r\n    //  @match (zoom <= 14)\r\n    // MediaQueries3 syntax:\r\n    //  @match (max-zoom: 14) [TODO - it's parsed just not handled correctly]\r\n    predicate = {\r\n      left: match[1],\r\n      operator: match[2],\r\n      right: match[3],\r\n    };\r\n  }\r\n  return predicate;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Predicate} predicate \r\n * @param {object} [context] \r\n * @returns {boolean}\r\n */\r\nexport function testPredicate (predicate, context={}) {\r\n  let left = typeof predicate.left === \"string\" || typeof predicate.left === \"number\" ? \r\n    predicate.left : testPredicate(predicate.left, context);\r\n  let right = typeof predicate.right === \"string\" || typeof predicate.right === \"number\"  ? \r\n    predicate.right : testPredicate(predicate.right, context);\r\n\r\n  if (typeof left === \"string\" && left in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[left] instanceof Function)\r\n      context[left] = context[left]();\r\n\r\n    left = context[left];\r\n  }\r\n\r\n  if (typeof right === \"string\" && right in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[right] instanceof Function)\r\n      context[right] = context[right]();\r\n\r\n    right = context[right];\r\n  }\r\n    \r\n  const op = COMPARE[predicate.operator];\r\n\r\n  if (!op) return false;\r\n  \r\n  return op(left, right);\r\n}\r\n\r\nconst COMPARE = {\r\n  \":\": (a,b) => a == b,\r\n  \"=\": (a,b) => a == b,\r\n  \">\": (a,b) => a > b,\r\n  \"<\": (a,b) => a < b,\r\n  \">=\": (a,b) => a >= b,\r\n  \"<=\": (a,b) => a <= b,\r\n  \"and\": (a,b) => a && b,\r\n  \"or\": (a,b) => a || b,\r\n}","\r\n/**\r\n * Can the string be considered a valid bbox?\r\n * - Are there four parts?\r\n * - Are they all numberic?\r\n * - Are they in the correct order?\r\n * @param {string} bbox \r\n */\r\nexport function isValid (bbox) {\r\n    const parts = bbox.split(\",\");\r\n    \r\n    if (parts.length !== 4) return false;\r\n  \r\n    if (parts.some(p => isNaN(+p))) return false;\r\n  \r\n    return +parts[0] < +parts[2] && +parts[1] < +parts[3];\r\n}\r\n\r\n/**\r\n * Determines whether or not areaB is entirely contained\r\n * within areaA\r\n * @param {string} areaA \r\n * @param {string} areaB \r\n * @returns {boolean}\r\n */\r\nexport function contains (areaA, areaB) {\r\n    const [Ax1,Ay1,Ax2,Ay2] = areaA.split(\",\");\r\n    const [Bx1,By1,Bx2,By2] = areaB.split(\",\");\r\n\r\n    return (Bx1 >= Ax1 && By1 >= Ay1 && Bx2 <= Ax2 && By2 <= Ay2);\r\n}\r\n\r\n/**\r\n * Compute simple area\r\n * @param {string} bbox \r\n */\r\nexport function getArea (bbox) {\r\n    const parts = bbox.split(\",\");\r\n    return (+parts[2] - +parts[0]) * (+parts[3] - +parts[1]);\r\n}\r\n\r\n/**\r\n * \r\n * @param {[number, number]} centre \r\n * @param {number} scale \r\n * @param {[number, number]} size \r\n */\r\nexport function makeBBox (centre, scale, size) {\r\n    const baseTileSize = 256;\r\n\r\n    const [ lon, lat ] = centre;\r\n    const [ width, height ] = size;\r\n\r\n    const tileCount = Math.pow(2, scale)\r\n    const xSpan = 180 / tileCount;\r\n    const ySpan = 180 / tileCount;\r\n    \r\n    const hTileCount = width / baseTileSize;\r\n    const vTileCount = height / baseTileSize;\r\n\r\n    const dLon = xSpan * hTileCount;\r\n    const dLat = ySpan * vTileCount;\r\n\r\n    return [ lon - dLon, lat - dLat, lon + dLon, lat + dLat ].map(p => p.toFixed(3)).join(\",\");\r\n}","\r\n/**\r\n * \r\n * @param {number} x \r\n * @param {number} y \r\n * @param {number} width \r\n * @param {number} height \r\n * @returns {[number, number][]}\r\n */\r\nexport function rectToPoints(x, y, width, height) {\r\n    /** @type {[number, number][]} */\r\n    return [\r\n        [x, y],\r\n        [x, y + height],\r\n        [x + width, y + height],\r\n        [x + width, y],\r\n    ];\r\n}\r\n\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points \r\n */\r\nexport function getCrossProductArea (points) {\r\n    let sum = 0;\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n        sum += points[i][0] * points[i+1][1] - points[i+1][0] * points[i][1];\r\n    }\r\n    return sum / 2;\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getArea (points) {\r\n    return Math.abs(getCrossProductArea(points));\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isAntiClockwise (points) {\r\n    return getCrossProductArea(points) > 0;\r\n}\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points\r\n */\r\nexport function isConvex (points) {\r\n    const l = points.length;\r\n    if (l < 3) return;\r\n\r\n    let sign = 0;\r\n    for (let i = 1; i < l; i++) {\r\n        const a = points[i-1];\r\n        const b = points[i];\r\n        const c = points[(i+1) % l];\r\n        \r\n        const next = Math.sign((b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]));\r\n\r\n        if (sign === 0) sign = next;\r\n        else if (next !== 0 && sign !== next) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isSelfClosing (points) {\r\n    const f = points[0];\r\n    const l = points[points.length - 1]; \r\n    return f[0] === l[0] && f[1] === l[1];\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getLength (points) {\r\n    let sum = 0;\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n        const dx = points[i][0] - points[i-1][0];\r\n        const dy = points[i][1] - points[i-1][1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    return sum;\r\n}","import { makeBBox } from \"./bbox\";\r\nimport { getArea, rectToPoints, isConvex, isSelfClosing, isAntiClockwise, getLength } from \"./geometry\";\r\nimport { testPredicate } from \"./Style\";\r\n\r\n/**\r\n * @param {HTMLCanvasElement} canvas\r\n */\r\nexport function clearMap (canvas) {\r\n    const { clientWidth, clientHeight } = canvas;\r\n\r\n    const width = clientWidth * devicePixelRatio;\r\n    const height = clientHeight * devicePixelRatio;\r\n\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n}\r\n\r\n/** @typedef {import(\"./Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"./Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {[number,number]} centre\r\n * @param {number} scale\r\n * @param {import(\"./Overpass\").OverpassElement[]} elements\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {import(\"./Style\").StyleRule} rule\r\n * @param {{ zoom: number, current: Position }} context\r\n */\r\nexport function renderMap (centre, scale, elements=[], canvas, rule, context) {\r\n    // Prepare node map\r\n    /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n    const nodeMap = {};\r\n    elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n    // Prepare way map\r\n    /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n    const wayMap = {};\r\n    elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n    \r\n    const ctx = canvas.getContext(\"2d\");\r\n    const { clientWidth, clientHeight } = canvas;\r\n\r\n    const width = clientWidth * devicePixelRatio;\r\n    const height = clientHeight * devicePixelRatio;\r\n\r\n    /** @type {(lon: number, lat: number) => [number, number]} */\r\n    const projection = mercatorProjection(centre, scale, width, height);\r\n\r\n    ctx.save();\r\n    \r\n    // Set up global context options \r\n    if (rule.declarations[\"opacity\"]) \r\n        ctx.globalAlpha = +rule.declarations[\"opacity\"];\r\n\r\n    if (rule.declarations[\"position\"] === \"relative\") {\r\n        const top = parseFloat(rule.declarations[\"top\"]) || 0;\r\n        const left = parseFloat(rule.declarations[\"left\"]) || 0;\r\n\r\n        ctx.translate(left * devicePixelRatio, top * devicePixelRatio);\r\n    }\r\n\r\n    // Special rules first\r\n    if (rule.selector.type === \"map\") {\r\n        const points = rectToPoints(0, 0, width, height);\r\n        renderArea(ctx, rule, points);\r\n    }\r\n    else if (rule.selector.type === \"current\") {\r\n        if (context.current) {\r\n            const { coords } = context.current;\r\n            renderPoint(ctx, rule, projection(coords.longitude, coords.latitude));\r\n        }\r\n    } else if (rule.selector.type === \"gridlines\") {\r\n        renderGridlines(ctx, rule, centre, scale, width, height, projection);\r\n    } else {\r\n\r\n        // Then iterate all elements\r\n        for (const el of elements) {\r\n            if (el.type !== rule.selector.type) continue;\r\n\r\n            if (el.type === \"node\") {\r\n                renderPoint(ctx, rule, projection(el.lon, el.lat), el);\r\n            }\r\n            else if (el.type === \"way\") {\r\n                if (!el.nodes) continue;\r\n\r\n                /** @type {import(\"./Overpass\").OverpassNodeElement[]} */\r\n                const nodes = el.nodes.map(id => nodeMap[id]);\r\n                const points = nodes.map(n => projection(n.lon, n.lat));\r\n\r\n                // Check if pseudo-classes match\r\n                if (rule.selector.pseudoClasses.some(c => c.name === \"is\" && c.params[0] === \"convex\")) {\r\n                    if (!isConvex(points)) continue;\r\n                }\r\n                else if (rule.selector.pseudoClasses.some(c => c.name === \"is\" && c.params[0] === \"concave\")) {\r\n                    if (isConvex(points)) continue;\r\n                }\r\n                \r\n                if (rule.selector.pseudoClasses.some(c => c.name === \"is\" && c.params[0] === \"clockwise\")) {\r\n                    if (isAntiClockwise(points)) continue;\r\n                }\r\n                else if (rule.selector.pseudoClasses.some(c => c.name === \"is\" && c.params[0] === \"anti-clockwise\")) {\r\n                    if (!isAntiClockwise(points)) continue;\r\n                }\r\n                \r\n                const hasPseudoClasses = rule.selector.pseudoClasses.filter(c => c.name === \"has\")\r\n                let match = true;\r\n                for (const pc of hasPseudoClasses) {\r\n                    if (typeof pc.params[0] === \"string\") continue;\r\n\r\n                    const predicate = pc.params[0];\r\n\r\n                    // Functions for lazy evaluation\r\n                    const context = {\r\n                        area: () => getArea(points),\r\n                        length: () => getLength(points),\r\n                        width: () => getBoundingBox(points)[2],\r\n                        height: () => getBoundingBox(points)[3],\r\n                    };\r\n\r\n                    match = testPredicate(predicate, context);\r\n                    \r\n                    // Break from other pseudo classes\r\n                    if (!match) break;\r\n                }\r\n                // Continue to other elements\r\n                if (!match) continue;\r\n\r\n                if (rule.selector.pseudoElement === \"centre\" || rule.selector.pseudoElement === \"center\") {\r\n                    // Centre of bounding box\r\n                    const midPoint = getMidPoint(points);\r\n                    renderPoint(ctx, rule, midPoint, el);\r\n                }\r\n                else if (rule.selector.pseudoElement === \"average-point\") {\r\n                    // Average of all points\r\n                    const avgPoint = getAveragePoint(points);\r\n                    renderPoint(ctx, rule, avgPoint, el);\r\n                } \r\n                else if (rule.selector.pseudoElement === \"centre-of-mass\") {\r\n                    // TODO: calculate centre-of-mass\r\n                    // const avgPoint = getCOMPoint(points);\r\n                    // renderPoint(ctx, rule, avgPoint, el);\r\n                }\r\n                else if (rule.selector.pseudoElement === \"bounding-box\") {\r\n                    const bounding = getBoundingBox(points);\r\n\r\n                    const boundingPoints = rectToPoints(...bounding);\r\n\r\n                    renderArea(ctx, rule, boundingPoints, el);\r\n                } \r\n                else {\r\n                    renderLine(ctx, rule, points, el);\r\n                }\r\n            }\r\n            else if (el.type === \"area\") {\r\n                if (!el.nodes) continue;\r\n\r\n                /** @type {import(\"./Overpass\").OverpassNodeElement[]} */\r\n                const nodes = el.nodes.map(id => nodeMap[id]);\r\n                const points = nodes.map(n => projection(n.lon, n.lat));\r\n                \r\n                renderArea(ctx, rule, points, el);\r\n            }\r\n            else if (el.type === \"relation\") {\r\n                if (!el.members) continue;\r\n\r\n                ctx.fillStyle = rule.declarations[\"fill\"];\r\n                ctx.strokeStyle = rule.declarations[\"stroke\"];\r\n                ctx.lineWidth = +rule.declarations[\"stroke-width\"] * devicePixelRatio;\r\n\r\n                // As long as outer ways go anti-clockwise and inner rings go clockwise\r\n                // (or possibly vice-versa) then the CanvasRenderingContext2D can handle\r\n                // rending \"holes\".\r\n\r\n                ctx.beginPath();\r\n\r\n                const ways = el.members.filter(m => m.type === \"way\").map(m => wayMap[m.ref]);\r\n\r\n                for (const way of ways) {\r\n                    const nodes = way.nodes.map(id => nodeMap[id]);\r\n\r\n                    ctx.moveTo(...projection(nodes[0].lon, nodes[0].lat));\r\n                    for (let i = 1; i < nodes.length; i++) {\r\n                        ctx.lineTo(...projection(nodes[i].lon, nodes[i].lat));\r\n                    }\r\n                }\r\n                ctx.closePath();\r\n\r\n                rule.declarations[\"fill\"] && ctx.fill();\r\n                rule.declarations[\"stroke\"] && ctx.stroke();\r\n            }\r\n        }\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\nfunction renderGridlines(ctx, rule, centre, scale, width, height, projection) {\r\n    ctx.fillStyle = rule.declarations[\"fill\"];\r\n    ctx.strokeStyle = rule.declarations[\"stroke\"];\r\n    ctx.lineWidth = +rule.declarations[\"stroke-width\"] * devicePixelRatio;\r\n\r\n    const vertical = rule.selector.pseudoClasses.find(p => p.name === \"vertical\");\r\n    const horizontal = rule.selector.pseudoClasses.find(p => p.name === \"horizontal\");\r\n\r\n    if (vertical) {\r\n        const bbox = makeBBox(centre, scale, [width, height]);\r\n        const parts = bbox.split(\",\");\r\n\r\n        const step = parseFloat(vertical.params[0]);\r\n\r\n        const round = 1 / step;\r\n\r\n        const xmin = Math.floor(+parts[0] * round) / round;\r\n        const xmax = Math.ceil(+parts[2] * round) / round;\r\n        const ymin = Math.floor(+parts[1] * round) / round;\r\n        const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n        ctx.beginPath();\r\n        for (let i = xmin; i <= xmax; i += step) {\r\n            ctx.moveTo(...projection(i, ymin));\r\n            for (let j = ymin; j <= ymax; j += step) {\r\n                ctx.lineTo(...projection(i, j));\r\n            }\r\n        }\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    if (horizontal) {\r\n        const bbox = makeBBox(centre, scale, [width, height]);\r\n        const parts = bbox.split(\",\");\r\n\r\n        const step = parseFloat(horizontal.params[0]);\r\n\r\n        const round = 1 / step;\r\n\r\n        const xmin = Math.floor(+parts[0] * round) / round;\r\n        const xmax = Math.ceil(+parts[2] * round) / round;\r\n        const ymin = Math.floor(+parts[1] * round) / round;\r\n        const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n        ctx.beginPath();\r\n        for (let j = ymin; j <= ymax; j += step) {\r\n            ctx.moveTo(...projection(xmin, j));\r\n            for (let i = xmin; i <= xmax; i += step) {\r\n                ctx.lineTo(...projection(i, j));\r\n            }\r\n        }\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} position\r\n * @param {OverpassElement} element\r\n */\r\nfunction renderPoint(ctx, rule, [x, y], element=null) {\r\n    ctx.fillStyle = rule.declarations[\"fill\"];\r\n    ctx.strokeStyle = rule.declarations[\"stroke\"];\r\n    ctx.lineWidth = +rule.declarations[\"stroke-width\"] * devicePixelRatio;\r\n    \r\n    ctx.beginPath();\r\n\r\n    const r = +rule.declarations[\"size\"] * devicePixelRatio;\r\n\r\n    ctx.ellipse(x, y, r, r, 0, 0, Math.PI * 2);\r\n\r\n    rule.declarations[\"fill\"] && ctx.fill();\r\n    rule.declarations[\"stroke\"] && ctx.stroke();\r\n\r\n    if (rule.declarations[\"content\"]) {\r\n        renderText(ctx, rule, [x, y], element);\r\n    }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {OverpassElement} element\r\n */\r\nfunction renderLine(ctx, rule, points, element=null) {\r\n    \r\n    ctx.fillStyle = rule.declarations[\"fill\"];\r\n    ctx.strokeStyle = rule.declarations[\"stroke\"];\r\n    ctx.lineWidth = +rule.declarations[\"stroke-width\"] * devicePixelRatio;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(...points[0]);\r\n    for (let i = 1; i < points.length; i++) {\r\n        ctx.lineTo(...points[i]);\r\n    }\r\n\r\n    rule.declarations[\"fill\"] && ctx.fill();\r\n    rule.declarations[\"stroke\"] && ctx.stroke();\r\n\r\n    // Text Handling \r\n    if (rule.declarations[\"content\"]) {\r\n        // find mid-point (and average gradient?)\r\n        const point = getMidPoint(points);\r\n        renderText(ctx, rule, point, element);\r\n    }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {OverpassElement} element\r\n */\r\nfunction renderArea(ctx, rule, points, element=null) {\r\n    if (points.length === 0) return;\r\n    const p = isSelfClosing(points) ? points : [...points, points[0]];\r\n    renderLine(ctx, rule, p, element);\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} param2\r\n * @param {OverpassElement} [element]\r\n */\r\nfunction renderText(ctx, rule, [x, y], element=null) {\r\n    ctx.fillStyle = rule.declarations[\"fill\"];\r\n    ctx.strokeStyle = rule.declarations[\"stroke\"];\r\n    ctx.lineWidth = +rule.declarations[\"stroke-width\"] * devicePixelRatio;\r\n\r\n    let content = rule.declarations[\"content\"];\r\n\r\n    if (content.match(/^\".*\"$/g)) {\r\n        content = content.replace(/^\"|\"$/g, \"\");\r\n    }\r\n    else if (content.match(/tag\\(([^)]+)\\)/)) {\r\n        const m = content.match(/tag\\(([^)]+)\\)/);\r\n        content = element.tags[m[1]] || \"\";\r\n    }\r\n    else {\r\n        content = \"?\";\r\n    }\r\n\r\n    let fontSize = `${10 * devicePixelRatio}px`;\r\n    let fontWeight = \"normal\";\r\n    let fontFamily = \"sans-serif\";\r\n\r\n    if (rule.declarations[\"font-size\"]) {\r\n        fontSize = rule.declarations[\"font-size\"].replace(/^\\d[\\d.]*/, m => `${+m * devicePixelRatio}`);\r\n    }\r\n\r\n    if (rule.declarations[\"font-weight\"]) {\r\n        fontWeight = rule.declarations[\"font-weight\"];\r\n    }\r\n\r\n    if (rule.declarations[\"font-family\"]) {\r\n        fontFamily = rule.declarations[\"font-family\"];\r\n    }\r\n\r\n    ctx.font = rule.declarations[\"font\"] || `${fontWeight} ${fontSize} ${fontFamily}`;\r\n\r\n    if (rule.declarations[\"text-align\"]) {\r\n        const textWidth = ctx.measureText(content).width;\r\n\r\n        if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n            x -= textWidth / 2;\r\n        } else if (rule.declarations[\"text-align\"] === \"right\") {\r\n            x -= textWidth;\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"text-color\"]) {\r\n        ctx.fillStyle = rule.declarations[\"text-color\"];\r\n        ctx.fillText(content, x, y);\r\n    }\r\n    else {\r\n        if (rule.declarations[\"stroke\"])\r\n            ctx.strokeText(content, x, y);\r\n        if (rule.declarations[\"fill\"] || !rule.declarations[\"stroke\"])\r\n            ctx.fillText(content, x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n * @param {number} minLon\r\n * @param {number} minLat\r\n * @param {number} maxLon\r\n * @param {number} maxLat\r\n * @param {number} width\r\n * @param {number} height\r\n */\r\nfunction flatProjection (minLon, minLat, maxLon, maxLat, width, height) {\r\n    const xScale = width / (maxLon - minLon);\r\n    const yScale = height / (maxLat - minLat);\r\n    const scale = Math.max(xScale, yScale);\r\n    return ((lon, lat) => [(lon - minLon) * scale, height - (lat - minLat) * scale]);\r\n}\r\n\r\n/**\r\n * @param {[number, number]} centre\r\n * @param {number} scale\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {(lon: number, lat: number) => [number, number]} \r\n */\r\nfunction mercatorProjection (centre, scale, width, height) {\r\n    const baseTileSize = 256;\r\n\r\n    const [ cLon, cLat ] = centre;\r\n\r\n    const tileCount = Math.pow(2, scale)\r\n    const degPerTileH = 180 / tileCount;\r\n    const degPerTileV = 180 / tileCount;  \r\n\r\n    const hPixelsPerDeg = baseTileSize / degPerTileH;\r\n    const vPixelsPerDeg = baseTileSize / degPerTileV;\r\n\r\n    const QUARTER_PI = Math.PI / 4;\r\n\r\n    const cX = width / 2;\r\n    const cY = height / 2;\r\n\r\n    const cLatPrime = Math.log(Math.tan(QUARTER_PI + (cLat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n    return (lon, lat) => {\r\n        const E = lon;\r\n        const N = Math.log(Math.tan(QUARTER_PI + (lat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n        const dLon = E - cLon;\r\n        const dLat = N - cLatPrime;\r\n\r\n        const dX = dLon * hPixelsPerDeg;\r\n        const dY = dLat * vPixelsPerDeg;\r\n\r\n        return [cX + dX, cY - dY];\r\n    }\r\n}\r\n\r\n/**\r\n * \r\n * @param {[number, number][]} points \r\n */\r\nfunction getAveragePoint (points) {\r\n    const sum = points.reduce((sum, p) => [sum[0] + p[0], sum[1] + p[1]], [0, 0]);\r\n    /** @type {[number, number]} */\r\n    const avg = (sum.map(x => x / points.length));\r\n    return avg;\r\n}\r\n\r\n/**\r\n * \r\n * @param {[number, number][]} points \r\n * @returns {[number, number]}\r\n */\r\nfunction getMidPoint (points) {\r\n    const boundingBox = getBoundingBox(points);\r\n\r\n    return [\r\n        boundingBox[0] + boundingBox[2] / 2,\r\n        boundingBox[1] + boundingBox[3] / 2,\r\n    ];\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n * @returns {[number, number, number, number]} (x, y, width, height)\r\n */\r\nfunction getBoundingBox (points) {\r\n    const minMax = points.reduce((minMax, point) => {\r\n        return [\r\n            Math.min(minMax[0], point[0]),\r\n            Math.min(minMax[1], point[1]),\r\n            Math.max(minMax[2], point[0]),\r\n            Math.max(minMax[3], point[1]),\r\n        ]\r\n    }, [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]);\r\n\r\n    return [\r\n        minMax[0],\r\n        minMax[1],\r\n        minMax[2] - minMax[0],\r\n        minMax[3] - minMax[1],\r\n    ];\r\n}\r\n","import { contains, getArea } from \"./bbox\";\r\n\r\nexport default class IDBElementDatabase {\r\n    constructor (name=\"OverpassElements\") {\r\n        const request = indexedDB.open(name);\r\n\r\n        request.addEventListener(\"upgradeneeded\", ev => {\r\n            /** @type {IDBOpenDBRequest} */\r\n            const request = (ev.target);\r\n            const db = request.result;\r\n            db.createObjectStore(\"nodes\", { keyPath: \"id\" });\r\n\r\n            const store = db.createObjectStore(\"elements\");\r\n            store.createIndex(\"selectorIndex\", [\"selector\", \"area\", \"bbox\"], { unique: false });\r\n        });\r\n\r\n        /** @type {Promise<IDBDatabase>} */\r\n        this.db = new Promise((resolve, reject) => {\r\n            request.addEventListener(\"success\", ev => {\r\n                /** @type {IDBOpenDBRequest} */\r\n                const request = (ev.target);\r\n                resolve(request.result);\r\n            });\r\n\r\n            request.addEventListener(\"error\", reject);\r\n        })\r\n\r\n    }\r\n\r\n    async saveNodes (nodes) {\r\n        const db = await this.db;\r\n        const store = db.transaction(\"nodes\", \"readwrite\").objectStore(\"nodes\");\r\n        for (const n of nodes) {\r\n            store.put(n);\r\n        }\r\n    }\r\n\r\n    async getNode (id) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const store = db.transaction(\"nodes\", \"readonly\").objectStore(\"nodes\");\r\n            const request = store.get(id);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", e => reject(e));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number[]} ids \r\n     */\r\n    getNodes (ids) {\r\n        return Promise.all(ids.map(id => this.getNode(id)));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} bbox \r\n     * @param {string} selector \r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    getElements (bbox, selector) {\r\n        const key = makeKey(bbox, selector);\r\n        return this.getElementsByKey(key);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} key \r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    async getElementsByKey (key) {\r\n        const db = await this.db;\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const request = objectStore.get(key);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} bbox \r\n     * @param {string} selector \r\n     * @returns {Promise<string>}\r\n     */\r\n    async searchElements (bbox, selector) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const index = objectStore.index(\"selectorIndex\");\r\n            const range = IDBKeyRange.bound([selector,0,\"0\"], [selector,Number.MAX_VALUE,\"999999999999999999\"]);\r\n            const request = index.openKeyCursor(range);\r\n            let count = 0;\r\n            request.addEventListener(\"success\", e => {\r\n                const cursor = request.result;\r\n                \r\n                if (cursor) {\r\n                    const { key, primaryKey } = cursor;\r\n                    const keyBBox = key[2];\r\n                    count++;\r\n                    if (contains(keyBBox, bbox)) {\r\n                        console.debug(`${selector} found after checking ${count} records`);\r\n                        resolve(primaryKey);\r\n                        return;\r\n                    }\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    console.debug(`${selector} not found after checking ${count} records`);\r\n                    resolve(null);\r\n                }\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} bbox \r\n     * @param {string} selector \r\n     * @param {{ elements: import(\"./Overpass\").OverpassElement[], cached: number }} record \r\n     */\r\n    async saveElements (bbox, selector, record) {\r\n        const db = await this.db;\r\n        const key = makeKey(bbox, selector);\r\n        const area = getArea(bbox);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readwrite\").objectStore(\"elements\");\r\n            const request = objectStore.put({ selector, bbox, area, ...record }, key);\r\n            request.addEventListener(\"success\", () => {\r\n                console.debug(`Saved ${selector}/${bbox} to database with ${record.elements.length} elements`);\r\n                resolve();\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n}\r\n\r\nfunction makeKey (bbox, selector) {\r\n    const bkey = bbox.split(\",\").map(p => (+p).toFixed(3)).join(\",\");\r\n    return `${selector}/${bkey}`;\r\n}\r\n","import IDBElementDatabase from \"./database.idb\";\r\nimport { contains } from \"./bbox\";\r\nimport { matchSelector } from \"./Style\";\r\n\r\n/** @typedef {import(\"./Style\").StyleSelector} StyleSelector */\r\n\r\nconst API_ROOT = require(\"./const\").API_ROOT;\r\n\r\nconst overpassRe = /(node|way|rel(?:ation)?|area)/;\r\nconst recurRe = /(way|rel(?:ation)?|area)/;\r\n\r\nexport class Overpass {\r\n    constructor (bbox) {\r\n        /** @type {Map<string, Promise<OverpassElement[]>>} */\r\n        this.elements = new Map();\r\n        this.bbox = bbox;\r\n        this.database = new IDBElementDatabase();\r\n    }\r\n\r\n    setBBox (bbox) {\r\n        // If the new bbox is completely contained within the\r\n        // old one then we don't need to clear our cache\r\n        if (!contains(this.bbox, bbox)) {\r\n            this.elements.clear();\r\n        }\r\n        this.bbox = bbox;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {StyleSelector[]} selectors \r\n     */\r\n    async preLoadElements (selectors) {\r\n        const { bbox } = this;\r\n\r\n        // Create set of selectors\r\n        /** @type {{ [key: string]: StyleSelector }} */\r\n        const set = {};\r\n        selectors.forEach(s => set[s.toString()] = s);\r\n\r\n        console.debug(`Preloading Elements: ${selectors.length} requested (${Object.keys(set).length} unique)`);\r\n\r\n        // Remove non-overpass selectors\r\n        for (const [key, selector] of Object.entries(set)) {\r\n            if (!overpassRe.test(selector.type)) delete set[key];\r\n        }\r\n        console.debug(`Preloading Elements: ${Object.keys(set).length} are Overpass Elements`); \r\n\r\n        // Remove selectors in local hash map cache\r\n        for (const key of Object.keys(set)) {\r\n            if (this.elements.has(key)) delete set[key];\r\n        }\r\n        console.debug(`Preloading Elements: ${Object.keys(set).length} not in HashMap`); \r\n        \r\n        // Remove selectors in database\r\n        await Promise.all(Object.keys(set).map(s => {\r\n            return this.database.searchElements(bbox, s)\r\n                .then(els => {\r\n                    if (els) delete set[s];\r\n                });\r\n        }));\r\n        console.debug(`Preloading Elements: ${Object.keys(set).length} not in Database`);\r\n\r\n        if (Object.keys(set).length === 0) return;\r\n\r\n        const { elements } = await this.query(Object.values(set));\r\n\r\n        console.log(`Preloading Elements: Fetched ${elements.length} elements from Server`);\r\n\r\n        // Prepare node map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n        const nodeMap = {};\r\n        elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n        // Prepare way map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n        const wayMap = {};\r\n        elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n        return Promise.all(Object.values(set).map(selector => {\r\n            const out = elements.filter(el => matchSelector(selector, el));\r\n\r\n            if (selector.type === \"relation\") {\r\n                /** @type {OverpassRelElement[]} */\r\n                const rels = (out.slice());\r\n\r\n                /** @type {OverpassWayElement[]} */\r\n                const ways = [];\r\n\r\n                for (const rel of rels) {\r\n                    const refs = rel.members.map(m => m.ref);\r\n                    ways.push(...refs.map(id => wayMap[id]));\r\n                }\r\n\r\n                out.push(...ways);\r\n\r\n                for (const way of ways) {\r\n                    out.push(...way.nodes.map(id => nodeMap[id]));\r\n                }\r\n\r\n            } else if (selector.type === \"way\") {\r\n                /** @type {OverpassWayElement[]} */\r\n                const ways = (out.slice());\r\n\r\n                for (const way of ways) {\r\n                    out.push(...way.nodes.map(id => nodeMap[id]));\r\n                }\r\n            }\r\n\r\n            this.elements.set(selector.toString(), Promise.resolve(out));\r\n            return this.database.saveElements(bbox, selector.toString(), { elements: out, cached: Date.now() });\r\n        }));\r\n        }\r\n\r\n    /**\r\n     * \r\n     * @param {StyleSelector[]} selectors \r\n     * @returns {Promise<{ elements: OverpassElement[] }>}\r\n     */\r\n    query (selectors) {\r\n        const sMap = selectors.map(s => recurRe.test(s.type) ? `\\n\\t${s};\\n\\t>;` : s.toString() + \";\");\r\n        const query = `[out:json][bbox];\\n(${sMap.join(\"\")}\\n);\\nout;`\r\n        const url = `${API_ROOT}?data=${query.replace(/\\s/,\"\")}&bbox=${this.bbox}`;\r\n\r\n        if (this.currentFetch && this.currentFetch.url === url) return this.currentFetch.promise;\r\n\r\n        this.currentFetch = {\r\n            url,\r\n            promise: fetch(url.toString()).then(r => r.ok ? r.json() : () => {\r\n                this.currentFetch = null;\r\n                return Promise.reject(r.status);\r\n            }),\r\n        };\r\n\r\n        return this.currentFetch.promise;\r\n    }\r\n\r\n    tryElements (selector, tries=10) {\r\n        return new Promise ((resolve, reject) => {\r\n            this.query([selector]).then(d => {\r\n                resolve(d.elements);\r\n            }, e => {\r\n                if (e !== 429) reject(\"Bad Response\");\r\n                else if (tries > 0) {\r\n                    setTimeout(() => {\r\n                        this.tryElements(selector, tries - 1).then(resolve, reject);\r\n                    }, 10000);\r\n                }\r\n                else reject(e);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {import(\"./Style\").StyleSelector} selector\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    async getElements (selector) {\r\n        if (!overpassRe.test(selector.type)) return;\r\n\r\n        const s = selector.toString();\r\n        if (this.elements.has(s)) return this.elements.get(s);\r\n\r\n        const dbResult = await this.database.getElements(this.bbox, selector.toString());\r\n\r\n        if (dbResult) {\r\n            const { elements } = dbResult;\r\n            this.elements.set(s, Promise.resolve(elements));\r\n            return elements;\r\n        }\r\n\r\n        const dbSearchResult = await this.database.searchElements(this.bbox, selector.toString());\r\n\r\n        if (dbSearchResult) {\r\n            const elements = this.database.getElementsByKey(dbSearchResult).then(r => r.elements);\r\n            this.elements.set(s, elements);\r\n            return elements;\r\n        }\r\n\r\n        const p = this.tryElements(selector);\r\n        \r\n        this.elements.set(s, p);\r\n        \r\n        p.catch(() => this.elements.delete(s));\r\n\r\n        p.then(elements => {\r\n            this.database.saveElements(this.bbox, selector.toString(), { elements, cached: Date.now() });\r\n        });\r\n\r\n        return p;\r\n    }\r\n}\r\n\r\n/** @typedef {import('./Style.js').StyleRule} StyleRule */\r\n\r\n/**\r\n * @typedef {OverpassNodeElement|OverpassWayElement|OverpassAreaElement|OverpassRelElement} OverpassElement\r\n */\r\n\r\n/**\r\n * @typedef OverpassNodeElement\r\n * @property {number} id\r\n * @property {\"node\"} type\r\n * @property {number} lon\r\n * @property {number} lat\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassWayElement\r\n * @property {number} id\r\n * @property {\"way\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassAreaElement\r\n * @property {number} id\r\n * @property {\"area\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassRelElement\r\n * @property {number} id\r\n * @property {\"relation\"} type\r\n * @property {{ ref: number, role: \"inner\"|\"outer\", type: \"node\"|\"way\"|\"relation\" }[]} members\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n","import { useState, useEffect } from 'react';\r\n\r\n/**\r\n * @link https://usehooks.com/useDebounce/\r\n * @param {any} value \r\n * @param {number} delay \r\n */\r\nexport function useDebounce(value, delay) {\r\n    // State and setters for debounced value\r\n    const [debouncedValue, setDebouncedValue] = useState(value);\r\n  \r\n    useEffect(\r\n      () => {\r\n        // Update debounced value after delay\r\n        const handler = setTimeout(() => {\r\n          setDebouncedValue(value);\r\n        }, delay);\r\n  \r\n        // Cancel the timeout if value changes (also on delay change or unmount)\r\n        // This is how we prevent debounced value from updating if value is changed ...\r\n        // .. within the delay period. Timeout gets cleared and restarted.\r\n        return () => {\r\n          clearTimeout(handler);\r\n        };\r\n      },\r\n      [value, delay] // Only re-call effect if value or delay changes\r\n    );\r\n  \r\n    return debouncedValue;\r\n  }","import React from 'react';\r\n\r\n/**\r\n * \r\n * @param {{ value: string, onChange: (event) => void, style?: React.CSSProperties}} param0 \r\n */\r\nexport default function Textarea ({ value, onChange, style={} }) {\r\n    /**\r\n     * @param {React.KeyboardEvent<HTMLTextAreaElement>} event\r\n     */\r\n    function handleKeyDown (event) {\r\n        const { key, currentTarget } = event;\r\n    \r\n        if (key === \"Tab\") {\r\n            event.preventDefault();\r\n    \r\n            const i = currentTarget.selectionStart;\r\n            const lineStart = value.lastIndexOf(\"\\n\", i-1) + 1;\r\n            const linePos = i - lineStart;\r\n            const x = 4 - linePos % 4;\r\n\r\n            const newValue = value.substring(0,i) + \"    \".substring(0,x) + value.substring(i);\r\n            onChange(newValue);\r\n\r\n            setTimeout(() => currentTarget.setSelectionRange(i + x, i + x), 10);\r\n        }\r\n    \r\n        else if (key === \"Enter\") {\r\n            event.preventDefault();\r\n\r\n            const i = currentTarget.selectionStart;\r\n            const addIndent = value[i-1] === \"{\";\r\n            const lineStart = value.lastIndexOf(\"\\n\", i-1) + 1;\r\n            const match = value.substring(lineStart, i).match(/^ */);\r\n            const newPos = i + match[0].length + 1 + (addIndent ? 4 : 0);\r\n\r\n            const newValue = value.substring(0,i) + \"\\n\" + (addIndent ? \"    \" : \"\") + match[0] + value.substring(i);\r\n            onChange(newValue);\r\n\r\n            setTimeout(() => currentTarget.setSelectionRange(newPos, newPos), 10);\r\n        }\r\n    }\r\n\r\n    return <textarea value={value} onChange={e => onChange(e.target.value)} onKeyDown={handleKeyDown} style={style} />;\r\n}","import React from 'react';\nimport './App.css';\nimport useSavedState from './useSavedState';\nimport { parseStyle, expandRules } from './Style';\nimport { renderMap, clearMap } from './render';\nimport { Overpass } from './Overpass';\nimport { useDebounce } from './useDebounce';\nimport { makeBBox } from './bbox';\nimport useGeolocation from './useGeolocation';\nimport Textarea from './Textarea';\nimport useDeepCompareEffect from 'use-deep-compare-effect';\n\nfunction App() {\n  const [ style, setStyle ] = useSavedState(\"USER_STYLE\", \"node[amenity=post_box] {\\n\\tfill: black;\\n\\tsize: 2;\\n}\");\n  const [ centre, setCentre ] = useSavedState(\"USER_CENTRE\", \"7.1,50.7\");\n  const [ scale, setScale ] = useSavedState(\"USER_SCALE\", 14);\n  const current = useGeolocation();\n  /** @type {React.MutableRefObject<HTMLCanvasElement>} */\n  const canvasRef = React.useRef();\n  /** @type {React.MutableRefObject<Overpass>} */\n  const overpassRef = React.useRef();\n  const [ fetching, setFetching ] = React.useState(false);\n  const [ error, setError ] = React.useState(\"\");\n\n  const { clientWidth: width, clientHeight: height } = canvasRef.current || { clientWidth: 1000, clientHeight: 1000 };\n\n  const debouncedCentre = useDebounce(centre, 500);\n  const debouncedScale = useDebounce(scale, 500);\n\n  const bbox = React.useMemo(() => makeBBox(debouncedCentre.split(\",\").map(p => +p), debouncedScale, [width, height]), [debouncedCentre, debouncedScale, width, height]);\n\n  if (!overpassRef.current) {\n    overpassRef.current = new Overpass(bbox);\n  }\n  \n  const debouncedStyle = useDebounce(style, 500);\n  \n  const parsedStyle = React.useMemo(() => parseStyle(debouncedStyle), [debouncedStyle]);\n\n  React.useEffect(() => overpassRef.current.setBBox(bbox), [bbox]);\n  \n  // Refetch/Render map when bbox, or style change\n  useDeepCompareEffect(() => {\n    async function run () {\n      setFetching(true);\n      setError(\"\");\n\n      try {\n        const context = { zoom: debouncedScale, current };\n        const rules = expandRules(parsedStyle.rules, context);\n        await overpassRef.current.preLoadElements(rules.map(r => r.selector));\n        \n        const map = rules.map(rule => {\n          return {\n            rule,\n            promise: overpassRef.current.getElements(rule.selector),\n          }\n        });\n\n        if (canvasRef.current) {\n          clearMap(canvasRef.current);\n\n          /** @type {[number, number]} */\n          const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\n\n          for (const item of map) {\n            const elements = await item.promise;\n            renderMap(centrePoint, debouncedScale, elements, canvasRef.current, item.rule, context);\n          }\n        }\n      } catch (e) {\n        setError(\"Error Fetching\");\n      } finally {\n        setFetching(false);\n      }\n    }\n\n    run();\n  }, [debouncedCentre, debouncedScale, parsedStyle, current]);\n\n  function move (dX, dY) {\n    /** @type {[number, number]} */\n    const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\n    const stepSize = 360 / Math.pow(2, scale);\n    const newCentre = [ centrePoint[0] + dX * stepSize, centrePoint[1] + dY * stepSize ];\n    setCentre(newCentre.join(\",\"));\n  }\n\n  return (\n    <div className=\"App\">\n      <div className=\"sidebar\">\n        <div className=\"controls\">\n          <button onClick={() => move(-1,0)}>⏴</button>\n          <button onClick={() => move(1,0)}>⏵</button>\n          <button onClick={() => move(0,1)}>⏶</button>\n          <button onClick={() => move(0,-1)}>⏷</button>\n          <button onClick={() => setScale(scale + 1)}>➕</button>\n          <button onClick={() => setScale(scale - 1)}>➖</button>\n          { current && <button onClick={() => setCentre(`${current.coords.longitude},${current.coords.latitude}`)}>📍</button> }\n        </div>\n        <label>Centre <input value={centre} onChange={e => setCentre(e.target.value)} /></label>\n        <label>Zoom <input type=\"number\" value={scale} onChange={e => setScale(+e.target.value)} /></label>\n        <Textarea value={style} onChange={setStyle} style={{flex:1}} />\n        { fetching && <p>Loading...</p> }\n        { error && <p style={{color:\"red\"}}>{error}</p> }\n      </div>\n      <canvas ref={canvasRef} />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\r\n\r\nexport default function useGeolocation () {\r\n    /** @type {[Position, (newPos: Position) => void]} */\r\n    const [ loc, setLoc ] = React.useState();\r\n\r\n    React.useEffect(() => { navigator.geolocation.getCurrentPosition(setLoc) }, []);\r\n\r\n    React.useEffect(() => {\r\n        const id = navigator.geolocation.watchPosition(setLoc);\r\n\r\n        return () => navigator.geolocation.clearWatch(id);\r\n    }, []);\r\n\r\n    return loc;\r\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}