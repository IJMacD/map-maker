{"version":3,"sources":["const.js","useSavedState.js","Style.js","util.js","geometry.js","matchPseudoClasses.js","getContent.js","bbox.js","MapRenderer.js","parseStrokeFill.js","canvas-render/setStrokeFill.js","canvas-render/renderText.js","canvas-render/transform.js","canvas-render/renderPoint.js","CollisionSystem.js","canvas-render/renderAreaLine.js","canvas-render/index.js","render-worker.js","WorkerRenderer.js","svg-render/renderAreaLine.js","svg-render/index.js","database.idb.js","Overpass.js","useDebounce.js","Textarea.js","App.js","useGeolocation.js","serviceWorker.js","index.js"],"names":["API_ROOT","useSavedState","key","initalState","React","useState","saved","localStorage","getItem","JSON","parse","e","state","setState","newState","setItem","stringify","StyleSelector","type","tags","pseudoClasses","pseudoElement","this","Object","entries","map","k","v","op","test","join","matchSelector","selector","element","inequalities","length","value","m","exec","cmp","COMPARE","substr","res","isNaN","localeCompare","parseMedia","mediaText","match","match2","re","out","mediaQueries","index","re2","predicate","makePredicate","parseRules","substring","rules","push","console","log","ruleText","declarations","split","s","trim","filter","forEach","i","indexOf","property","selectors","parseMultiple","expandRules","context","rule","testPredicate","left","operator","right","Function","text","tagText","m2","re3","m3","params","name","re4","m4","x","a","b","timeout","duration","Promise","resolve","setTimeout","mercatorProjection","centre","scale","width","height","cLon","cLat","tileCount","Math","pow","hPixelsPerDeg","vPixelsPerDeg","QUARTER_PI","PI","cX","cY","cLatPrime","tan","lon","lat","E","N","getAveragePoint","points","reduce","sum","p","getCentrePoint","boundingBox","getBoundingBox","getMidPoint","floor","minMax","point","min","max","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","rectToPoints","y","getCrossProductArea","getArea","abs","isAntiClockwise","isConvex","l","sign","c","next","isSelfClosing","f","getLength","dx","dy","sqrt","matchPseudoClasses","nodes","includesPseudoClass","hasPseudoClasses","pc","elementContext","area","some","getContent","content","replace","toString","contains","areaA","areaB","Ax1","Ay1","Ax2","Ay2","Bx1","By1","Bx2","By2","bbox","parts","makeBBox","zoom","size","dLon","dLat","toFixed","MapRenderer","elements","nodeMap","n","id","wayMap","projection","globalSetup","renderPseudoElement","renderArea","current","coords","renderPoint","longitude","latitude","renderGridlines","el","renderLine","renderAreaLine","getPoint","centrePoint","midPoint","avgPoint","bounding","boundingPoints","bottom","top","NaN","baseline","line","measureText","ascending","descending","padding","parseFloat","boundPoints","decimatedPoints","vertical","find","horizontal","step","round","sigFigs","ceil","log10","xmin","xmax","ymin","ymax","j","parseStrokeFill","lineWidth","lineDash","fillStyle","strokeStyle","mutedStyle","ss","repeat","sm","setStrokeFill","ctx","setLineDash","renderText","setFont","textWidth","strokeText","fillText","actualBoundingBoxAscent","actualBoundingBoxDescent","fontSize","fontWeight","fontFamily","font","applyTransform","r","t","trans","unit","transform","rotate","translate","valueY","save","beginPath","ellipse","fill","stroke","drawPath","urlRe","url","img","Image","src","w","h","addEventListener","drawImage","restore","pathSpec","first","prev","segs","x2","y2","x3","y3","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","CollisionSystem","sets","set","box","intersects","singleton","boxA","boxB","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","scaleFactor","collisionSystem","getCollisionSystem","add","policy","offsetX","offsetY","cp","CanvasRender","canvas","getContext","globalAlpha","Worker","WorkerRenderer","transferControlToOffscreen","worker","RenderWorker","postMessage","method","_elements","layer","path","d","SVGRender","layers","currentLayer","colours","layerSetup","getTextParts","Blob","attr","attributes","opacity","IDBElementDatabase","request","indexedDB","open","ev","db","target","result","createObjectStore","keyPath","createIndex","unique","reject","store","transaction","objectStore","put","get","ids","all","getNode","makeKey","getElementsByKey","range","IDBKeyRange","bound","MAX_VALUE","openKeyCursor","count","bboxOversizeArea","cursor","primaryKey","keyBBox","keyArea","debug","continue","record","req","clear","onsuccess","onerror","bkey","require","overpassRe","recurRe","Overpass","Map","database","fetchMap","currentJob","jobs","Error","mapSelector","keys","has","searchElements","then","els","tryQuery","values","rels","slice","ways","refs","members","ref","way","saveElements","cached","Date","now","sMap","mapSelectorForQuery","query","clamp","clampBBox","fetch","ok","json","status","finally","tries","catch","getElements","dbResult","dbSearchResult","delete","fn","recur","useDebounce","delay","debouncedValue","setDebouncedValue","useEffect","handler","clearTimeout","Textarea","onChange","otherProps","onKeyDown","event","currentTarget","shiftKey","preventDefault","selectionStart","lineStart","lastIndexOf","newValue","setSelectionRange","addIndent","newPos","App","style","setStyle","setCentre","setZoom","loc","setLoc","navigator","geolocation","getCurrentPosition","watchPosition","clearWatch","useGeolocation","canvasRef","useRef","overpassRef","setStatus","error","setError","downloading","setDownloading","progress","setProgress","rendererRef","shellContextRef","executables","clearCache","counter","setCounter","useForceRender","renderPending","forceRender","render","window","location","reload","removeItem","consoleVisible","showConsole","clientWidth","clientHeight","devicePixelRatio","debouncedCentre","debouncedZoom","useMemo","debouncedStyle","parsedStyle","styleText","rulesResult","mediaResult","parseStyle","setBBox","callback","ctrlKey","altKey","document","removeEventListener","move","dX","dY","bb","stepSizeX","stepSizeY","newCentre","cleanupPoint","handleDownload","cb","toBlob","blob","blobDownload","downloadPNG","downloadSVG","WorkerRender","useDeepCompareEffect","currentEffect","className","onClick","cleanup","disabled","flex","spellCheck","color","maxHeight","onDoubleClick","nativeEvent","from","to","fx","fy","tw","th","interpolateBox","parseBBox","dz","overpass","promise","svgRender","item","renderRule","filename","URL","createObjectURL","createElement","download","href","body","appendChild","click","removeChild","revokeObjectURL","renderer","preLoadElements","prefix","Boolean","hostname","ReactDOM","StrictMode","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.0544f4ba.chunk.js","sourcesContent":["\r\nexport const API_ROOT = \"https://overpass-api.de/api/interpreter\";","import React from 'react';\r\n\r\n/**\r\n * @template T\r\n * @param {string} key \r\n * @param {T} initalState \r\n * @returns {[ T, (newState: T) => void ]}\r\n */\r\nexport default function useSavedState (key, initalState) {\r\n    const [ state, setState ] = React.useState(() => {\r\n        const saved = localStorage.getItem(key);\r\n    \r\n        if (saved) {\r\n            try {\r\n                initalState = JSON.parse(saved);\r\n            } catch (e) {}\r\n        }\r\n\r\n        return initalState;\r\n    });\r\n\r\n    return [\r\n        state,\r\n        newState => {\r\n            localStorage.setItem(key, JSON.stringify(newState));\r\n            setState(newState);\r\n        }\r\n    ]\r\n}","/**\r\n * @typedef StyleRule\r\n * @property {\"rule\"} type\r\n * @property {StyleSelector} [selector]\r\n * @property {StyleSelector[]} [selectors]\r\n * @property {{ [key: string]: string }} declarations\r\n */\r\n\r\n/**\r\n * @typedef MediaQuery\r\n * @property {\"query\"} type\r\n * @property {Predicate} predicate\r\n * @property {StyleRule[]} rules\r\n */\r\n\r\n/**\r\n * @typedef Predicate\r\n * @property {string|number|Predicate} left\r\n * @property {string} operator\r\n * @property {string|number|Predicate} right\r\n */\r\n\r\nexport class StyleSelector {\r\n    /**\r\n     * @param {string} type\r\n     * @param {{ [key: string]: string }} tags\r\n     * @param {{ name: string, params: (string|Predicate)[] }[]} pseudoClasses\r\n     * @param {string} [pseudoElement]\r\n     */\r\n    constructor (type, tags, pseudoClasses=[], pseudoElement=null) {\r\n      this.type = type;\r\n      this.tags = tags;\r\n      this.pseudoClasses = pseudoClasses;\r\n      this.pseudoElement = pseudoElement;\r\n    }\r\n\r\n    toString () {\r\n      return `${this.type}${Object.entries(this.tags).map(([k,v]) => {\r\n        const op = /^[<=>]/.test(v) ? \"\" : \"=\";\r\n        return `[${k}${op}${v}]`;\r\n      }).join(\"\")}`;\r\n    }\r\n}\r\n\r\nStyleSelector.parse = /**\r\n * @param {string} text\r\n */\r\nfunction (text) {\r\n    const re = /^\\s*([a-z]+)/;\r\n    const m = re.exec(text);\r\n\r\n    if (!m) return null;\r\n\r\n    let type = m[1];\r\n\r\n    if (type === \"rel\") {\r\n      type = \"relation\";\r\n    }\r\n\r\n    /** @type {{ [key: string]: string }} */\r\n    const tags = {};\r\n\r\n    let tagText = text.substring(m[0].length).trim();\r\n\r\n    const re2 = /^\\[([a-z0-9_-]+)(?:(=|<=|>=|<|>)([^[\\]]+))?\\]/i;\r\n\r\n    while (true) {\r\n      const m2 = re2.exec(tagText);\r\n\r\n      if (!m2) break;\r\n\r\n      const op = m2[2] === \"=\" ? \"\" : m2[2];\r\n\r\n      tags[m2[1]] = m2[3] ? op + m2[3] : \"*\";\r\n\r\n      tagText = tagText.substring(m2[0].length);\r\n    }\r\n\r\n    /** @type {{ name: string, params: (string|Predicate)[] }[]} */\r\n    const pseudoClasses = [];\r\n\r\n    const re3 = /^:([a-z-]+)(?:\\(([^)]+)\\))?/;\r\n\r\n    while (true) {\r\n      const m3 = re3.exec(tagText);\r\n\r\n      if (!m3) break;\r\n\r\n      const re = /^\\s*([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?/;\r\n      const params = m3[2] ? m3[2].split(\",\").map(s => re.test(s) ? makePredicate(re.exec(s)) : s) : [];\r\n      pseudoClasses.push({ name: m3[1], params });\r\n\r\n      tagText = tagText.substring(m3[0].length);\r\n    }\r\n\r\n    let pseudoElement = null;\r\n\r\n    const re4 = /^::([a-z-]+)?/;\r\n\r\n    if (re4.test(tagText)) {\r\n      const m4 = re4.exec(tagText);\r\n\r\n      pseudoElement = m4[1];\r\n\r\n      tagText = tagText.substring(m4[0].length);\r\n    }\r\n\r\n    if (tagText.length) {\r\n      console.log(`Invalid selector: ${text} unexpected part: '${tagText}'`);\r\n      return null;\r\n    }\r\n\r\n    return new StyleSelector(type, tags, pseudoClasses, pseudoElement);\r\n};\r\n\r\n/**\r\n *\r\n * @param {string} text\r\n */\r\nStyleSelector.parseMultiple = function (text) {\r\n    return text.split(\",\").map(StyleSelector.parse).filter(x => x);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{ rules: StyleRule[] }} style\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @returns {StyleRule}\r\n */\r\nexport function matchRule (style, element) {\r\n    for (const rule of style.rules) {\r\n      for (const selector of rule.selectors) {\r\n        if (matchSelector(selector, element))  return rule;\r\n      }\r\n    }\r\n}\r\n\r\n/**\r\n * @param {StyleSelector} selector\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n */\r\nexport function matchSelector (selector, element, inequalities=true) {\r\n  if (element.type !== selector.type && !(selector.type === \"area\" && element.type === \"way\")) return false;\r\n\r\n  const entries = Object.entries(selector.tags);\r\n  if (entries.length && typeof element.tags === \"undefined\") return false;\r\n\r\n  for (const [key, value] of entries) {\r\n    if (typeof element.tags[key] === \"undefined\") return false;\r\n\r\n    const m = /^[<=>]+/.exec(value);\r\n    if (m) {\r\n      // Only test if inequalities are enabled\r\n      if (inequalities) {\r\n        const op = m[0];\r\n        const cmp = COMPARE[op];\r\n        // Skip if invalid operator\r\n        if (!cmp) continue;\r\n        const v = value.substr(m[0].length);\r\n        // String compare or numeric compare\r\n        const res = isNaN(+v) ? cmp(element.tags[key].localeCompare(v), 0) : cmp(+element.tags[key], +v);\r\n\r\n        if (!res) return false;\r\n      }\r\n      // If inequalities are disabled then this tag gets a pass\r\n    }\r\n    else if (value !== \"*\" && element.tags[key] !== value) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * @param {string} styleText\r\n */\r\nexport function parseStyle (styleText) {\r\n  /** @type {{ rules: (StyleRule|MediaQuery)[] }} */\r\n  const out = { rules: [] };\r\n\r\n  let length = styleText.length;\r\n\r\n  while (length > 0) {\r\n\r\n    // Try parsing rule list\r\n    const rulesResult = parseRules(styleText);\r\n    out.rules.push(...rulesResult.rules);\r\n    styleText = styleText.substring(rulesResult.index).trim();\r\n\r\n    // Try parsing media query\r\n    const mediaResult = parseMedia(styleText);\r\n    out.rules.push(...mediaResult.mediaQueries);\r\n    styleText = styleText.substring(mediaResult.index).trim();\r\n\r\n    if (styleText.length === length) {\r\n      console.log(\"Got stuck parsing style at: \" + styleText);\r\n      break;\r\n    }\r\n\r\n    length = styleText.length;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * @param {string} mediaText\r\n */\r\nfunction parseMedia (mediaText) {\r\n  const re = /^\\s*@match\\s*\\(([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?\\)\\s*{/;\r\n  /** @type {{ mediaQueries: MediaQuery[], index: number }} */\r\n  const out = { mediaQueries: [], index: 0 };\r\n  let match;\r\n\r\n  const re2 = /^\\s*}/;\r\n  let match2;\r\n\r\n  while (match = re.exec(mediaText)) {\r\n    const predicate = makePredicate(match);\r\n\r\n    out.index += match[0].length;\r\n\r\n    mediaText = mediaText.substring(match[0].length);\r\n\r\n    const { rules, index } = parseRules(mediaText);\r\n\r\n    out.index += index;\r\n\r\n    mediaText = mediaText.substring(index);\r\n\r\n    match2 = re2.exec(mediaText);\r\n\r\n    if (match2) {\r\n      out.mediaQueries.push({\r\n        type: \"query\",\r\n        predicate,\r\n        rules,\r\n      });\r\n\r\n      out.index += match2[0].length;\r\n\r\n    } else {\r\n      console.log(\"Unterminated media query\");\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nfunction parseRules (ruleText) {\r\n  const re = /^\\s*([^{}]+)\\s*{([^{}]*)}/;\r\n  let match;\r\n  /** @type {{ rules: StyleRule[], index: number }} */\r\n  const out = { rules: [], index: 0 };\r\n\r\n  while(match = re.exec(ruleText)) {\r\n    /** @type {{ [key: string]: string }} */\r\n    const declarations = {};\r\n\r\n    match[2].split(\";\").map(s => s.trim()).filter(s => s).forEach(s => {\r\n      // s.split(\":\", 2) is not the same as PHP\r\n      const i = s.indexOf(\":\");\r\n      const property = s.substring(0,i).trim();\r\n      const value = s.substring(i+1).trim();\r\n      declarations[property] = value;\r\n    });\r\n\r\n    const selectors = StyleSelector.parseMultiple(match[1]);\r\n\r\n    if (selectors.length) {\r\n      out.rules.push({\r\n        type: \"rule\",\r\n        selectors,\r\n        declarations,\r\n      });\r\n    }\r\n\r\n    out.index += match[0].length;\r\n\r\n    ruleText = ruleText.substring(match[0].length);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n *\r\n * @param {(StyleRule|MediaQuery)[]} rules\r\n * @param {object} context\r\n * @returns {StyleRule[]}\r\n */\r\nexport function expandRules (rules, context) {\r\n  /** @type {StyleRule[]} */\r\n  const out = [];\r\n  for (const rule of rules) {\r\n    if (rule.type === \"rule\") {\r\n      const { declarations } = rule;\r\n      for (const selector of rule.selectors) {\r\n        out.push({ type: \"rule\", selector, declarations });\r\n      }\r\n    } else {\r\n      if (testPredicate(rule.predicate, context)) {\r\n        out.push(...expandRules(rule.rules, context));\r\n      }\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction makePredicate(match) {\r\n  let predicate;\r\n\r\n  if (match[4]) {\r\n    // MediaQueries4 syntax:\r\n    //  @match (10 < zoom <= 14)\r\n    predicate = {\r\n      left: { left: match[1], operator: match[2], right: match[3] },\r\n      operator: \"and\",\r\n      right: { left: match[3], operator: match[4], right: match[5] },\r\n    };\r\n  }\r\n  else {\r\n    // MediaQueries4 syntax:\r\n    //  @match (zoom <= 14)\r\n    // MediaQueries3 syntax:\r\n    //  @match (max-zoom: 14) [TODO - it's parsed just not handled correctly]\r\n    predicate = {\r\n      left: match[1],\r\n      operator: match[2],\r\n      right: match[3],\r\n    };\r\n  }\r\n  return predicate;\r\n}\r\n\r\n/**\r\n *\r\n * @param {Predicate} predicate\r\n * @param {object} [context]\r\n * @returns {boolean}\r\n */\r\nexport function testPredicate (predicate, context={}) {\r\n  let left = typeof predicate.left === \"string\" || typeof predicate.left === \"number\" ?\r\n    predicate.left : testPredicate(predicate.left, context);\r\n  let right = typeof predicate.right === \"string\" || typeof predicate.right === \"number\"  ?\r\n    predicate.right : testPredicate(predicate.right, context);\r\n\r\n  if (typeof left === \"string\" && left in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[left] instanceof Function)\r\n      context[left] = context[left]();\r\n\r\n    left = context[left];\r\n  }\r\n\r\n  if (typeof right === \"string\" && right in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[right] instanceof Function)\r\n      context[right] = context[right]();\r\n\r\n    right = context[right];\r\n  }\r\n\r\n  const op = COMPARE[predicate.operator];\r\n\r\n  if (!op) return false;\r\n\r\n  return op(left, right);\r\n}\r\n\r\nconst COMPARE = {\r\n  \":\": (a,b) => a == b,\r\n  \"=\": (a,b) => a == b,\r\n  \">\": (a,b) => a > b,\r\n  \"<\": (a,b) => a < b,\r\n  \">=\": (a,b) => a >= b,\r\n  \"<=\": (a,b) => a <= b,\r\n  \"and\": (a,b) => a && b,\r\n  \"or\": (a,b) => a || b,\r\n}","/**\r\n * Promise based timeout\r\n * @param {number} duration\r\n */\r\nexport function timeout (duration) {\r\n    return new Promise(resolve => setTimeout(resolve, duration));\r\n}\r\n\r\n/**\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n * @param {number} minLon\r\n * @param {number} minLat\r\n * @param {number} maxLon\r\n * @param {number} maxLat\r\n * @param {number} width\r\n * @param {number} height\r\n */\r\nexport function flatProjection(minLon, minLat, maxLon, maxLat, width, height) {\r\n    const xScale = width / (maxLon - minLon);\r\n    const yScale = height / (maxLat - minLat);\r\n    const scale = Math.max(xScale, yScale);\r\n    return ((lon, lat) => [(lon - minLon) * scale, height - (lat - minLat) * scale]);\r\n}\r\n/**\r\n * @param {[number, number]} centre\r\n * @param {number} scale\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n */\r\nexport function mercatorProjection(centre, scale, width, height) {\r\n    const baseTileSize = 256;\r\n\r\n    const [cLon, cLat] = centre;\r\n\r\n    const tileCount = Math.pow(2, scale);\r\n    const degPerTileH = 180 / tileCount;\r\n    const degPerTileV = 180 / tileCount;\r\n\r\n    const hPixelsPerDeg = baseTileSize / degPerTileH;\r\n    const vPixelsPerDeg = baseTileSize / degPerTileV;\r\n\r\n    const QUARTER_PI = Math.PI / 4;\r\n\r\n    const cX = width / 2;\r\n    const cY = height / 2;\r\n\r\n    const cLatPrime = Math.log(Math.tan(QUARTER_PI + (cLat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n    return (lon, lat) => {\r\n        const E = lon;\r\n        const N = Math.log(Math.tan(QUARTER_PI + (lat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n        const dLon = E - cLon;\r\n        const dLat = N - cLatPrime;\r\n\r\n        const dX = dLon * hPixelsPerDeg;\r\n        const dY = dLat * vPixelsPerDeg;\r\n\r\n        return [cX + dX, cY - dY];\r\n    };\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n */\r\n\r\nexport function getAveragePoint(points) {\r\n    const sum = points.reduce((sum, p) => [sum[0] + p[0], sum[1] + p[1]], [0, 0]);\r\n    /** @type {[number, number]} */\r\n    const avg = (sum.map(x => x / points.length));\r\n    return avg;\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n * @returns {[number, number]}\r\n */\r\n\r\nexport function getCentrePoint(points) {\r\n    const boundingBox = getBoundingBox(points);\r\n\r\n    return [\r\n        boundingBox[0] + boundingBox[2] / 2,\r\n        boundingBox[1] + boundingBox[3] / 2,\r\n    ];\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n * @returns {[number, number]}\r\n */\r\n\r\nexport function getMidPoint(points) {\r\n    return points[Math.floor((points.length - 1) / 2)];\r\n}\r\n/**\r\n * @param {[number, number][]} points\r\n * @returns {[number, number, number, number]} (x, y, width, height)\r\n */\r\n\r\nexport function getBoundingBox(points) {\r\n    const minMax = points.reduce((minMax, point) => {\r\n        return [\r\n            Math.min(minMax[0], point[0]),\r\n            Math.min(minMax[1], point[1]),\r\n            Math.max(minMax[2], point[0]),\r\n            Math.max(minMax[3], point[1]),\r\n        ];\r\n    }, [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]);\r\n\r\n    return [\r\n        minMax[0],\r\n        minMax[1],\r\n        minMax[2] - minMax[0],\r\n        minMax[3] - minMax[1],\r\n    ];\r\n}\r\n","\r\n/**\r\n * \r\n * @param {number} x \r\n * @param {number} y \r\n * @param {number} width \r\n * @param {number} height \r\n * @returns {[number, number][]}\r\n */\r\nexport function rectToPoints(x, y, width, height) {\r\n    /** @type {[number, number][]} */\r\n    return [\r\n        [x, y],\r\n        [x, y + height],\r\n        [x + width, y + height],\r\n        [x + width, y],\r\n    ];\r\n}\r\n\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points \r\n */\r\nexport function getCrossProductArea (points) {\r\n    let sum = 0;\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n        sum += points[i][0] * points[i+1][1] - points[i+1][0] * points[i][1];\r\n    }\r\n    return sum / 2;\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getArea (points) {\r\n    return Math.abs(getCrossProductArea(points));\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isAntiClockwise (points) {\r\n    return getCrossProductArea(points) > 0;\r\n}\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points\r\n */\r\nexport function isConvex (points) {\r\n    const l = points.length;\r\n    if (l < 3) return;\r\n\r\n    let sign = 0;\r\n    for (let i = 1; i < l; i++) {\r\n        const a = points[i-1];\r\n        const b = points[i];\r\n        const c = points[(i+1) % l];\r\n        \r\n        const next = Math.sign((b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]));\r\n\r\n        if (sign === 0) sign = next;\r\n        else if (next !== 0 && sign !== next) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isSelfClosing (points) {\r\n    const f = points[0];\r\n    const l = points[points.length - 1]; \r\n    return f[0] === l[0] && f[1] === l[1];\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getLength (points) {\r\n    let sum = 0;\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n        const dx = points[i][0] - points[i-1][0];\r\n        const dy = points[i][1] - points[i-1][1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    return sum;\r\n}","import { getArea, isConvex, isAntiClockwise, getLength } from \"./geometry\";\r\nimport { testPredicate } from \"./Style\";\r\nimport { getBoundingBox } from \"./util\";\r\n\r\n/** @typedef {import(\"./Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"./Overpass\").OverpassElement} OverpassElement */\r\n\r\n\r\n/**\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @param {import(\"./Overpass\").OverpassElement[]} nodes\r\n */\r\nexport function matchPseudoClasses(rule, points, element=null, nodes = null) {\r\n    const { selector } = rule;\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"convex\")) {\r\n        if (!isConvex(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"concave\")) {\r\n        if (isConvex(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"clockwise\")) {\r\n        if (isAntiClockwise(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"anti-clockwise\")) {\r\n        if (!isAntiClockwise(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"self-closing\")) {\r\n        if (nodes[0] !== nodes[points.length - 1])\r\n            return false;\r\n    }\r\n\r\n    const hasPseudoClasses = selector.pseudoClasses.filter(c => c.name === \"has\");\r\n\r\n    for (const pc of hasPseudoClasses) {\r\n        if (typeof pc.params[0] === \"string\")\r\n            return false;\r\n\r\n        const predicate = pc.params[0];\r\n\r\n        // Functions for lazy evaluation\r\n        const elementContext = {\r\n            area: () => getArea(points),\r\n            length: () => getLength(points),\r\n            width: () => getBoundingBox(points)[2],\r\n            height: () => getBoundingBox(points)[3],\r\n        };\r\n\r\n        const match = testPredicate(predicate, elementContext);\r\n\r\n        if (!match) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * @todo Add support for more than one paramater\r\n * @param {import(\"./Overpass\").StyleSelector} selector\r\n * @param {string} name\r\n * @param  {...string} params\r\n */\r\nfunction includesPseudoClass (selector, name, ...params) {\r\n    return selector.pseudoClasses.some(c => c.name === name && c.params[0] === params[0]);\r\n}","/**\r\n * @param {import(\"./Style\").StyleRule} rule\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n * @param {import(\"./MapRenderer\").MapContext} context\r\n */\r\n\r\nexport function getContent(rule, element, context) {\r\n    let content = rule.declarations[\"content\"];\r\n\r\n    if (!content)\r\n        return \"\";\r\n\r\n    let index = 0;\r\n    /** @type {string[]} */\r\n    const out = [];\r\n\r\n    while (index < content.length) {\r\n        const c = content.substr(index);\r\n\r\n        let m = /^\\s+/.exec(c);\r\n        if (m) {\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        m = /^\"(.*?[^\\\\])\"/.exec(c);\r\n        if (m) {\r\n            out.push(m[1].replace(/\\\\\"/g, `\"`).replace(/\\\\n/g, `\\n`));\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        m = /^tag\\(([^)]+)\\)/.exec(c);\r\n        if (m) {\r\n            out.push(element.tags[m[1]] || \"\");\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        m = /^debug\\(([^)]+)\\)/.exec(c);\r\n        if (m) {\r\n            if (m[1] === \"type\") out.push(element.type);\r\n            else if (m[1] === \"tags\") out.push(Object.entries(element.tags).map(([key, value]) => `[${key}=${value}]`).join(\"\\n\"));\r\n            else if (m[1] === \"location\" && element.type === \"node\") out.push(`(${element.lon},${element.lat})`);\r\n            else if (m[1] === \"node_count\" && (element.type === \"way\" || element.type === \"area\")) out.push(element.nodes.length.toString());\r\n            // else if (m[1] === \"length\" && (element.type === \"way\" || element.type === \"area\")) out.push(getLength(element.).toString())\r\n            // else if (m[1] === \"area\" && (element.type === \"way\" || element.type === \"area\")) out.push(getArea(element.).toString())\r\n            else if (m[1] === \"scale\") out.push(context.scale.toString());\r\n            index += m[0].length;\r\n            continue;\r\n        }\r\n\r\n        // Shouldn't get here\r\n        return \"?\";\r\n    }\r\n\r\n    return out.join(\"\");\r\n}\r\n","\r\n/**\r\n * Can the string be considered a valid bbox?\r\n * - Are there four parts?\r\n * - Are they all numberic?\r\n * - Are they in the correct order?\r\n * @param {string} bbox\r\n */\r\nexport function isValid (bbox) {\r\n    const parts = bbox.split(\",\");\r\n\r\n    if (parts.length !== 4) return false;\r\n\r\n    if (parts.some(p => isNaN(+p))) return false;\r\n\r\n    return +parts[0] < +parts[2] && +parts[1] < +parts[3];\r\n}\r\n\r\n/**\r\n * Determines whether or not areaB is entirely contained\r\n * within areaA\r\n * @param {string} areaA\r\n * @param {string} areaB\r\n * @returns {boolean}\r\n */\r\nexport function contains (areaA, areaB) {\r\n    const [Ax1,Ay1,Ax2,Ay2] = areaA.split(\",\");\r\n    const [Bx1,By1,Bx2,By2] = areaB.split(\",\");\r\n\r\n    return (Bx1 >= Ax1 && By1 >= Ay1 && Bx2 <= Ax2 && By2 <= Ay2);\r\n}\r\n\r\n/**\r\n * Compute simple area\r\n * @param {string} bbox\r\n */\r\nexport function getArea (bbox) {\r\n    const parts = bbox.split(\",\");\r\n    return (+parts[2] - +parts[0]) * (+parts[3] - +parts[1]);\r\n}\r\n\r\n/**\r\n *\r\n * @param {[number, number]} centre\r\n * @param {number} zoom\r\n * @param {[number, number]} size\r\n */\r\nexport function makeBBox (centre, zoom, size) {\r\n    const baseTileSize = 256;\r\n\r\n    const [ lon, lat ] = centre;\r\n    const [ width, height ] = size;\r\n\r\n    const tileCount = Math.pow(2, zoom)\r\n    const xSpan = 180 / tileCount;\r\n    const ySpan = 180 / tileCount;\r\n\r\n    const hTileCount = width / baseTileSize;\r\n    const vTileCount = height / baseTileSize;\r\n\r\n    const dLon = xSpan * hTileCount;\r\n    const dLat = ySpan * vTileCount;\r\n\r\n    return [ lon - dLon, lat - dLat, lon + dLon, lat + dLat ].map(p => p.toFixed(3)).join(\",\");\r\n}","import { mercatorProjection, getCentrePoint, getMidPoint, getAveragePoint, getBoundingBox } from \"./util\";\r\nimport { rectToPoints, isSelfClosing } from \"./geometry\";\r\nimport { matchPseudoClasses } from \"./matchPseudoClasses\";\r\nimport { getContent } from \"./getContent\";\r\nimport { makeBBox } from \"./bbox\";\r\nimport { matchSelector } from \"./Style\";\r\n\r\n/** @typedef {{ centre: [number, number], zoom: number, bbox: string, current?: { longitude: number, latitude: number }, width: number, height: number, scale: number }} MapContext */\r\n\r\nexport default class MapRenderer {\r\n\r\n    /**\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {import(\"./Overpass\").OverpassElement[]} elements\r\n     */\r\n    renderRule (context, rule, elements=[]) {\r\n        // Prepare node map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n        const nodeMap = {};\r\n        elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n        // Prepare way map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n        const wayMap = {};\r\n        elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n        const { centre, zoom, width, height } = context;\r\n\r\n        /** @type {(lon: number, lat: number) => [number, number]} */\r\n        const projection = mercatorProjection(centre, zoom, width, height);\r\n\r\n        // Set up global context options\r\n        this.globalSetup(context, rule);\r\n\r\n        const { type } = rule.selector;\r\n\r\n        // Non-Overpass Types first\r\n        switch (type) {\r\n            case \"map\": {\r\n                const points = rectToPoints(0, 0, width, height);\r\n                if (rule.selector.pseudoElement)\r\n                    this.renderPseudoElement(context, rule, points, null, null);\r\n                else\r\n                    this.renderArea(context, rule, points, null);\r\n                break;\r\n            }\r\n            case \"current\": {\r\n                if (context.current) {\r\n                    const coords = context.current;\r\n                    this.renderPoint(context, rule, projection(coords.longitude, coords.latitude));\r\n                }\r\n                break;\r\n            }\r\n            case \"gridlines\": {\r\n                this.renderGridlines(context, rule, projection);\r\n                break;\r\n            }\r\n            case \"dummy\": {\r\n                this.renderPoint(context, rule, [0, 0]);\r\n                break;\r\n            }\r\n            default:\r\n                // Then iterate all elements\r\n                for (const el of elements) {\r\n                    if (!matchSelector(rule.selector, el)) continue;\r\n\r\n                    switch (type) {\r\n                        case \"node\": {\r\n                            if (el.type !== \"node\") continue;\r\n\r\n                            const point = projection(el.lon, el.lat);\r\n\r\n                            if (rule.selector.pseudoElement) {\r\n                                this.renderPseudoElement(context, rule, [point], el, [el]);\r\n                            }\r\n                            else {\r\n                                this.renderPoint(context, rule, point, el);\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"way\":\r\n                        case \"area\": {\r\n                            if (el.type !== \"way\") continue;\r\n\r\n                            /** @type {import(\"./Overpass\").OverpassNodeElement[]} */\r\n                            const nodes = el.nodes.map(id => nodeMap[id]);\r\n                            const points = nodes.map(n => projection(n.lon, n.lat));\r\n\r\n                            if (!matchPseudoClasses(rule, points, el, nodes)) continue;\r\n\r\n                            if (rule.selector.pseudoElement) {\r\n                                this.renderPseudoElement(context, rule, points, el, nodes);\r\n                            }\r\n                            else {\r\n                                // Render actual way/area\r\n                                if (type === \"area\") {\r\n                                    this.renderArea(context, rule, points, el);\r\n                                } else {\r\n                                    this.renderLine(context, rule, points, el);\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                        case \"relation\": {\r\n                            if (el.type !== \"relation\") continue;\r\n\r\n                            // this.renderRelation(rule, el, wayMap, nodeMap, projection, context);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n        }\r\n    }\r\n\r\n    renderPoint (context, rule, point, element=null) {}\r\n\r\n    renderLine (context, rule, points, element=null) {\r\n        this.renderAreaLine(context, rule, points, getMidPoint, element);\r\n    }\r\n\r\n    renderArea (context, rule, points, element=null) {\r\n        if (points.length === 0)\r\n            return;\r\n\r\n        if (!isSelfClosing(points)) {\r\n            points = [ ...points, points[0] ];\r\n        }\r\n\r\n        this.renderAreaLine(context, rule, points, getCentrePoint, element);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {}\r\n\r\n    /**\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {[number, number][]} points\r\n     * @param {import(\"./Overpass\").OverpassElement} [element]\r\n     * @param {import(\"./Overpass\").OverpassNodeElement[]} [nodes]\r\n     */\r\n    renderPseudoElement(context, rule, points, element=null, nodes=null) {\r\n        switch (rule.selector.pseudoElement) {\r\n            case \"centre\":\r\n            case \"center\": {\r\n                // Centre of bounding box\r\n                const centrePoint = getCentrePoint(points);\r\n                this.renderPoint(context, rule, centrePoint, element);\r\n                break;\r\n            }\r\n            case \"mid-point\": {\r\n                // N/2th point (median point)\r\n                const midPoint = getMidPoint(points);\r\n                this.renderPoint(context, rule, midPoint, element);\r\n                break;\r\n            }\r\n            case \"average-point\": {\r\n                // Average of all points\r\n                const avgPoint = getAveragePoint(points);\r\n                this.renderPoint(rule, avgPoint, element, context);\r\n                break;\r\n            }\r\n            case \"start\": {\r\n                // First point\r\n                this.renderPoint(context, rule, points[0], element);\r\n                break;\r\n            }\r\n            case \"end\": {\r\n                // Last point\r\n                this.renderPoint(context, rule, points[points.length - 1], element);\r\n                break;\r\n            }\r\n            case \"centre-of-mass\": {\r\n                // TODO: calculate centre-of-mass\r\n                // const avgPoint = getCOMPoint(points);\r\n                // renderPoint(ctx, rule, avgPoint, element);\r\n                break;\r\n            }\r\n            case \"bounding-box\": {\r\n                const bounding = getBoundingBox(points);\r\n\r\n                const boundingPoints = rectToPoints(...bounding);\r\n\r\n                this.renderArea(context, rule, boundingPoints, element);\r\n                break;\r\n            }\r\n            case \"content-box\": {\r\n                const { scale } = context;\r\n                let point = points[0];\r\n\r\n                if (rule.selector.type === \"way\")\r\n                    point = getMidPoint(points);\r\n                else if (rule.selector.type === \"area\")\r\n                    point = getCentrePoint(points);\r\n\r\n                let [ x, y ] = point;\r\n\r\n                const content = getContent(rule, element, context);\r\n\r\n                if (!content) return;\r\n\r\n                let width = Number.NEGATIVE_INFINITY;;\r\n                let top = Number.NaN;\r\n                let bottom;\r\n                let baseline = y;\r\n                for (const line of content.split(\"\\n\")) {\r\n                    const size = this.measureText(context, rule, line);\r\n\r\n                    width = Math.max(width, size.width);\r\n\r\n                    if (isNaN(top)) top = y - size.ascending;\r\n\r\n                    bottom = baseline + size.descending;\r\n\r\n                    baseline += size.height;\r\n                }\r\n\r\n                const padding = rule.declarations[\"padding\"] ? parseFloat(rule.declarations[\"padding\"]) * scale : 0;\r\n\r\n                if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n                    x -= width / 2;\r\n                }\r\n                else if (rule.declarations[\"text-align\"] === \"right\") {\r\n                    x -= width;\r\n                }\r\n\r\n                /** @type {[number, number][]} */\r\n                const boundPoints = [\r\n                    [ x - padding,           top - padding ],     // Top Left\r\n                    [ x - padding,           bottom + padding ],    // Bottom left\r\n                    [ x + width + padding,   bottom + padding ],    // Bottom right\r\n                    [ x + width + padding,   top - padding ],     // Top Right\r\n                ];\r\n\r\n                // Close self\r\n                boundPoints.push(boundPoints[0]);\r\n\r\n                this.renderAreaLine(context, rule, boundPoints, () => point, element);\r\n                break;\r\n            }\r\n            case \"decimate\": {\r\n                if (rule.selector.type === \"way\") {\r\n                    const l = points.length - 1;\r\n                    const decimatedPoints = points.filter((p, i) => i % 10 === 0 || i === l);\r\n                    this.renderLine(context, rule, decimatedPoints, element);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    renderGridlines (context, rule, projection) {\r\n        const vertical = rule.selector.pseudoClasses.find(p => p.name === \"vertical\");\r\n        const horizontal = rule.selector.pseudoClasses.find(p => p.name === \"horizontal\");\r\n\r\n        const { width, height, centre, zoom } = context;\r\n\r\n        const bbox = makeBBox(centre, zoom, [width, height]);\r\n        const parts = bbox.split(\",\");\r\n\r\n        if (vertical) {\r\n            const step = parseFloat(vertical.params[0]);\r\n\r\n            const round = 1 / step;\r\n\r\n            const sigFigs = Math.ceil(Math.log10(round));\r\n\r\n            const xmin = Math.floor(+parts[0] * round) / round;\r\n            const xmax = Math.ceil(+parts[2] * round) / round;\r\n            const ymin = Math.floor(+parts[1] * round) / round;\r\n            const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n            for (let i = xmin; i <= xmax; i += step) {\r\n                const points = [ projection(i, ymin),  projection(i, (ymin + ymax) / 2), projection(i, ymax) ];\r\n                this.renderLine(context, rule, points, { type: \"way\", id: 0, nodes: [], tags: { name: i.toFixed(sigFigs) }});\r\n            }\r\n        }\r\n\r\n        if (horizontal) {\r\n            const step = parseFloat(horizontal.params[0]);\r\n\r\n            const round = 1 / step;\r\n\r\n            const sigFigs = Math.ceil(Math.log10(round));\r\n\r\n            const xmin = Math.floor(+parts[0] * round) / round;\r\n            const xmax = Math.ceil(+parts[2] * round) / round;\r\n            const ymin = Math.floor(+parts[1] * round) / round;\r\n            const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n            for (let j = ymin; j <= ymax; j += step) {\r\n                const points = [ projection(xmin, j), projection((xmin + xmax) / 2, j), projection(xmax, j) ];\r\n                this.renderLine(context, rule, points, { type: \"way\", id: 0, nodes: [], tags: { name: j.toFixed(sigFigs) }});\r\n            }\r\n        }\r\n    }\r\n\r\n    clear (context) {}\r\n\r\n    globalSetup (context, rule) { }\r\n\r\n    /**\r\n     *\r\n     * @param {MapContext} context\r\n     * @param {import(\"./Style\").StyleRule} rule\r\n     * @param {string} text\r\n     * @return {{ width: number, ascending: number, descending: number, height: number }}\r\n     */\r\n    measureText (context, rule, text) {\r\n        return { width: 0, ascending: 0, descending: 0, height: 0 };\r\n    }\r\n}","/**\r\n * @param {import(\"./Style\").StyleRule} rule\r\n * @param {number} scale\r\n */\r\nexport function parseStrokeFill(rule, scale) {\r\n    const fillStyle = rule.declarations[\"fill\"];\r\n    let strokeStyle = rule.declarations[\"stroke\"];\r\n    let lineWidth;\r\n    /** @type {number[]} */\r\n    let lineDash;\r\n\r\n    if (strokeStyle) {\r\n        // Numbers in e.g. rgba(128,64,0,0.2) confuse it\r\n        let mutedStyle = strokeStyle.replace(/\\([^)]*\\)/g, ss => \" \".repeat(ss.length));\r\n\r\n        // So would hex colour strings\r\n        mutedStyle = mutedStyle.replace(/#[0-9a-f]{3}/i, \"    \");\r\n        mutedStyle = mutedStyle.replace(/#[0-9a-f]{6}/i, \"       \");\r\n\r\n        /**\r\n         * @todo A better parser would probably be nice\r\n         */\r\n        const swRe = /(\\d+(?:\\.\\d+)?)\\s*(?:px)?/;\r\n        const sm = swRe.exec(mutedStyle);\r\n        if (sm) {\r\n            lineWidth = +sm[1] * scale;\r\n            strokeStyle = strokeStyle.replace(sm[0], \"\");\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"stroke-width\"]) {\r\n        lineWidth = +rule.declarations[\"stroke-width\"] * scale;\r\n    }\r\n\r\n    if (rule.declarations[\"stroke-dash\"]) {\r\n        lineDash = rule.declarations[\"stroke-dash\"].split(\" \").map(s => +s * scale);\r\n    }\r\n\r\n    return {\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth,\r\n        lineDash,\r\n    };\r\n}","import { parseStrokeFill } from '../parseStrokeFill';\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {import(\"../Style\").StyleRule} rule\r\n */\r\nexport function setStrokeFill (ctx, rule, scale) {\r\n    const { fillStyle, strokeStyle, lineWidth, lineDash } = parseStrokeFill(rule, scale);\r\n\r\n    ctx.fillStyle = fillStyle;\r\n    ctx.strokeStyle = strokeStyle;\r\n    ctx.lineWidth = lineWidth;\r\n    if (lineDash) {\r\n        ctx.setLineDash(lineDash);\r\n    }\r\n}","/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\nimport { setStrokeFill } from \"./setStrokeFill\";\r\nimport { getContent } from \"../getContent\";\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} param2\r\n * @param {OverpassElement} [element]\r\n * @param {import(\"../MapRenderer\").MapContext} context\r\n */\r\nexport function renderText(ctx, rule, [x, y], element = null, context) {\r\n    setStrokeFill(ctx, rule, context.scale);\r\n\r\n    let content = getContent(rule, element, context);\r\n\r\n    setFont(ctx, rule, context.scale);\r\n\r\n    for (const line of content.split(\"\\n\")) {\r\n        y += renderLine(ctx, rule, line, x, y, context);\r\n    }\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {string} content\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {import(\"../MapRenderer\").MapContext} context\r\n */\r\nfunction renderLine(ctx, rule, content, x, y, context) {\r\n    const size = ctx.measureText(content);\r\n\r\n    if (rule.declarations[\"text-align\"]) {\r\n        const textWidth = size.width;\r\n\r\n        if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n            x -= textWidth / 2;\r\n        }\r\n        else if (rule.declarations[\"text-align\"] === \"right\") {\r\n            x -= textWidth;\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"stroke-width\"]) {\r\n        ctx.lineWidth = parseFloat(rule.declarations[\"stroke-width\"]) * context.scale;\r\n    }\r\n\r\n    if (rule.declarations[\"text-stroke\"]) {\r\n        // Todo: parse `2px red`\r\n        ctx.strokeStyle = rule.declarations[\"text-stroke\"];\r\n        ctx.strokeText(content, x, y);\r\n    }\r\n\r\n    if (rule.declarations[\"text-color\"] || !rule.declarations[\"text-stroke\"]) {\r\n        ctx.fillStyle = rule.declarations[\"text-color\"];\r\n        ctx.fillText(content, x, y);\r\n    }\r\n\r\n    const height = size.actualBoundingBoxAscent + size.actualBoundingBoxDescent;\r\n    return height;\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {number} scale\r\n */\r\nexport function setFont(ctx, rule, scale) {\r\n    let fontSize = `${10 * scale}px`;\r\n    let fontWeight = \"normal\";\r\n    let fontFamily = \"sans-serif\";\r\n\r\n    if (rule.declarations[\"font\"]) {\r\n        // It would be nice for the specific properties to override the\r\n        // shorthand, but it would complicate things a bit.\r\n        ctx.font = rule.declarations[\"font\"].replace(/\\d+(?:\\.\\d+)?/, s => `${+s * scale}`);\r\n    }\r\n    else {\r\n        if (rule.declarations[\"font-size\"]) {\r\n            fontSize = rule.declarations[\"font-size\"].replace(/^\\d[\\d.]*/, m => `${+m * scale}`);\r\n        }\r\n\r\n        if (rule.declarations[\"font-weight\"]) {\r\n            fontWeight = rule.declarations[\"font-weight\"];\r\n        }\r\n\r\n        if (rule.declarations[\"font-family\"]) {\r\n            fontFamily = rule.declarations[\"font-family\"];\r\n        }\r\n\r\n        ctx.font = `${fontWeight} ${fontSize} ${fontFamily}`;\r\n    }\r\n}\r\n","/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n */\r\nexport function applyTransform(ctx, rule, scale) {\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        const r = /\\s*([a-z]+)\\(([^)]*)\\)\\s*/g;\r\n        const t = rule.declarations[\"transform\"];\r\n        let m;\r\n        while (m = r.exec(t)) {\r\n            const trans = m[1];\r\n            const params = m[2].split(\",\").map(s => ({ value: parseFloat(s) * scale, unit: s.replace(/[-\\d.\\s]/g, \"\") }));\r\n            switch (trans) {\r\n                case \"matrix\":\r\n                    // @ts-ignore\r\n                    ctx.transform(...params.map(p => p.value));\r\n                    break;\r\n                case \"rotate\": {\r\n                    let { value, unit } = params[0];\r\n\r\n                    if (unit === \"deg\") {\r\n                        value *= Math.PI / 180;\r\n                    } else if (unit === \"turn\") {\r\n                        value *= Math.PI * 2;\r\n                    }\r\n\r\n                    ctx.rotate(value);\r\n                    break;\r\n                }\r\n                case \"scale\":\r\n                    const x = params[0].value;\r\n                    const y = params[1] ? params[1].value : x;\r\n                    ctx.scale(x, y);\r\n                    break;\r\n                case \"translate\":\r\n                    // @ts-ignore\r\n                    ctx.translate(...params.map(p => p.value));\r\n                    break;\r\n                case \"skew\":\r\n                    let { value, unit } = params[0];\r\n\r\n                    if (unit === \"rad\")\r\n                        value = Math.tan(value);\r\n                    else if (unit === \"deg\")\r\n                        value = Math.tan(value * Math.PI / 180);\r\n\r\n                    let valueY = 0;\r\n\r\n                    if (params[1]) {\r\n                        let { value, unit } = params[1];\r\n\r\n                        if (unit === \"rad\")\r\n                            value = Math.tan(value);\r\n                        else if (unit === \"deg\")\r\n                            value = Math.tan(value * Math.PI / 180);\r\n\r\n                        valueY = value;\r\n                    }\r\n\r\n                    ctx.transform(1, valueY, value, 1, 0, 0);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { renderText } from \"./renderText\";\r\nimport { setStrokeFill } from \"./setStrokeFill\";\r\nimport { applyTransform } from \"./transform\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} position\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderPoint(ctx, rule, [x, y], element = null, context = {}) {\r\n    ctx.save();\r\n\r\n    const { scale } = context;\r\n\r\n    setStrokeFill(ctx, rule, scale);\r\n\r\n    if (rule.declarations[\"position\"] === \"absolute\") {\r\n        x = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n        y = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n    }\r\n    ctx.translate(x, y);\r\n\r\n    applyTransform(ctx, rule, scale);\r\n\r\n    if (rule.declarations[\"size\"]) {\r\n        ctx.beginPath();\r\n\r\n        const r = +rule.declarations[\"size\"] * scale;\r\n\r\n        ctx.ellipse(0, 0, r, r, 0, 0, Math.PI * 2);\r\n\r\n        rule.declarations[\"fill\"] && ctx.fill();\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    if (rule.declarations[\"path\"]) {\r\n        ctx.beginPath();\r\n\r\n        drawPath(ctx, rule.declarations[\"path\"], scale);\r\n\r\n        rule.declarations[\"fill\"] && ctx.fill();\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    // Syntax:\r\n    //  url(<URL>) [<width> [<height>]]\r\n    //  url(https://ijmacd.github.io/map-maker/logo192.png) 90px 120px;\r\n    const urlRe = /url\\(([^)]+)\\)(?:\\s+([^\\s]+)(?:\\s+([^\\s]+))?)?/;\r\n    if (urlRe.test(rule.declarations[\"icon\"])) {\r\n        const m = urlRe.exec(rule.declarations[\"icon\"]);\r\n        const url = m[1];\r\n        const img = new Image();\r\n        img.src = url;\r\n        const w = parseFloat(m[2]);\r\n        const h = parseFloat(m[3]);\r\n\r\n\r\n        img.addEventListener(\"load\", () => {\r\n            // The image is drawn in a callback so the render context state is lost\r\n            ctx.save();\r\n            // globalSetup(ctx, rule);\r\n\r\n            ctx.translate(x, y);\r\n\r\n            // applyTransform(ctx, rule);\r\n\r\n            if (w) {\r\n                const height = !isNaN(h) ? h : img.height * (w / img.width);\r\n                ctx.drawImage(img, 0, 0, w * scale, height * scale);\r\n            }\r\n            else {\r\n                ctx.drawImage(img, 0, 0);\r\n            }\r\n\r\n            ctx.restore();\r\n        });\r\n    }\r\n\r\n    if (rule.declarations[\"content\"]) {\r\n        renderText(ctx, rule, [0, 0], element, context);\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {string} pathSpec\r\n */\r\nfunction drawPath (ctx, pathSpec, scale) {\r\n    const segs = /([MLQCVHZ])\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?/ig;\r\n    let match;\r\n    /** @type {[number, number]} */\r\n    let first;\r\n    /** @type {[number, number]} */\r\n    let prev;\r\n\r\n    while (match = segs.exec(pathSpec)) {\r\n        const x = parseFloat(match[2]) * scale;\r\n        const y = parseFloat(match[3]) * scale;\r\n        const x2 = parseFloat(match[4]) * scale;\r\n        const y2 = parseFloat(match[5]) * scale;\r\n        const x3 = parseFloat(match[6]) * scale;\r\n        const y3 = parseFloat(match[7]) * scale;\r\n\r\n        if (!first) first = [x,y];\r\n\r\n        if (match[1] === \"M\") {\r\n            prev = [x,y];\r\n            ctx.moveTo(x, y);\r\n        }\r\n        else if (match[1] === \"L\") {\r\n            prev = [x,y];\r\n            ctx.lineTo(x, y);\r\n        }\r\n        else if (match[1] === \"Q\") {\r\n            prev = [x2,y2];\r\n            ctx.quadraticCurveTo(x, y, x2, y2);\r\n        }\r\n        else if (match[1] === \"C\") {\r\n            prev = [x3,y3];\r\n            ctx.bezierCurveTo(x, y, x2, y2, x3, y3);\r\n        }\r\n        else if (match[1] === \"Z\") {\r\n            prev = first;\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"V\") {\r\n            prev = [prev[0], x];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"H\") {\r\n            prev = [x, prev[1]];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"m\") {\r\n            prev = [prev[0] + x, prev[1] + y];\r\n            ctx.moveTo(...prev);\r\n        }\r\n        else if (match[1] === \"l\") {\r\n            prev = [prev[0] + x, prev[1] + y];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"q\") {\r\n            ctx.quadraticCurveTo(prev[0] + x, prev[1] + y, prev[0] + x2, prev[1] + y2);\r\n            prev = [prev[0] + x2, prev[1] + y2];\r\n        }\r\n        else if (match[1] === \"c\") {\r\n            prev = [x3,y3];\r\n            ctx.bezierCurveTo(prev[0] + x, prev[1] + y, prev[0] + x2, prev[1] + y2, prev[0] + x3, prev[1] + y3);\r\n            prev = [prev[0] + x3, prev[1] + y3];\r\n        }\r\n        else if (match[1] === \"z\") {\r\n            prev = first;\r\n            ctx.lineTo(...first);\r\n        }\r\n        else if (match[1] === \"v\") {\r\n            prev = [prev[0], prev[1] + x];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"h\") {\r\n            prev = [prev[0] + x, prev[1]];\r\n            ctx.lineTo(...prev);\r\n        }\r\n    }\r\n}","export default class CollisionSystem {\r\n    /** @type {CollisionSystem} */\r\n    static singleton;\r\n\r\n    constructor () {\r\n        /** @type {{ [name: string]: [number, number, number, number][] }} */\r\n        this.sets = {}\r\n    }\r\n\r\n    clear () {\r\n        this.sets = {};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} set\r\n     * @param {[number, number, number, number]} box\r\n     */\r\n    add (set, box) {\r\n        if (!this.sets[set]) this.sets[set] = [];\r\n\r\n        for (const other of this.sets[set]) {\r\n            if (intersects(box, other)) return false;\r\n        }\r\n\r\n        this.sets[set].push(box);\r\n\r\n        return true;\r\n    }\r\n\r\n    static getCollisionSystem () {\r\n        if (!this.singleton) {\r\n            this.singleton = new CollisionSystem();\r\n        }\r\n\r\n        return this.singleton;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * [x , y, width, height]\r\n * @param {[number, number, number, number]} boxA\r\n * @param {[number, number, number, number]} boxB\r\n */\r\nfunction intersects (boxA, boxB) {\r\n    const ax1 = boxA[0];\r\n    const ay1 = boxA[1];\r\n    const ax2 = boxA[0] + boxA[2];\r\n    const ay2 = boxA[1] + boxA[3];\r\n    const bx1 = boxB[0];\r\n    const by1 = boxB[1];\r\n    const bx2 = boxB[0] + boxB[2];\r\n    const by2 = boxB[1] + boxB[3];\r\n    return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;\r\n}","import { renderPoint } from \"./renderPoint\";\r\nimport { applyTransform } from \"./transform\";\r\nimport { setStrokeFill } from \"./setStrokeFill\";\r\nimport { getBoundingBox } from \"../util\";\r\nimport CollisionSystem from \"../CollisionSystem\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D|OffscreenCanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {(points: [number, number][]) => [number, number]} getPoint\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderAreaLine(ctx, rule, points, getPoint, element = null, context = {}) {\r\n    if (points.length === 0)\r\n        return;\r\n\r\n\r\n    if (rule.declarations[\"collision-set\"]) {\r\n        const box = getBoundingBox(points);\r\n\r\n        if (rule.declarations[\"collision-size\"]) {\r\n            const s = /(\\d+\\.?\\d*)%/.exec(rule.declarations[\"collision-size\"]);\r\n\r\n            const scaleFactor = +s[1] / 100;\r\n            const w = box[2];\r\n            const h = box[3];\r\n\r\n            box[0] += (1 - scaleFactor) * w / 2;\r\n            box[1] += (1 - scaleFactor) * h / 2;\r\n            box[2] = w * scaleFactor;\r\n            box[3] = h * scaleFactor;\r\n        }\r\n\r\n        const collisionSystem = CollisionSystem.getCollisionSystem();\r\n\r\n        if (!collisionSystem.add(rule.declarations[\"collision-set\"], box)) {\r\n            const policy = rule.declarations[\"collision-policy\"] || \"hide\";\r\n\r\n            if (policy === \"hide\") {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    ctx.save();\r\n\r\n    setStrokeFill(ctx, rule, context.scale);\r\n\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        // Extra work required if we're transforming\r\n\r\n        // First get transform origin;\r\n        const cp = getPoint(points);\r\n\r\n        // Set offset to adjust all points later\r\n        offsetX = cp[0];\r\n        offsetY = cp[1];\r\n\r\n        // Translate the canvas\r\n        ctx.translate(offsetX, offsetY);\r\n\r\n        // Apply the transformation\r\n        applyTransform(ctx, rule, context.scale);\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(points[0][0] - offsetX, points[0][1] - offsetY);\r\n    for (let i = 1; i < points.length; i++) {\r\n        ctx.lineTo(points[i][0] - offsetX, points[i][1] - offsetY);\r\n    }\r\n\r\n    rule.declarations[\"fill\"] && ctx.fill();\r\n    rule.declarations[\"stroke\"] && ctx.stroke();\r\n\r\n    ctx.restore();\r\n\r\n    // Text Handling, Icons etc.\r\n    if (rule.declarations[\"content\"] || rule.declarations[\"size\"] || rule.declarations[\"path\"] || rule.declarations[\"icon\"]) {\r\n        ctx.save();\r\n        renderPoint(ctx, rule, getPoint(points), element, context);\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\n\r\n","import MapRenderer from \"../MapRenderer\";\r\nimport { renderPoint } from \"./renderPoint\";\r\nimport { setFont } from \"./renderText\";\r\nimport { renderAreaLine } from \"./renderAreaLine\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n\r\nexport default class CanvasRender extends MapRenderer {\r\n\r\n    /**\r\n     * @param {HTMLCanvasElement|OffscreenCanvas} canvas\r\n     */\r\n    constructor (canvas) {\r\n        super();\r\n        this.canvas = canvas;\r\n    }\r\n\r\n    clear (context) {\r\n        const { width, height } = context;\r\n\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n    }\r\n\r\n    renderRule (context, rule, elements=[]) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        ctx.save();\r\n        super.renderRule(context, rule, elements);\r\n        ctx.restore();\r\n    }\r\n\r\n    globalSetup({ scale }, rule) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n\r\n        if (rule.declarations[\"opacity\"])\r\n            ctx.globalAlpha = +rule.declarations[\"opacity\"];\r\n\r\n        if (rule.declarations[\"position\"] === \"relative\") {\r\n            const top = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n            const left = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n\r\n            ctx.translate(left, top);\r\n        }\r\n    }\r\n\r\n    renderPoint (context, rule, point, element=null) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        renderPoint(ctx, rule, point, element, context);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        renderAreaLine(ctx, rule, points, getPoint, element, context);\r\n    }\r\n\r\n    measureText (context, rule, text) {\r\n        const ctx = this.canvas.getContext(\"2d\");\r\n        const { scale } = context;\r\n        setFont(ctx, rule, scale);\r\n        const size = ctx.measureText(text);\r\n        const { width, actualBoundingBoxDescent: descending, actualBoundingBoxAscent: ascending } = size;\r\n\r\n        return {\r\n            width,\r\n            ascending,\r\n            descending,\r\n            height: ascending + descending,\r\n        };\r\n    }\r\n}\r\n\r\n","export default function() {\n  return new Worker(__webpack_public_path__ + \"static/js/render-worker.30a7101a.worker.js\");\n}\n","// @ts-ignore\nimport RenderWorker from 'worker-loader!./render-worker'; // eslint-disable-line import/no-webpack-loader-syntax\nimport MapRenderer from './MapRenderer';\n\nexport default class WorkerRenderer extends MapRenderer {\n    /**\n     * @param {HTMLCanvasElement} canvas\n     */\n    constructor (canvas) {\n        super();\n\n        this.canvas = canvas.transferControlToOffscreen();\n        /** @type {Worker} */\n        this.worker = new RenderWorker();\n\n        this.worker.postMessage({ canvas: this.canvas }, [ this.canvas ]);\n    }\n\n    clear (context) {\n        this.worker.postMessage({ method: \"clear\", context });\n    }\n\n    renderRule (context, rule, _elements) {\n        this.worker.postMessage({ method: \"renderRule\", context, rule });\n    }\n}","// import { renderPoint } from \"./renderPoint\";\r\n// import { applyTransform } from \"./transform\";\r\nimport { parseStrokeFill } from \"../parseStrokeFill\";\r\nimport { getBoundingBox } from \"../util\";\r\nimport CollisionSystem from \"../CollisionSystem\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {{ elements: { type: string, [key: string]: string }[] }} layer\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {(points: [number, number][]) => [number, number]} getPoint\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderAreaLine(layer, rule, points, getPoint, element = null, context = {}) {\r\n    if (points.length === 0)\r\n        return;\r\n\r\n\r\n    if (rule.declarations[\"collision-set\"]) {\r\n        const box = getBoundingBox(points);\r\n\r\n        const collisionSystem = CollisionSystem.getCollisionSystem();\r\n\r\n        if (!collisionSystem.add(rule.declarations[\"collision-set\"], box)) {\r\n            const policy = rule.declarations[\"collision-policy\"] || \"hide\";\r\n\r\n            if (policy === \"hide\") {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    const path = { type: \"path\" };\r\n\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        // Extra work required if we're transforming\r\n\r\n        // First get transform origin;\r\n        const cp = getPoint(points);\r\n\r\n        // Set offset to adjust all points later\r\n        offsetX = cp[0];\r\n        offsetY = cp[1];\r\n\r\n        // Translate the canvas\r\n        // ctx.translate(offsetX, offsetY);\r\n\r\n        // Apply the transformation\r\n        // applyTransform(path, rule);\r\n\r\n        path.transform = rule.declarations[\"transform\"];\r\n    }\r\n\r\n    const d = [];\r\n\r\n    d.push(`M ${(points[0][0] - offsetX).toFixed(2)} ${(points[0][1] - offsetY).toFixed(2)}`);\r\n    for (let i = 1; i < points.length; i++) {\r\n        d.push(`L ${(points[i][0] - offsetX).toFixed(2)} ${(points[i][1] - offsetY).toFixed(2)}`);\r\n    }\r\n\r\n    path.d = d.join(\" \");\r\n\r\n    layer.elements.push(path);\r\n\r\n    // Text Handling, Icons etc.\r\n    if (rule.declarations[\"content\"] || rule.declarations[\"size\"] || rule.declarations[\"path\"] || rule.declarations[\"icon\"]) {\r\n        // this.renderPoint(context, rule, getPoint(points), element);\r\n    }\r\n}\r\n\r\n\r\n","import MapRenderer from \"../MapRenderer\";\r\nimport { renderAreaLine } from \"./renderAreaLine\";\r\nimport { parseStrokeFill } from \"../parseStrokeFill\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\nexport default class SVGRender extends MapRenderer {\r\n    /**\r\n     * @param {number} width\r\n     * @param {number} height\r\n     */\r\n    constructor (width, height) {\r\n        super();\r\n        this.layers = [];\r\n        this.width = width;\r\n        this.height = height;\r\n        this.currentLayer = null;\r\n    }\r\n\r\n    clear () {\r\n        this.layers.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @param {import(\"../MapRenderer\").MapContext} context\r\n     * @param {import(\"../Style\").StyleRule} rule\r\n     * @param {import(\"../Overpass\").OverpassElement[]} elements\r\n     */\r\n    renderRule (context, rule, elements=[]) {\r\n        this.currentLayer = { elements: [] };\r\n\r\n        const colours = parseStrokeFill(rule);\r\n\r\n        this.currentLayer.stroke = colours.strokeStyle;\r\n        this.currentLayer.fill = colours.fillStyle || \"none\";\r\n\r\n        // Set up global context options\r\n        layerSetup(this.currentLayer, rule, context.scale);\r\n\r\n        super.renderRule(context, rule, elements);\r\n\r\n        this.layers.push(this.currentLayer);\r\n    }\r\n\r\n    renderAreaLine (context, rule, points, getPoint, element=null) {\r\n        renderAreaLine(this.currentLayer, rule, points, getPoint, element, context);\r\n    }\r\n\r\n    toString () {\r\n        return this.getTextParts().join(\"\");\r\n    }\r\n\r\n    toBlob () {\r\n        return new Blob(this.getTextParts());\r\n    }\r\n\r\n    getTextParts() {\r\n        const parts = [];\r\n\r\n        parts.push(`<svg version=\"1.1\" viewBox=\"0 0 ${this.width} ${this.height}\" width=\"${this.width}\" height=\"${this.height}\" xmlns=\"http://www.w3.org/2000/svg\">\\n`);\r\n\r\n        for (const layer of this.layers) {\r\n            const { elements, ...attr } = layer;\r\n\r\n            parts.push(`<g ${attributes(attr)}>\\n`);\r\n\r\n            for (const element of elements) {\r\n                const { type, ...attr } = element;\r\n                parts.push(`<${type} ${attributes(attr)} />\\n`);\r\n            }\r\n\r\n            parts.push(`</g>\\n`);\r\n        }\r\n\r\n        parts.push(`</svg>`);\r\n        return parts;\r\n    }\r\n}\r\n\r\nfunction attributes(attr) {\r\n    return Object.entries(attr).filter(([key, value]) => typeof value !== \"undefined\").map(([key, value]) => `${key}=\"${value}\"`).join(\" \");\r\n}\r\n\r\nexport function layerSetup(layer, rule, scale) {\r\n    if (rule.declarations[\"opacity\"])\r\n        layer.opacity = +rule.declarations[\"opacity\"];\r\n\r\n    if (rule.declarations[\"position\"] === \"relative\") {\r\n        const top = (parseFloat(rule.declarations[\"top\"]) || 0) * scale;\r\n        const left = (parseFloat(rule.declarations[\"left\"]) || 0) * scale;\r\n\r\n        layer.translate = [left, top];\r\n    }\r\n}\r\n","import { contains, getArea } from \"./bbox\";\r\n\r\nexport default class IDBElementDatabase {\r\n    constructor (name=\"OverpassElements\") {\r\n        const request = indexedDB.open(name);\r\n\r\n        request.addEventListener(\"upgradeneeded\", ev => {\r\n            /** @type {IDBOpenDBRequest} */\r\n            const request = (ev.target);\r\n            const db = request.result;\r\n            db.createObjectStore(\"nodes\", { keyPath: \"id\" });\r\n\r\n            const store = db.createObjectStore(\"elements\");\r\n            store.createIndex(\"selectorIndex\", [\"selector\", \"area\", \"bbox\"], { unique: false });\r\n        });\r\n\r\n        /** @type {Promise<IDBDatabase>} */\r\n        this.db = new Promise((resolve, reject) => {\r\n            request.addEventListener(\"success\", ev => {\r\n                /** @type {IDBOpenDBRequest} */\r\n                const request = (ev.target);\r\n                resolve(request.result);\r\n            });\r\n\r\n            request.addEventListener(\"error\", reject);\r\n        })\r\n\r\n    }\r\n\r\n    async saveNodes (nodes) {\r\n        const db = await this.db;\r\n        const store = db.transaction(\"nodes\", \"readwrite\").objectStore(\"nodes\");\r\n        for (const n of nodes) {\r\n            store.put(n);\r\n        }\r\n    }\r\n\r\n    async getNode (id) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const store = db.transaction(\"nodes\", \"readonly\").objectStore(\"nodes\");\r\n            const request = store.get(id);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", e => reject(e));\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number[]} ids\r\n     */\r\n    getNodes (ids) {\r\n        return Promise.all(ids.map(id => this.getNode(id)));\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} bbox\r\n     * @param {string} selector\r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    getElements (bbox, selector) {\r\n        const key = makeKey(bbox, selector);\r\n        return this.getElementsByKey(key);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} key\r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    async getElementsByKey (key) {\r\n        const db = await this.db;\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const request = objectStore.get(key);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} bbox\r\n     * @param {string} selector\r\n     * @returns {Promise<string>}\r\n     */\r\n    async searchElements (bbox, selector) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const index = objectStore.index(\"selectorIndex\");\r\n            const range = IDBKeyRange.bound([selector,0,\"0\"], [selector,Number.MAX_VALUE,\"999999999999999999\"]);\r\n            const request = index.openKeyCursor(range);\r\n            let count = 0;\r\n            const bboxOversizeArea = getArea(bbox) * 9;\r\n            request.addEventListener(\"success\", e => {\r\n                const cursor = request.result;\r\n\r\n                if (cursor) {\r\n                    const { key, primaryKey } = cursor;\r\n                    const keyBBox = key[2];\r\n                    const keyArea = key[1];\r\n                    count++;\r\n                    console.debug(`Checking index #${count} for ${selector}`);\r\n                    if (contains(keyBBox, bbox) && keyArea < bboxOversizeArea) {\r\n                        console.debug(`${selector} found after checking ${count} records`);\r\n                        resolve(primaryKey.toString());\r\n                        return;\r\n                    }\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    console.debug(`${selector} not found after checking ${count} records`);\r\n                    resolve(null);\r\n                }\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} bbox\r\n     * @param {string} selector\r\n     * @param {{ elements: import(\"./Overpass\").OverpassElement[], cached: number }} record\r\n     */\r\n    async saveElements (bbox, selector, record) {\r\n        const db = await this.db;\r\n        const key = makeKey(bbox, selector);\r\n        const area = getArea(bbox);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readwrite\").objectStore(\"elements\");\r\n            const request = objectStore.put({ selector, bbox, area, ...record }, key);\r\n            request.addEventListener(\"success\", () => {\r\n                console.debug(`Saved ${selector}/${bbox} to database with ${record.elements.length} elements`);\r\n                resolve();\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    // Delete all saved nodes\r\n    async clear () {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const req = db.transaction(\"elements\", \"readwrite\").objectStore(\"elements\").clear();\r\n            req.onsuccess = resolve;\r\n            req.onerror = reject;\r\n        });\r\n    }\r\n}\r\n\r\nfunction makeKey (bbox, selector) {\r\n    const bkey = bbox.split(\",\").map(p => (+p).toFixed(3)).join(\",\");\r\n    return `${selector}/${bkey}`;\r\n}\r\n","import IDBElementDatabase from \"./database.idb\";\r\nimport { contains } from \"./bbox\";\r\nimport { matchSelector } from \"./Style\";\r\nimport { timeout } from './util';\r\n\r\n/** @typedef {import(\"./Style\").StyleSelector} StyleSelector */\r\n\r\nconst API_ROOT = require(\"./const\").API_ROOT;\r\n\r\nconst overpassRe = /^(node|way|rel(?:ation)?|area)/;\r\nconst recurRe = /^(way|rel(?:ation)?|area)/;\r\n\r\nexport class Overpass {\r\n    /** @param {string} bbox */\r\n    constructor (bbox=null) {\r\n        /** @type {Map<string, Promise<OverpassElement[]>>} */\r\n        this.elements = new Map();\r\n        this.bbox = bbox;\r\n        this.database = new IDBElementDatabase();\r\n        /** @type {{ [url: string]: Promise<OverpassElement[]> }} */\r\n        this.fetchMap = {};\r\n        /** @type {Promise<any>} */\r\n        this.currentJob = Promise.resolve();\r\n    }\r\n\r\n    setBBox (bbox) {\r\n        // If the new bbox is completely contained within the\r\n        // old one then we don't need to clear our cache\r\n        if (this.bbox && !contains(this.bbox, bbox)) {\r\n            this.elements.clear();\r\n        }\r\n        this.bbox = bbox;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     */\r\n    async preLoadElements (selectors) {\r\n        return this.jobs(async () => {\r\n            const { bbox } = this;\r\n\r\n            if (!this.bbox) {\r\n                throw Error(\"No bounding box specified\");\r\n            }\r\n\r\n            // Create set of selectors\r\n            /** @type {{ [key: string]: StyleSelector }} */\r\n            const set = {};\r\n            selectors.forEach(s => set[mapSelector(s)] = s);\r\n\r\n            console.debug(`Preloading Elements: ${selectors.length} requested (${Object.keys(set).length} unique)`);\r\n\r\n            // Remove non-overpass selectors\r\n            for (const [key, selector] of Object.entries(set)) {\r\n                if (!overpassRe.test(selector.type)) delete set[key];\r\n            }\r\n            console.debug(`Preloading Elements: ${Object.keys(set).length} are Overpass Elements`);\r\n\r\n            // Remove selectors found in local hash map cache\r\n            for (const key of Object.keys(set)) {\r\n                if (this.elements.has(key)) delete set[key];\r\n            }\r\n            console.debug(`Preloading Elements: ${Object.keys(set).length} not in HashMap`);\r\n\r\n            // Remove selectors which were found in database\r\n            await Promise.all(Object.keys(set).map(s => {\r\n                return this.database.searchElements(bbox, s)\r\n                    .then(els => {\r\n                        if (els) delete set[s];\r\n                    });\r\n            }));\r\n            console.debug(`Preloading Elements: ${Object.keys(set).length} not in Database`);\r\n\r\n            if (Object.keys(set).length === 0) return 0;\r\n\r\n            const elements = await this.tryQuery(Object.values(set));\r\n\r\n            console.log(`Preloading Elements: Fetched ${elements.length} elements from Server`);\r\n\r\n            // Prepare node map\r\n            /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n            const nodeMap = {};\r\n            elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n            // Prepare way map\r\n            /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n            const wayMap = {};\r\n            elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n            await Promise.all(Object.values(set).map(selector => {\r\n                const out = elements.filter(el => matchSelector(selector, el, false));\r\n\r\n                if (selector.type === \"relation\") {\r\n                    /** @type {OverpassRelElement[]} */\r\n                    const rels = (out.slice());\r\n\r\n                    /** @type {OverpassWayElement[]} */\r\n                    const ways = [];\r\n\r\n                    for (const rel of rels) {\r\n                        const refs = rel.members.map(m => m.ref);\r\n                        ways.push(...refs.map(id => wayMap[id]));\r\n                    }\r\n\r\n                    out.push(...ways);\r\n\r\n                    for (const way of ways) {\r\n                        out.push(...way.nodes.map(id => nodeMap[id]));\r\n                    }\r\n\r\n                } else if (selector.type === \"way\" || selector.type === \"area\") {\r\n                    /** @type {OverpassWayElement[]} */\r\n                    const ways = (out.slice());\r\n\r\n                    for (const way of ways) {\r\n                        out.push(...way.nodes.map(id => nodeMap[id]));\r\n                    }\r\n                }\r\n\r\n                this.elements.set(mapSelector(selector), Promise.resolve(out));\r\n                return this.database.saveElements(bbox, mapSelector(selector), { elements: out, cached: Date.now() });\r\n            }));\r\n\r\n            return elements.length;\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    query (selectors) {\r\n        if (this.bbox.split(\",\").map(p => +p).some(isNaN)) throw Error(\"Invalid BBox\");\r\n\r\n        const sMap = selectors.map(mapSelectorForQuery);\r\n        const query = `[out:json][bbox];\\n(${sMap.join(\"\")}\\n);\\nout;`\r\n        const url = `${API_ROOT}?data=${query.replace(/\\s/,\"\")}&bbox=${clampBBox(this.bbox)}`;\r\n\r\n        if (!this.fetchMap[url]) {;\r\n            this.fetchMap[url] = fetch(url.toString()).then(r => r.ok ? r.json() : Promise.reject(r.status)).then(r => r.elements);\r\n\r\n            this.fetchMap[url].finally(() => delete this.fetchMap[url]);\r\n        }\r\n\r\n        return this.fetchMap[url];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     * @param {number} tries\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    tryQuery (selectors, tries=10) {\r\n        return this.query(selectors).catch(e => {\r\n            if (e !== 429) throw Error(\"Bad Response\");\r\n\r\n            if (tries > 0) {\r\n                return timeout(10000).then(() => this.tryQuery(selectors, tries - 1))\r\n            }\r\n\r\n            throw Error(\"Too many retries fetching data\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {import(\"./Style\").StyleSelector} selector\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    async getElements (selector) {\r\n        if (!overpassRe.test(selector.type)) return;\r\n\r\n        if (!this.bbox) return;\r\n\r\n        const s = mapSelector(selector);\r\n        if (this.elements.has(s)) return this.elements.get(s);\r\n\r\n        const dbResult = await this.database.getElements(this.bbox, s);\r\n\r\n        if (dbResult) {\r\n            const { elements } = dbResult;\r\n            this.elements.set(s, Promise.resolve(elements));\r\n            return elements;\r\n        }\r\n\r\n        const dbSearchResult = await this.database.searchElements(this.bbox, s);\r\n\r\n        if (dbSearchResult) {\r\n            const elements = this.database.getElementsByKey(dbSearchResult).then(r => r.elements);\r\n            this.elements.set(s, elements);\r\n            return elements;\r\n        }\r\n\r\n        const p = this.tryQuery([selector]);\r\n\r\n        this.elements.set(s, p);\r\n\r\n        p.catch(() => this.elements.delete(s));\r\n\r\n        p.then(elements => {\r\n            this.database.saveElements(this.bbox, s, { elements, cached: Date.now() });\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    jobs (fn) {\r\n        this.currentJob = this.currentJob.then(() => fn());\r\n\r\n        return this.currentJob;\r\n    }\r\n\r\n    // Delete everything from cache\r\n    clearCache (database = false) {\r\n        this.elements.clear();\r\n        if (database)\r\n            return this.database.clear();\r\n    }\r\n}\r\n\r\n/** @param {StyleSelector} selector */\r\nfunction mapSelectorForQuery (selector) {\r\n    const recur = recurRe.test(selector.type) ? \">;\" : \"\";\r\n    return `${mapSelector(selector)};${recur}`;\r\n}\r\n\r\n/** @param {StyleSelector} selector */\r\nfunction mapSelector (selector) {\r\n    const type = selector.type === \"area\" ? \"way\" : selector.type;\r\n    const tags = Object.entries(selector.tags).map(([k,v]) => {\r\n        return (/^[<=>]+/.test(v) || v === \"*\") ? `[${k}]` : `[${k}=${v}]`;\r\n    });\r\n    return `${type}${tags.join(\"\")}`;\r\n}\r\n\r\n/** @typedef {import('./Style.js').StyleRule} StyleRule */\r\n\r\n/**\r\n * @typedef {OverpassNodeElement|OverpassWayElement|OverpassAreaElement|OverpassRelElement} OverpassElement\r\n */\r\n\r\n/**\r\n * @typedef OverpassNodeElement\r\n * @property {number} id\r\n * @property {\"node\"} type\r\n * @property {number} lon\r\n * @property {number} lat\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassWayElement\r\n * @property {number} id\r\n * @property {\"way\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassAreaElement\r\n * @property {number} id\r\n * @property {\"area\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassRelElement\r\n * @property {number} id\r\n * @property {\"relation\"} type\r\n * @property {{ ref: number, role: \"inner\"|\"outer\", type: \"node\"|\"way\"|\"relation\" }[]} members\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\nfunction clampBBox (bbox) {\r\n    const p = bbox.split(\",\").map(p => +p);\r\n    return `${clamp(p[0], -180, 180)},${clamp(p[1], -90, 90)},${clamp(p[2], -180, 180)},${clamp(p[3], -90, 90)}`;\r\n}\r\n\r\nfunction clamp (v, min, max) {\r\n    return Math.max(min, Math.min(v, max));\r\n}","import { useState, useEffect } from 'react';\r\n\r\n/**\r\n * @link https://usehooks.com/useDebounce/\r\n * @param {any} value \r\n * @param {number} delay \r\n */\r\nexport function useDebounce(value, delay) {\r\n    // State and setters for debounced value\r\n    const [debouncedValue, setDebouncedValue] = useState(value);\r\n  \r\n    useEffect(\r\n      () => {\r\n        // Update debounced value after delay\r\n        const handler = setTimeout(() => {\r\n          setDebouncedValue(value);\r\n        }, delay);\r\n  \r\n        // Cancel the timeout if value changes (also on delay change or unmount)\r\n        // This is how we prevent debounced value from updating if value is changed ...\r\n        // .. within the delay period. Timeout gets cleared and restarted.\r\n        return () => {\r\n          clearTimeout(handler);\r\n        };\r\n      },\r\n      [value, delay] // Only re-call effect if value or delay changes\r\n    );\r\n  \r\n    return debouncedValue;\r\n  }","import React from 'react';\r\n\r\n/**\r\n * \r\n * @param {{ value: string, onChange: (event) => void, [key: string]: any }} param0 \r\n */\r\nexport default function Textarea ({ value, onChange, ...otherProps }) {\r\n    /**\r\n     * @param {React.KeyboardEvent<HTMLTextAreaElement>} event\r\n     */\r\n    function handleKeyDown (event) {\r\n        const { key, currentTarget, shiftKey } = event;\r\n    \r\n        if (key === \"Tab\") {\r\n            event.preventDefault();\r\n    \r\n            const i = currentTarget.selectionStart;\r\n            const lineStart = value.lastIndexOf(\"\\n\", i-1) + 1;\r\n\r\n            if (shiftKey) {\r\n                if (value.substr(lineStart, 4) === \"    \") {\r\n                    const newValue = value.substring(0,lineStart) + value.substring(lineStart + 4);\r\n                    onChange(newValue);\r\n                    \r\n                    setTimeout(() => currentTarget.setSelectionRange(i - 4, i - 4), 10);\r\n                }\r\n            } else {\r\n                const linePos = i - lineStart;\r\n                const x = 4 - linePos % 4;\r\n\r\n                const newValue = value.substring(0,i) + \"    \".substring(0,x) + value.substring(i);\r\n                onChange(newValue);\r\n                \r\n                setTimeout(() => currentTarget.setSelectionRange(i + x, i + x), 10);\r\n            }\r\n        }\r\n    \r\n        else if (key === \"Enter\") {\r\n            event.preventDefault();\r\n\r\n            const i = currentTarget.selectionStart;\r\n            const addIndent = value[i-1] === \"{\";\r\n            const lineStart = value.lastIndexOf(\"\\n\", i-1) + 1;\r\n            const match = value.substring(lineStart, i).match(/^ */);\r\n            const newPos = i + match[0].length + 1 + (addIndent ? 4 : 0);\r\n\r\n            const newValue = value.substring(0,i) + \"\\n\" + (addIndent ? \"    \" : \"\") + match[0] + value.substring(i);\r\n            onChange(newValue);\r\n\r\n            setTimeout(() => currentTarget.setSelectionRange(newPos, newPos), 10);\r\n        }\r\n    }\r\n\r\n    return <textarea value={value} onChange={e => onChange(e.target.value)} onKeyDown={handleKeyDown} {...otherProps} />;\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport useSavedState from './useSavedState';\r\nimport { parseStyle, expandRules } from './Style';\r\nimport CanvasRender from './canvas-render';\r\nimport WorkerRender from './WorkerRenderer';\r\nimport SVGRender from './svg-render';\r\nimport { Overpass } from './Overpass';\r\nimport { useDebounce } from './useDebounce';\r\nimport { makeBBox } from './bbox';\r\nimport useGeolocation from './useGeolocation';\r\nimport Textarea from './Textarea';\r\nimport useDeepCompareEffect from 'use-deep-compare-effect';\r\nimport CollisionSystem from './CollisionSystem';\r\nimport { Console } from 'app-console';\r\n\r\nimport 'app-console/dist/index.css';\r\n\r\nconst WORKER_ENABLED_KEY = \"worker-enabled\";\r\n/** @typedef {import('./MapRenderer').default} MapRenderer */\r\n\r\nfunction App() {\r\n  const [ style, setStyle ] = useSavedState(\"USER_STYLE\", \"node[amenity=post_box] {\\n\\tfill: black;\\n\\tsize: 2;\\n}\");\r\n  const [ centre, setCentre ] = useSavedState(\"USER_CENTRE\", \"7.1,50.7\");\r\n  const [ zoom, setZoom ] = useSavedState(\"USER_SCALE\", 14);\r\n  const current = useGeolocation();\r\n  /** @type {React.MutableRefObject<HTMLCanvasElement>} */\r\n  const canvasRef = React.useRef();\r\n  /** @type {React.MutableRefObject<Overpass>} */\r\n  const overpassRef = React.useRef(new Overpass());\r\n  /** @type {[ string, (string) => void ]} */\r\n  const [ status, setStatus ] = React.useState(null);\r\n  const [ error, setError ] = React.useState(\"\");\r\n  const [ downloading, setDownloading ] = React.useState(false);\r\n  const [ progress, setProgress ] = React.useState(0);\r\n  /** @type {React.MutableRefObject<MapRenderer>} */\r\n  const rendererRef = React.useRef();\r\n  const shellContextRef = React.useRef({\r\n    executables: {\r\n      \"clear-cache\": () => {\r\n        if (overpassRef.current) {\r\n          overpassRef.current.clearCache(true);\r\n        }\r\n      },\r\n    },\r\n  });\r\n  const [ renderPending, forceRender ] = useForceRender();\r\n  React.useEffect(() => {\r\n    const { current: { executables } } = shellContextRef;\r\n    executables.render = forceRender;\r\n    executables.get = name => {\r\n      if (name === \"centre\") return centre;\r\n      if (name === \"zoom\") return zoom;\r\n      if (name === \"myPos\") return `${current.coords.longitude},${current.coords.latitude}`;\r\n      return void 0;\r\n    };\r\n    executables.set = (name, value) => {\r\n      if (name === \"centre\") { setCentre(value); return true; }\r\n      if (name === \"zoom\") { setZoom(value); return true; }\r\n      return false;\r\n    };\r\n    executables[\"enable-worker\"] = () => {\r\n      localStorage.setItem(WORKER_ENABLED_KEY, \"on\");\r\n      window.location.reload();\r\n    };\r\n    executables[\"disable-worker\"] = () => {\r\n      localStorage.removeItem(WORKER_ENABLED_KEY);\r\n      window.location.reload();\r\n    };\r\n  }, [ forceRender, centre, zoom, setCentre, setZoom, current ]);\r\n  const [ consoleVisible, showConsole ] = React.useState(false);\r\n\r\n  const { clientWidth, clientHeight } = canvasRef.current || { clientWidth: 1000, clientHeight: 1000 };\r\n\r\n  const width = clientWidth * devicePixelRatio;\r\n  const height = clientHeight * devicePixelRatio;\r\n\r\n  const debouncedCentre = useDebounce(centre, 500);\r\n  const debouncedZoom = useDebounce(zoom, 500);\r\n\r\n  const bbox = React.useMemo(() => makeBBox(debouncedCentre.split(\",\").map(p => +p), debouncedZoom, [clientWidth, clientHeight]), [debouncedCentre, debouncedZoom, clientWidth, clientHeight]);\r\n\r\n  const debouncedStyle = useDebounce(style, 500);\r\n\r\n  const parsedStyle = React.useMemo(() => parseStyle(debouncedStyle), [debouncedStyle]);\r\n\r\n  React.useEffect(() => overpassRef.current.setBBox(bbox), [bbox]);\r\n\r\n  /** @type {[number, number]} */\r\n  const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\r\n\r\n  /** @type {import('./MapRenderer').MapContext} */\r\n  const context = { centre: centrePoint, zoom: debouncedZoom, bbox, scale: devicePixelRatio, width, height };\r\n  const rules = expandRules(parsedStyle.rules, context);\r\n\r\n  React.useEffect(() => {\r\n    /** @type {(e: KeyboardEvent) => void} */\r\n    const callback = e => e.key === \"k\" && e.ctrlKey && e.altKey && showConsole(!consoleVisible);\r\n\r\n    document.addEventListener(\"keyup\", callback);\r\n\r\n    return () => document.removeEventListener(\"keyup\", callback);\r\n  }, [consoleVisible]);\r\n\r\n  /**\r\n   * @param {React.MouseEvent<HTMLCanvasElement, MouseEvent>} e\r\n   */\r\n  function handleDoubleClick (e) {\r\n    const { offsetX: x, offsetY: y, ctrlKey, shiftKey, altKey } = e.nativeEvent;\r\n\r\n    // Flip client height so y-axis is negative\r\n    // @ts-ignore\r\n    const { x: lon, y: lat } = interpolateBox({ x, y }, [0, clientHeight, clientWidth, 0], parseBBox(bbox));\r\n    setCentre(cleanupPoint(lon, lat));\r\n\r\n    const dz = altKey ? 3 : 1;\r\n    if (ctrlKey) setZoom(zoom + dz);\r\n    else if (shiftKey) setZoom(zoom - dz);\r\n  }\r\n\r\n  if (rules.some(r => r.selector.type === \"current\")) {\r\n    const { coords: { longitude, latitude } } = current || { coords: {} };\r\n    context.current = { longitude, latitude };\r\n  }\r\n\r\n  if (canvasRef.current && !rendererRef.current) {\r\n    if (window.Worker && canvasRef.current.transferControlToOffscreen && localStorage.getItem(WORKER_ENABLED_KEY)) {\r\n      rendererRef.current = new WorkerRender(canvasRef.current);\r\n    } else {\r\n      rendererRef.current = new CanvasRender(canvasRef.current);\r\n    }\r\n  }\r\n\r\n  // Refetch/Render map when bbox, or style change\r\n  useDeepCompareEffect(() => {\r\n    // Double pointer to update inside render function scope\r\n    let current = { currentEffect: true };\r\n\r\n    render(rules, overpassRef.current, rendererRef.current, context, setStatus, setError, setProgress, current);\r\n\r\n    return () => { current.currentEffect = false; };\r\n  }, [debouncedCentre, debouncedZoom, rules, context, renderPending]);\r\n\r\n  /**\r\n   * @param {number} dX\r\n   * @param {number} dY\r\n   */\r\n  function move (dX, dY) {\r\n    /** @type {[number, number]} */\r\n    const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\r\n    const bb = bbox.split(\",\").map(p => +p);\r\n    const stepSizeX = (bb[2] - bb[0]) / 2;\r\n    const stepSizeY = (bb[3] - bb[1]) / 2;\r\n    const newCentre = cleanupPoint(centrePoint[0] + dX * stepSizeX, centrePoint[1] + dY * stepSizeY);\r\n    setCentre(newCentre);\r\n  }\r\n\r\n  /**\r\n   * @param {string} type\r\n   */\r\n  function handleDownload (type) {\r\n    if (!downloading) {\r\n      setDownloading(true);\r\n      const cb = () => setDownloading(false);\r\n      if (type === \"png\") {\r\n        downloadPNG(canvasRef.current, cb);\r\n      } else {\r\n        downloadSVG(context, parsedStyle, overpassRef.current, cb);\r\n      }\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"sidebar\">\r\n        <div className=\"controls\">\r\n          <button onClick={() => move(-1,0)}></button>\r\n          <button onClick={() => move(1,0)}></button>\r\n          <button onClick={() => move(0,1)}></button>\r\n          <button onClick={() => move(0,-1)}></button>\r\n          <button onClick={() => setZoom(+cleanup(zoom + 1))}></button>\r\n          <button onClick={() => setZoom(+cleanup(zoom - 1))}></button>\r\n          { current && <button onClick={() => setCentre(`${current.coords.longitude},${current.coords.latitude}`)}></button> }\r\n          <button onClick={() => handleDownload(\"png\")} disabled={downloading}> PNG</button>\r\n          <button onClick={() => handleDownload(\"svg\")} disabled={downloading}> SVG</button>\r\n        </div>\r\n        <label>Centre <input value={centre} onChange={e => setCentre(e.target.value)} /></label>\r\n        <label>Zoom <input type=\"number\" value={zoom} onChange={e => setZoom(+e.target.value)} /></label>\r\n        <Textarea value={style} onChange={setStyle} style={{flex:1}} spellCheck={false} />\r\n        <div className=\"status-area\">\r\n          { status && <p>{status}</p> }\r\n          { progress > 0 && <progress value={progress} />}\r\n          { error && <p style={{color:\"red\"}}>{error}</p> }\r\n        </div>\r\n        { consoleVisible && <Console context={shellContextRef.current} style={{ maxHeight: 200 }} /> }\r\n      </div>\r\n      <canvas ref={canvasRef} onDoubleClick={handleDoubleClick} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n/**\r\n * @param {HTMLCanvasElement} canvas\r\n */\r\nfunction downloadPNG (canvas, callback=null) {\r\n  canvas.toBlob(blob => {\r\n    blobDownload(blob, \"map.png\");\r\n    if (callback) callback();\r\n  });\r\n}\r\n\r\nasync function downloadSVG (context, style, overpass, callback=null) {\r\n  const rules = expandRules(style.rules, context);\r\n\r\n  const map = rules.map(rule => {\r\n    return {\r\n      rule,\r\n      promise: overpass.getElements(rule.selector),\r\n    }\r\n  });\r\n\r\n  CollisionSystem.getCollisionSystem().clear();\r\n\r\n  const svgRender = new SVGRender(context.width, context.height);\r\n\r\n  for (const item of map) {\r\n    const elements = await item.promise;\r\n    svgRender.renderRule(context, item.rule, elements);\r\n  }\r\n\r\n  const blob = svgRender.toBlob();\r\n  blobDownload(blob, \"map.svg\");\r\n\r\n  if (callback) callback();\r\n}\r\n\r\nfunction blobDownload (blob, filename) {\r\n  const url = URL.createObjectURL(blob);\r\n  const a = document.createElement(\"a\");\r\n  a.download = filename;\r\n  a.href = url;\r\n  document.body.appendChild(a);\r\n  a.click();\r\n  document.body.removeChild(a);\r\n  URL.revokeObjectURL(url);\r\n}\r\n\r\n/**\r\n * @param {number} n\r\n */\r\nfunction cleanup (n) {\r\n  return n.toFixed(5).replace(/^0+|0+$/g, \"\");\r\n}\r\n\r\nfunction cleanupPoint (x, y) {\r\n  return `${cleanup(x)},${cleanup(y)}`;\r\n}\r\n\r\nfunction useForceRender () {\r\n  const [ counter, setCounter ] = React.useState(0);\r\n\r\n  return [ counter, () => setCounter(c => c + 1) ];\r\n}\r\n\r\n/**\r\n * @param {import('./Style').StyleRule[]} [rules]\r\n * @param {Overpass} [overpass]\r\n * @param {MapRenderer} [renderer]\r\n * @param {import('./MapRenderer').MapContext} [context]\r\n * @param {(arg0: string) => void} [setStatus]\r\n * @param {(arg0: string) => void} [setError]\r\n * @param {(arg0: number) => void} [setProgress]\r\n * @param {{ currentEffect: any; }} [current]\r\n */\r\nasync function render (rules, overpass, renderer, context, setStatus, setError, setProgress, current) {\r\n  setStatus(\"Fetching...\");\r\n  setError(\"\");\r\n\r\n  try {\r\n    const count = await overpass.preLoadElements(rules.map(r => r.selector));\r\n\r\n    if (!current.currentEffect) return;\r\n\r\n    // Check if we're already preloading something\r\n    if (count < 0) return;\r\n\r\n    if (count === 0)\r\n      setStatus(`Rendering...`);\r\n    else\r\n      setStatus(`Rendering ${count} elements...`);\r\n\r\n    const map = rules.map(rule => {\r\n      return {\r\n        rule,\r\n        promise: renderer instanceof WorkerRender ? Promise.resolve() : overpass.getElements(rule.selector),\r\n      }\r\n    });\r\n\r\n    CollisionSystem.getCollisionSystem().clear();\r\n\r\n    if (renderer) {\r\n      if (!current.currentEffect) return;\r\n\r\n      renderer.clear(context);\r\n\r\n      let count = 0;\r\n      // setProgress(0);\r\n\r\n      for (const item of map) {\r\n        const prefix = `${++count}/${map.length}`;\r\n\r\n        console.debug(`${prefix} Loading elements for ${item.rule.selector}`);\r\n        const elements = await item.promise;\r\n\r\n        if (!current.currentEffect) return;\r\n\r\n        console.debug(`${prefix} Rendering ${item.rule.selector}`);\r\n\r\n        renderer.renderRule(context, item.rule, elements);\r\n\r\n        // setProgress(count/map.length);\r\n      }\r\n      // setProgress(0);\r\n\r\n      console.debug(`Rendered!`);\r\n    }\r\n\r\n    setStatus(null);\r\n  } catch (e) {\r\n    setError(\"Error Fetching\");\r\n    setStatus(null);\r\n    console.log(e);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} bbox\r\n */\r\nfunction parseBBox (bbox) {\r\n  return bbox.split(\",\").map(s => +s);\r\n}\r\n\r\n\r\n/**\r\n * @param {{ x: number, y: number }} param0\r\n * @param {[number, number, number, number]} from\r\n * @param {[number, number, number, number]} to\r\n */\r\nfunction interpolateBox ({x, y}, from, to) {\r\n  const fx = (x - from[0]) / (from[2] - from[0]);\r\n  const fy = (y - from[1]) / (from[3] - from[1]);\r\n\r\n  const tw = to[2] - to[0];\r\n  const th = to[3] - to[1];\r\n\r\n  return { x: fx * tw + to[0], y: fy * th+ to[1] };\r\n}","import React from 'react';\r\n\r\nexport default function useGeolocation () {\r\n    /** @type {[Position, (newPos: Position) => void]} */\r\n    const [ loc, setLoc ] = React.useState();\r\n\r\n    React.useEffect(() => { navigator.geolocation.getCurrentPosition(setLoc) }, []);\r\n\r\n    React.useEffect(() => {\r\n        const id = navigator.geolocation.watchPosition(setLoc);\r\n\r\n        return () => navigator.geolocation.clearWatch(id);\r\n    }, []);\r\n\r\n    return loc;\r\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}