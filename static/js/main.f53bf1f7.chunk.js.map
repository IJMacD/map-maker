{"version":3,"sources":["const.js","useSavedState.js","Style.js","geometry.js","render/parseStrokeFill.js","render/renderText.js","render/transform.js","render/renderPoint.js","render/util.js","CollisionSystem.js","render/renderAreaLine.js","render/renderLine.js","render/renderArea.js","bbox.js","render/renderGridlines.js","render/renderPsuedoElement.js","render/matchPsuedoClasses.js","render/renderRelation.js","render/index.js","database.idb.js","util.js","Overpass.js","useDebounce.js","Textarea.js","App.js","useGeolocation.js","serviceWorker.js","index.js"],"names":["API_ROOT","useSavedState","key","initalState","React","useState","saved","localStorage","getItem","JSON","parse","e","state","setState","newState","setItem","stringify","StyleSelector","type","tags","pseudoClasses","pseudoElement","this","Object","entries","map","k","v","join","matchSelector","selector","element","match","value","parseMedia","mediaText","match2","re","out","mediaQueries","index","re2","exec","predicate","makePredicate","length","parseRules","substring","rules","push","console","log","ruleText","declarations","split","s","trim","filter","forEach","i","indexOf","property","selectors","parseMultiple","expandRules","context","rule","testPredicate","left","operator","right","Function","op","COMPARE","text","m","tagText","m2","re3","m3","params","test","name","re4","m4","x","a","b","rectToPoints","y","width","height","getCrossProductArea","points","sum","getArea","Math","abs","isAntiClockwise","isConvex","l","sign","c","next","isSelfClosing","f","getLength","dx","dy","sqrt","setStrokeFill","ctx","lineWidth","fillStyle","strokeStyle","mutedStyle","replace","ss","repeat","sm","devicePixelRatio","parseStrokeFill","renderText","content","getContent","setFont","textWidth","measureText","strokeText","fillText","fontSize","fontWeight","fontFamily","font","applyTransform","dpr","r","t","trans","parseFloat","unit","transform","p","PI","rotate","scale","translate","tan","valueY","renderPoint","save","beginPath","ellipse","fill","stroke","drawPath","urlRe","url","img","Image","src","w","h","addEventListener","globalSetup","isNaN","drawImage","restore","pathSpec","first","prev","segs","x2","y2","x3","y3","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","mercatorProjection","centre","cLon","cLat","tileCount","pow","hPixelsPerDeg","vPixelsPerDeg","QUARTER_PI","cX","cY","cLatPrime","lon","lat","E","N","getCentrePoint","boundingBox","getBoundingBox","getMidPoint","floor","minMax","reduce","point","min","max","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","CollisionSystem","sets","set","box","intersects","singleton","boxA","boxB","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","renderAreaLine","getPoint","collisionSystem","getCollisionSystem","add","policy","offsetX","offsetY","cp","renderLine","renderArea","contains","areaA","areaB","Ax1","Ay1","Ax2","Ay2","Bx1","By1","Bx2","By2","bbox","parts","makeBBox","size","dLon","dLat","toFixed","renderGridlines","projection","vertical","find","horizontal","step","round","sigFigs","ceil","log10","xmin","xmax","ymin","ymax","id","nodes","j","renderPsuedoElement","getAveragePoint","bounding","desc","actualBoundingBoxDescent","asc","actualBoundingBoxAscent","padding","boundPoints","matchPsuedoClasses","includesPseudoClass","hasPseudoClasses","pc","area","some","renderRelation","wayMap","nodeMap","outerWays","members","role","ref","innerWays","started","clearMap","canvas","clientWidth","clientHeight","renderMap","elements","n","getContext","current","coords","longitude","latitude","el","globalAlpha","top","IDBElementDatabase","request","indexedDB","open","ev","db","target","result","createObjectStore","keyPath","createIndex","unique","Promise","resolve","reject","store","transaction","objectStore","put","get","ids","all","getNode","makeKey","getElementsByKey","range","IDBKeyRange","bound","MAX_VALUE","openKeyCursor","count","cursor","primaryKey","keyBBox","debug","continue","record","bkey","timeout","duration","setTimeout","require","overpassRe","recurRe","Overpass","Map","database","fetchMap","clear","mapSelector","keys","has","searchElements","then","els","tryQuery","values","rels","slice","ways","refs","way","saveElements","cached","Date","now","Error","sMap","mapSelectorForQuery","query","clamp","clampBBox","fetch","toString","ok","json","status","finally","tries","catch","getElements","dbResult","dbSearchResult","delete","recur","useDebounce","delay","debouncedValue","setDebouncedValue","useEffect","handler","clearTimeout","Textarea","onChange","otherProps","onKeyDown","event","currentTarget","shiftKey","preventDefault","selectionStart","lineStart","lastIndexOf","substr","newValue","setSelectionRange","addIndent","newPos","App","style","setStyle","setCentre","setScale","loc","setLoc","navigator","geolocation","getCurrentPosition","watchPosition","clearWatch","useGeolocation","canvasRef","useRef","overpassRef","fetching","setFetching","error","setError","debouncedCentre","debouncedScale","useMemo","debouncedStyle","parsedStyle","styleText","rulesResult","mediaResult","parseStyle","move","dX","dY","centrePoint","bb","stepSizeX","stepSizeY","newCentre","setBBox","useDeepCompareEffect","zoom","preLoadElements","promise","item","run","className","onClick","flex","spellCheck","color","Boolean","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"2LACA,gDAAO,IAAMA,EAAW,+C,+HCOT,SAASC,EAAeC,EAAKC,GAAc,IAAD,EACzBC,IAAMC,UAAS,WACvC,IAAMC,EAAQC,aAAaC,QAAQN,GAEnC,GAAII,EACA,IACIH,EAAcM,KAAKC,MAAMJ,GAC3B,MAAOK,IAGb,OAAOR,KAV0C,mBAC7CS,EAD6C,KACtCC,EADsC,KAarD,MAAO,CACHD,EACA,SAAAE,GACIP,aAAaQ,QAAQb,EAAKO,KAAKO,UAAUF,IACzCD,EAASC,K,yBCHRG,EAAb,WAOI,WAAaC,EAAMC,GAA6C,IAAvCC,EAAsC,uDAAxB,GAAIC,EAAoB,uDAAN,KAAM,oBAC7DC,KAAKJ,KAAOA,EACZI,KAAKH,KAAOA,EACZG,KAAKF,cAAgBA,EACrBE,KAAKD,cAAgBA,EAX3B,uDAeM,MAAM,GAAN,OAAUC,KAAKJ,MAAf,OAAsBK,OAAOC,QAAQF,KAAKH,MAAMM,KAAI,mCAAEC,EAAF,KAAIC,EAAJ,sBAAeD,EAAf,YAAoBC,EAApB,QAA0BC,KAAK,SAfzF,KAkHO,SAASC,EAAeC,EAAUC,GACvC,GAAIA,EAAQb,OAASY,EAASZ,OAA4B,SAAlBY,EAASZ,MAAoC,QAAjBa,EAAQb,MAAiB,OAAO,EAIpG,IAFA,IAAIc,GAAQ,EAEZ,MAA2BT,OAAOC,QAAQM,EAASX,MAAnD,eAA0D,CAAC,IAAD,sBAA9CjB,EAA8C,KAAzC+B,EAAyC,KACxD,IAAKF,EAAQZ,MAAQY,EAAQZ,KAAKjB,KAAS+B,EAAO,CAChDD,GAAQ,EACR,OAIJ,OAAOA,EAsCT,SAASE,EAAYC,GASnB,IARA,IAGIH,EAGAI,EANEC,EAAK,uGAELC,EAAM,CAAEC,aAAc,GAAIC,MAAO,GAGjCC,EAAM,QAGLT,EAAQK,EAAGK,KAAKP,IAAY,CACjC,IAAMQ,EAAYC,EAAcZ,GAEhCM,EAAIE,OAASR,EAAM,GAAGa,OAHW,MAORC,EAFzBX,EAAYA,EAAUY,UAAUf,EAAM,GAAGa,SAEjCG,EAPyB,EAOzBA,MAAOR,EAPkB,EAOlBA,MAEfF,EAAIE,OAASA,EAEbL,EAAYA,EAAUY,UAAUP,IAEhCJ,EAASK,EAAIC,KAAKP,KAGhBG,EAAIC,aAAaU,KAAK,CACpB/B,KAAM,QACNyB,YACAK,UAGFV,EAAIE,OAASJ,EAAO,GAAGS,QAGvBK,QAAQC,IAAI,4BAIhB,OAAOb,EAGT,SAASQ,EAAYM,GAMnB,IALA,IACIpB,EADEK,EAAK,4BAGLC,EAAM,CAAEU,MAAO,GAAIR,MAAO,GAJH,aAQ3B,IAAMa,EAAe,GAErBrB,EAAM,GAAGsB,MAAM,KAAK7B,KAAI,SAAA8B,GAAC,OAAIA,EAAEC,UAAQC,QAAO,SAAAF,GAAC,OAAIA,KAAGG,SAAQ,SAAAH,GAE5D,IAAMI,EAAIJ,EAAEK,QAAQ,KACdC,EAAWN,EAAER,UAAU,EAAEY,GAAGH,OAC5BvB,EAAQsB,EAAER,UAAUY,EAAE,GAAGH,OAC/BH,EAAaQ,GAAY5B,KAG3B,IAAM6B,EAAY7C,EAAc8C,cAAc/B,EAAM,IAEhD8B,EAAUjB,QACZP,EAAIU,MAAMC,KAAK,CACb/B,KAAM,OACN4C,YACAT,iBAIJf,EAAIE,OAASR,EAAM,GAAGa,OAEtBO,EAAWA,EAASL,UAAUf,EAAM,GAAGa,SAxBnCb,EAAQK,EAAGK,KAAKU,IAAY,IA2BlC,OAAOd,EAQF,SAAS0B,EAAahB,EAAOiB,GAClC,IAD2C,EACrC3B,EAAM,GAD+B,cAExBU,GAFwB,IAE3C,2BAA0B,CAAC,IAAhBkB,EAAe,QACxB,GAAkB,SAAdA,EAAKhD,KAAiB,CAAC,IAAD,EAChBmC,EAAiBa,EAAjBb,aADgB,cAEDa,EAAKJ,WAFJ,IAExB,2BAAuC,CAAC,IAA7BhC,EAA4B,QACrCQ,EAAIW,KAAK,CAAEnB,WAAUuB,kBAHC,oCAMpBc,EAAcD,EAAKvB,UAAWsB,IAChC3B,EAAIW,KAAJ,MAAAX,EAAG,YAAS0B,EAAYE,EAAKlB,MAAOiB,MAVC,8BAc3C,OAAO3B,EAGT,SAASM,EAAcZ,GAuBrB,OApBIA,EAAM,GAGI,CACVoC,KAAM,CAAEA,KAAMpC,EAAM,GAAIqC,SAAUrC,EAAM,GAAIsC,MAAOtC,EAAM,IACzDqC,SAAU,MACVC,MAAO,CAAEF,KAAMpC,EAAM,GAAIqC,SAAUrC,EAAM,GAAIsC,MAAOtC,EAAM,KAQhD,CACVoC,KAAMpC,EAAM,GACZqC,SAAUrC,EAAM,GAChBsC,MAAOtC,EAAM,IAYZ,SAASmC,EAAexB,GAAwB,IAAbsB,EAAY,uDAAJ,GAC5CG,EAAiC,kBAAnBzB,EAAUyB,MAA+C,kBAAnBzB,EAAUyB,KAChEzB,EAAUyB,KAAOD,EAAcxB,EAAUyB,KAAMH,GAC7CK,EAAmC,kBAApB3B,EAAU2B,OAAiD,kBAApB3B,EAAU2B,MAClE3B,EAAU2B,MAAQH,EAAcxB,EAAU2B,MAAOL,GAE/B,kBAATG,GAAqBA,KAAQH,IAElCA,EAAQG,aAAiBG,WAC3BN,EAAQG,GAAQH,EAAQG,MAE1BA,EAAOH,EAAQG,IAGI,kBAAVE,GAAsBA,KAASL,IAEpCA,EAAQK,aAAkBC,WAC5BN,EAAQK,GAASL,EAAQK,MAE3BA,EAAQL,EAAQK,IAGlB,IAAME,EAAKC,EAAQ9B,EAAU0B,UAE7B,QAAKG,GAEEA,EAAGJ,EAAME,GA9SlBrD,EAAcP,MAGd,SAAUgE,GACN,IACMC,EADK,eACEjC,KAAKgC,GAElB,IAAKC,EAAG,OAAO,KAEf,IAAIzD,EAAOyD,EAAE,GAEA,QAATzD,IACFA,EAAO,YAUT,IANA,IAAMC,EAAO,GAETyD,EAAUF,EAAK3B,UAAU4B,EAAE,GAAG9B,QAAQW,OAEpCf,EAAM,+BAEC,CACX,IAAMoC,EAAKpC,EAAIC,KAAKkC,GAEpB,IAAKC,EAAI,MAET1D,EAAK0D,EAAG,IAAMA,EAAG,GAEjBD,EAAUA,EAAQ7B,UAAU8B,EAAG,GAAGhC,QAQpC,IAJA,IAAMzB,EAAgB,GAEhB0D,EAAM,8BAhCA,aAmCV,IAAMC,EAAKD,EAAIpC,KAAKkC,GAEpB,IAAKG,EAAI,cAET,IAAM1C,EAAK,sFACL2C,EAASD,EAAG,GAAKA,EAAG,GAAGzB,MAAM,KAAK7B,KAAI,SAAA8B,GAAC,OAAIlB,EAAG4C,KAAK1B,GAAKX,EAAcP,EAAGK,KAAKa,IAAMA,KAAK,GAC/FnC,EAAc6B,KAAK,CAAEiC,KAAMH,EAAG,GAAIC,WAElCJ,EAAUA,EAAQ7B,UAAUgC,EAAG,GAAGlC,WATvB,kBAGF,MASX,IAAIxB,EAAgB,KAEd8D,EAAM,gBAEZ,GAAIA,EAAIF,KAAKL,GAAU,CACrB,IAAMQ,EAAKD,EAAIzC,KAAKkC,GAEpBvD,EAAgB+D,EAAG,GAEnBR,EAAUA,EAAQ7B,UAAUqC,EAAG,GAAGvC,QAGpC,OAAI+B,EAAQ/B,QACVK,QAAQC,IAAR,4BAAiCuB,EAAjC,8BAA2DE,EAA3D,MACO,MAGF,IAAI3D,EAAcC,EAAMC,EAAMC,EAAeC,IAOxDJ,EAAc8C,cAAgB,SAAUW,GACpC,OAAOA,EAAKpB,MAAM,KAAK7B,IAAIR,EAAcP,OAAO+C,QAAO,SAAA4B,GAAC,OAAIA,MAuOhE,IAAMZ,EAAU,CACd,IAAK,SAACa,EAAEC,GAAH,OAASD,GAAKC,GACnB,IAAK,SAACD,EAAEC,GAAH,OAASD,GAAKC,GACnB,IAAK,SAACD,EAAEC,GAAH,OAASD,EAAIC,GAClB,IAAK,SAACD,EAAEC,GAAH,OAASD,EAAIC,GAClB,KAAM,SAACD,EAAEC,GAAH,OAASD,GAAKC,GACpB,KAAM,SAACD,EAAEC,GAAH,OAASD,GAAKC,GACpB,IAAO,SAACD,EAAEC,GAAH,OAASD,GAAKC,GACrB,GAAM,SAACD,EAAEC,GAAH,OAASD,GAAKC,ICzVf,SAASC,EAAaH,EAAGI,EAAGC,EAAOC,GAEtC,MAAO,CACH,CAACN,EAAGI,GACJ,CAACJ,EAAGI,EAAIE,GACR,CAACN,EAAIK,EAAOD,EAAIE,GAChB,CAACN,EAAIK,EAAOD,IASb,SAASG,EAAqBC,GAEjC,IADA,IAAIC,EAAM,EACDnC,EAAI,EAAGA,EAAIkC,EAAOhD,OAAS,EAAGc,IACnCmC,GAAOD,EAAOlC,GAAG,GAAKkC,EAAOlC,EAAE,GAAG,GAAKkC,EAAOlC,EAAE,GAAG,GAAKkC,EAAOlC,GAAG,GAEtE,OAAOmC,EAAM,EAMV,SAASC,EAASF,GACrB,OAAOG,KAAKC,IAAIL,EAAoBC,IAMjC,SAASK,EAAiBL,GAC7B,OAAOD,EAAoBC,GAAU,EAOlC,SAASM,EAAUN,GACtB,IAAMO,EAAIP,EAAOhD,OACjB,KAAIuD,EAAI,GAAR,CAGA,IADA,IAAIC,EAAO,EACF1C,EAAI,EAAGA,EAAIyC,EAAGzC,IAAK,CACxB,IAAM2B,EAAIO,EAAOlC,EAAE,GACb4B,EAAIM,EAAOlC,GACX2C,EAAIT,GAAQlC,EAAE,GAAKyC,GAEnBG,EAAOP,KAAKK,MAAMd,EAAE,GAAKD,EAAE,KAAOgB,EAAE,GAAKf,EAAE,KAAOA,EAAE,GAAKD,EAAE,KAAOgB,EAAE,GAAKf,EAAE,KAEjF,GAAa,IAATc,EAAYA,EAAOE,OAClB,GAAa,IAATA,GAAcF,IAASE,EAAM,OAAO,EAGjD,OAAO,GAOJ,SAASC,EAAeX,GAC3B,IAAMY,EAAIZ,EAAO,GACXO,EAAIP,EAAOA,EAAOhD,OAAS,GACjC,OAAO4D,EAAE,KAAOL,EAAE,IAAMK,EAAE,KAAOL,EAAE,GAMhC,SAASM,EAAWb,GAGvB,IAFA,IAAIC,EAAM,EAEDnC,EAAI,EAAGA,EAAIkC,EAAOhD,OAAQc,IAAK,CACpC,IAAMgD,EAAKd,EAAOlC,GAAG,GAAKkC,EAAOlC,EAAE,GAAG,GAChCiD,EAAKf,EAAOlC,GAAG,GAAKkC,EAAOlC,EAAE,GAAG,GACtCmC,GAAOE,KAAKa,KAAKF,EAAKA,EAAKC,EAAKA,GAGpC,OAAOd,ECpDJ,SAASgB,EAAeC,EAAK7C,GAAO,IAAD,EAvCnC,SAAyBA,GAC5B,IAEI8C,EAFEC,EAAY/C,EAAKb,aAAL,KACd6D,EAAchD,EAAKb,aAAL,OAGlB,GAAI6D,EAAa,CAEb,IAAIC,EAAaD,EAAYE,QAAQ,cAAc,SAAAC,GAAE,MAAI,IAAIC,OAAOD,EAAGxE,WAIvEsE,GADAA,EAAaA,EAAWC,QAAQ,eAAgB,SACxBA,QAAQ,eAAgB,WAKhD,IACMG,EADO,4BACG7E,KAAKyE,GACjBI,IACAP,GAAaO,EAAG,GAAKC,iBACrBN,EAAcA,EAAYE,QAAQG,EAAG,GAAI,KAQjD,OAJIrD,EAAKb,aAAa,kBAClB2D,GAAa9C,EAAKb,aAAa,gBAAkBmE,kBAG9C,CACHP,YACAC,cACAF,aAS0CS,CAAgBvD,GAAtD+C,EAD8B,EAC9BA,UAAWC,EADmB,EACnBA,YAAaF,EADM,EACNA,UAEhCD,EAAIE,UAAYA,EAChBF,EAAIG,YAAcA,EAClBH,EAAIC,UAAYA,ECjCb,SAASU,EAAWX,EAAK7C,EAAzB,GAAwD,IAAD,mBAAvBmB,EAAuB,KAApBI,EAAoB,KAAhB1D,EAAgB,uDAAN,KACpD+E,EAAcC,EAAK7C,GAEnB,IAAIyD,EAAUC,EAAW1D,EAAMnC,GAI/B,GAFA8F,EAAQd,EAAK7C,GAETA,EAAKb,aAAa,cAAe,CACjC,IAAMyE,EAAYf,EAAIgB,YAAYJ,GAASjC,MAEH,WAApCxB,EAAKb,aAAa,eAAkE,WAApCa,EAAKb,aAAa,cAClEgC,GAAKyC,EAAY,EAEwB,UAApC5D,EAAKb,aAAa,gBACvBgC,GAAKyC,GAIT5D,EAAKb,aAAa,iBAClB0D,EAAIG,YAAchD,EAAKb,aAAa,eACpC0D,EAAIiB,WAAWL,EAAStC,EAAGI,IAG3BvB,EAAKb,aAAa,eAClB0D,EAAIE,UAAY/C,EAAKb,aAAa,cAClC0D,EAAIkB,SAASN,EAAStC,EAAGI,KAGrBvB,EAAKb,aAAL,QACA0D,EAAIiB,WAAWL,EAAStC,EAAGI,IAC3BvB,EAAKb,aAAL,MAA8Ba,EAAKb,aAAL,QAC9B0D,EAAIkB,SAASN,EAAStC,EAAGI,IAI9B,SAASoC,EAAQd,EAAK7C,GACzB,IAAIgE,EAAQ,UAAM,GAAKV,iBAAX,MACRW,EAAa,SACbC,EAAa,aAEblE,EAAKb,aAAa,eAClB6E,EAAWhE,EAAKb,aAAa,aAAa+D,QAAQ,aAAa,SAAAzC,GAAC,iBAAQA,EAAI6C,sBAG5EtD,EAAKb,aAAa,iBAClB8E,EAAajE,EAAKb,aAAa,gBAG/Ba,EAAKb,aAAa,iBAClB+E,EAAalE,EAAKb,aAAa,gBAGnC0D,EAAIsB,KAAOnE,EAAKb,aAAL,gBAAgC8E,EAAhC,YAA8CD,EAA9C,YAA0DE,GAOlE,SAASR,EAAW1D,EAAMnC,GAC7B,IAAI4F,EAAUzD,EAAKb,aAAL,QAEd,IAAKsE,EAAS,MAAO,GAErB,GAAIA,EAAQ3F,MAAM,WACd2F,EAAUA,EAAQP,QAAQ,SAAU,SAEnC,GAAIO,EAAQ3F,MAAM,kBAAmB,CACtC,IAAM2C,EAAIgD,EAAQ3F,MAAM,kBACxB2F,EAAU5F,EAAQZ,KAAKwD,EAAE,KAAO,QAGhCgD,EAAU,IAEd,OAAOA,EC/EJ,SAASW,EAAevB,EAAK7C,GAChC,IAAMqE,EAAMf,iBAEZ,GAAItD,EAAKb,aAAL,UAIA,IAHA,IAEIsB,EAFE6D,EAAI,6BACJC,EAAIvE,EAAKb,aAAL,UAEHsB,EAAI6D,EAAE9F,KAAK+F,IAAI,CAClB,IAAMC,EAAQ/D,EAAE,GACVK,EAASL,EAAE,GAAGrB,MAAM,KAAK7B,KAAI,SAAA8B,GAAC,MAAK,CAAEtB,MAAO0G,WAAWpF,GAAKgF,EAAKK,KAAMrF,EAAE6D,QAAQ,YAAa,QACpG,OAAQsB,GACJ,IAAK,SAED3B,EAAI8B,UAAJ,MAAA9B,EAAG,YAAc/B,EAAOvD,KAAI,SAAAqH,GAAC,OAAIA,EAAE7G,WACnC,MACJ,IAAK,SAAW,IAAD,EACW+C,EAAO,GAAvB/C,EADK,EACLA,MAAO2G,EADF,EACEA,KAEA,QAATA,EACA3G,GAAS+D,KAAK+C,GAAK,IACH,SAATH,IACP3G,GAAmB,EAAV+D,KAAK+C,IAGlBhC,EAAIiC,OAAO/G,GACX,MAEJ,IAAK,QACD,IAAMoD,EAAIL,EAAO,GAAG/C,MACdwD,EAAIT,EAAO,GAAKA,EAAO,GAAG/C,MAAQoD,EACxC0B,EAAIkC,MAAM5D,EAAGI,GACb,MACJ,IAAK,YAEDsB,EAAImC,UAAJ,MAAAnC,EAAG,YAAc/B,EAAOvD,KAAI,SAAAqH,GAAC,OAAIA,EAAE7G,WACnC,MACJ,IAAK,OAAL,MAC0B+C,EAAO,GAAvB/C,EADV,EACUA,MAAO2G,EADjB,EACiBA,KAEA,QAATA,EACA3G,EAAQ+D,KAAKmD,IAAIlH,GACH,QAAT2G,IACL3G,EAAQ+D,KAAKmD,IAAIlH,EAAQ+D,KAAK+C,GAAK,MAEvC,IAAIK,EAAS,EAEb,GAAIpE,EAAO,GAAI,CAAC,IAAD,EACWA,EAAO,GAAvB/C,EADK,EACLA,MAAO2G,EADF,EACEA,KAEA,QAATA,EACA3G,EAAQ+D,KAAKmD,IAAIlH,GACH,QAAT2G,IACL3G,EAAQ+D,KAAKmD,IAAIlH,EAAQ+D,KAAK+C,GAAK,MAEvCK,EAASnH,EAGb8E,EAAI8B,UAAU,EAAGO,EAAQnH,EAAO,EAAG,EAAG,KClDnD,SAASoH,EAAYtC,EAAK7C,EAA1B,GAAyD,IAAD,mBAAvBmB,EAAuB,KAApBI,EAAoB,KAAhB1D,EAAgB,uDAAN,KAerD,GAdAgF,EAAIuC,OAEJvC,EAAIE,UAAY/C,EAAKb,aAAL,KAChB0D,EAAIG,YAAchD,EAAKb,aAAL,OAClB0D,EAAIC,WAAa9C,EAAKb,aAAa,gBAAkBmE,iBAEf,aAAlCtD,EAAKb,aAAL,WACAgC,GAAKsD,WAAWzE,EAAKb,aAAL,OAA8B,GAAKmE,iBACnD/B,GAAKkD,WAAWzE,EAAKb,aAAL,MAA6B,GAAKmE,kBAEtDT,EAAImC,UAAU7D,EAAGI,GAEjB6C,EAAevB,EAAK7C,GAEhBA,EAAKb,aAAL,KAA2B,CAC3B0D,EAAIwC,YAEJ,IAAMf,GAAKtE,EAAKb,aAAL,KAA4BmE,iBAEvCT,EAAIyC,QAAQ,EAAG,EAAGhB,EAAGA,EAAG,EAAG,EAAa,EAAVxC,KAAK+C,IAEnC7E,EAAKb,aAAL,MAA6B0D,EAAI0C,OACjCvF,EAAKb,aAAL,QAA+B0D,EAAI2C,SAGnCxF,EAAKb,aAAL,OACA0D,EAAIwC,YAEJI,EAAS5C,EAAK7C,EAAKb,aAAL,MAEda,EAAKb,aAAL,MAA6B0D,EAAI0C,OACjCvF,EAAKb,aAAL,QAA+B0D,EAAI2C,UAMvC,IAAME,EAAQ,iDACd,GAAIA,EAAM3E,KAAKf,EAAKb,aAAL,MAA4B,CACvC,IAAMsB,EAAIiF,EAAMlH,KAAKwB,EAAKb,aAAL,MACfwG,EAAMlF,EAAE,GACRmF,EAAM,IAAIC,MAChBD,EAAIE,IAAMH,EACV,IAAMI,EAAItB,WAAWhE,EAAE,IACjBuF,EAAIvB,WAAWhE,EAAE,IAGvBmF,EAAIK,iBAAiB,QAAQ,WAEzBpD,EAAIuC,OACJc,GAAYrD,EAAK7C,GAEjB6C,EAAImC,UAAU7D,EAAGI,GAEjB6C,EAAevB,EAAK7C,GAEpB,IAAMqE,EAAMf,iBACZ,GAAIyC,EAAG,CACH,IAAMtE,EAAU0E,MAAMH,GAASJ,EAAInE,QAAUsE,EAAIH,EAAIpE,OAA1BwE,EAC3BnD,EAAIuD,UAAUR,EAAK,EAAG,EAAGG,EAAI1B,EAAK5C,EAAS4C,QAG3CxB,EAAIuD,UAAUR,EAAK,EAAG,GAG1B/C,EAAIwD,aAIRrG,EAAKb,aAAL,SACAqE,EAAWX,EAAK7C,EAAM,CAAC,EAAG,GAAInC,GAGlCgF,EAAIwD,UAOR,SAASZ,EAAU5C,EAAKyD,GAQpB,IAPA,IACIxI,EAEAyI,EAEAC,EALEC,EAAO,8IAON3I,EAAQ2I,EAAKjI,KAAK8H,IAAW,CAChC,IAAMnF,EAAIsD,WAAW3G,EAAM,IAAMwF,iBAC3B/B,EAAIkD,WAAW3G,EAAM,IAAMwF,iBAC3BoD,EAAKjC,WAAW3G,EAAM,IAAMwF,iBAC5BqD,EAAKlC,WAAW3G,EAAM,IAAMwF,iBAC5BsD,EAAKnC,WAAW3G,EAAM,IAAMwF,iBAC5BuD,EAAKpC,WAAW3G,EAAM,IAAMwF,iBAE7BiD,IAAOA,EAAQ,CAACpF,EAAEI,IAEN,MAAbzD,EAAM,IACN0I,EAAO,CAACrF,EAAEI,GACVsB,EAAIiE,OAAO3F,EAAGI,IAEI,MAAbzD,EAAM,IACX0I,EAAO,CAACrF,EAAEI,GACVsB,EAAIkE,OAAO5F,EAAGI,IAEI,MAAbzD,EAAM,IACX0I,EAAO,CAACE,EAAGC,GACX9D,EAAImE,iBAAiB7F,EAAGI,EAAGmF,EAAIC,IAEb,MAAb7I,EAAM,IACX0I,EAAO,CAACI,EAAGC,GACXhE,EAAIoE,cAAc9F,EAAGI,EAAGmF,EAAIC,EAAIC,EAAIC,IAElB,MAAb/I,EAAM,IACX0I,EAAOD,EACP1D,EAAIkE,OAAJ,MAAAlE,EAAG,YAAW2D,KAEI,MAAb1I,EAAM,IACX0I,EAAO,CAACA,EAAK,GAAIrF,GACjB0B,EAAIkE,OAAJ,MAAAlE,EAAG,YAAW2D,KAEI,MAAb1I,EAAM,IACX0I,EAAO,CAACrF,EAAGqF,EAAK,IAChB3D,EAAIkE,OAAJ,MAAAlE,EAAG,YAAW2D,KAEI,MAAb1I,EAAM,IACX0I,EAAO,CAACA,EAAK,GAAKrF,EAAGqF,EAAK,GAAKjF,GAC/BsB,EAAIiE,OAAJ,MAAAjE,EAAG,YAAW2D,KAEI,MAAb1I,EAAM,IACX0I,EAAO,CAACA,EAAK,GAAKrF,EAAGqF,EAAK,GAAKjF,GAC/BsB,EAAIkE,OAAJ,MAAAlE,EAAG,YAAW2D,KAEI,MAAb1I,EAAM,IACX+E,EAAImE,iBAAiBR,EAAK,GAAKrF,EAAGqF,EAAK,GAAKjF,EAAGiF,EAAK,GAAKE,EAAIF,EAAK,GAAKG,GACvEH,EAAO,CAACA,EAAK,GAAKE,EAAIF,EAAK,GAAKG,IAEd,MAAb7I,EAAM,IACX0I,EAAO,CAACI,EAAGC,GACXhE,EAAIoE,cAAcT,EAAK,GAAKrF,EAAGqF,EAAK,GAAKjF,EAAGiF,EAAK,GAAKE,EAAIF,EAAK,GAAKG,EAAIH,EAAK,GAAKI,EAAIJ,EAAK,GAAKK,GAChGL,EAAO,CAACA,EAAK,GAAKI,EAAIJ,EAAK,GAAKK,IAEd,MAAb/I,EAAM,IACX0I,EAAOD,EACP1D,EAAIkE,OAAJ,MAAAlE,EAAG,YAAW0D,KAEI,MAAbzI,EAAM,IACX0I,EAAO,CAACA,EAAK,GAAIA,EAAK,GAAKrF,GAC3B0B,EAAIkE,OAAJ,MAAAlE,EAAG,YAAW2D,KAEI,MAAb1I,EAAM,KACX0I,EAAO,CAACA,EAAK,GAAKrF,EAAGqF,EAAK,IAC1B3D,EAAIkE,OAAJ,MAAAlE,EAAG,YAAW2D,MCjJnB,SAASU,EAAmBC,EAAQpC,EAAOvD,EAAOC,GACrD,IAD6D,cAGxC0F,EAHwC,GAGtDC,EAHsD,KAGhDC,EAHgD,KAKvDC,EAAYxF,KAAKyF,IAAI,EAAGxC,GAIxByC,EARe,KAKD,IAAMF,GAIpBG,EATe,KAMD,IAAMH,GAKpBI,EAAa5F,KAAK+C,GAAK,EAEvB8C,EAAKnG,EAAQ,EACboG,EAAKnG,EAAS,EAEdoG,EAA0E,IAA9D/F,KAAK7C,IAAI6C,KAAKmD,IAAIyC,EAAcL,EAAO,IAAMvF,KAAK+C,GAAM,IAAY/C,KAAK+C,GAE3F,OAAO,SAACiD,EAAKC,GACT,IAAMC,EAAIF,EACJG,EAAiE,IAA7DnG,KAAK7C,IAAI6C,KAAKmD,IAAIyC,EAAcK,EAAM,IAAMjG,KAAK+C,GAAM,IAAY/C,KAAK+C,GAQlF,MAAO,CAAC8C,GANKK,EAAIZ,GAGCI,EAGDI,GALJK,EAAIJ,GAGCJ,IAsBnB,SAASS,EAAevG,GAC3B,IAAMwG,EAAcC,EAAezG,GAEnC,MAAO,CACHwG,EAAY,GAAKA,EAAY,GAAK,EAClCA,EAAY,GAAKA,EAAY,GAAK,GASnC,SAASE,EAAY1G,GACxB,OAAOA,EAAOG,KAAKwG,OAAO3G,EAAOhD,OAAS,GAAK,IAO5C,SAASyJ,EAAezG,GAC3B,IAAM4G,EAAS5G,EAAO6G,QAAO,SAACD,EAAQE,GAClC,MAAO,CACH3G,KAAK4G,IAAIH,EAAO,GAAIE,EAAM,IAC1B3G,KAAK4G,IAAIH,EAAO,GAAIE,EAAM,IAC1B3G,KAAK6G,IAAIJ,EAAO,GAAIE,EAAM,IAC1B3G,KAAK6G,IAAIJ,EAAO,GAAIE,EAAM,OAE/B,CAACG,OAAOC,kBAAmBD,OAAOC,kBAAmBD,OAAOE,kBAAmBF,OAAOE,oBAEzF,MAAO,CACHP,EAAO,GACPA,EAAO,GACPA,EAAO,GAAKA,EAAO,GACnBA,EAAO,GAAKA,EAAO,I,IC3GNQ,E,WAIjB,aAAgB,oBAEZ3L,KAAK4L,KAAO,G,oDAIZ5L,KAAK4L,KAAO,K,0BAQXC,EAAKC,GACD9L,KAAK4L,KAAKC,KAAM7L,KAAK4L,KAAKC,GAAO,IAD3B,oBAGS7L,KAAK4L,KAAKC,IAHnB,IAGX,2BAAoC,CAChC,GAAIE,EAAWD,EADiB,SACJ,OAAO,GAJ5B,8BASX,OAFA9L,KAAK4L,KAAKC,GAAKlK,KAAKmK,IAEb,K,4CAQP,OAJK9L,KAAKgM,YACNhM,KAAKgM,UAAY,IAAIL,GAGlB3L,KAAKgM,c,KAUpB,SAASD,EAAYE,EAAMC,GACvB,IAAMC,EAAMF,EAAK,GACXG,EAAMH,EAAK,GACXI,EAAMJ,EAAK,GAAKA,EAAK,GACrBK,EAAML,EAAK,GAAKA,EAAK,GACrBM,EAAML,EAAK,GACXM,EAAMN,EAAK,GACXO,EAAMP,EAAK,GAAKA,EAAK,GACrBQ,EAAMR,EAAK,GAAKA,EAAK,GAC3B,OAAOC,EAAMM,GAAOJ,EAAME,GAAOH,EAAMM,GAAOJ,EAAME,ECtCjD,SAASG,EAAelH,EAAK7C,EAAM2B,EAAQqI,GAA2B,IAAjBnM,EAAgB,uDAAN,KAClE,GAAsB,IAAlB8D,EAAOhD,OAAX,CAIA,GAAIqB,EAAKb,aAAa,iBAAkB,CACpC,IAAM+J,EAAMd,EAAezG,GAErBsI,EAAkBlB,EAAgBmB,qBAExC,IAAKD,EAAgBE,IAAInK,EAAKb,aAAa,iBAAkB+J,GAAM,CAC/D,IAAMkB,EAASpK,EAAKb,aAAa,qBAAuB,OAExD,GAAe,SAAXiL,EACA,QAKZvH,EAAIuC,OAEJxC,EAAcC,EAAK7C,GAEnB,IAAIqK,EAAU,EACVC,EAAU,EAEd,GAAItK,EAAKb,aAAL,UAAgC,CAIhC,IAAMoL,EAAKP,EAASrI,GAGpB0I,EAAUE,EAAG,GACbD,EAAUC,EAAG,GAGb1H,EAAImC,UAAUqF,EAASC,GAGvBlG,EAAevB,EAAK7C,GAGxB6C,EAAIwC,YACJxC,EAAIiE,OAAOnF,EAAO,GAAG,GAAK0I,EAAS1I,EAAO,GAAG,GAAK2I,GAClD,IAAK,IAAI7K,EAAI,EAAGA,EAAIkC,EAAOhD,OAAQc,IAC/BoD,EAAIkE,OAAOpF,EAAOlC,GAAG,GAAK4K,EAAS1I,EAAOlC,GAAG,GAAK6K,GAGtDtK,EAAKb,aAAL,MAA6B0D,EAAI0C,OACjCvF,EAAKb,aAAL,QAA+B0D,EAAI2C,SAEnC3C,EAAIwD,WAGArG,EAAKb,aAAL,SAAgCa,EAAKb,aAAL,MAA6Ba,EAAKb,aAAL,MAA6Ba,EAAKb,aAAL,QAC1F0D,EAAIuC,OACJD,EAAYtC,EAAK7C,EAAMgK,EAASrI,GAAS9D,GACzCgF,EAAIwD,YC9DL,SAASmE,EAAW3H,EAAK7C,EAAM2B,GAAyB,IAAjB9D,EAAgB,uDAAN,KACpDkM,EAAelH,EAAK7C,EAAM2B,EAAQ0G,EAAaxK,GCA5C,SAAS4M,EAAW5H,EAAK7C,EAAM2B,GAAyB,IAAjB9D,EAAgB,uDAAN,KAC9B,IAAlB8D,EAAOhD,SAGN2D,EAAcX,KACfA,EAAM,sBAAQA,GAAR,CAAgBA,EAAO,MAGjCoI,EAAelH,EAAK7C,EAAM2B,EAAQuG,EAAgBrK,ICI/C,SAAS6M,EAAUC,EAAOC,GAAQ,IAAD,EACVD,EAAMvL,MAAM,KADF,mBAC7ByL,EAD6B,KACzBC,EADyB,KACrBC,EADqB,KACjBC,EADiB,OAEVJ,EAAMxL,MAAM,KAFF,mBAE7B6L,EAF6B,KAEzBC,EAFyB,KAErBC,EAFqB,KAEjBC,EAFiB,KAIpC,OAAQH,GAAOJ,GAAOK,GAAOJ,GAAOK,GAAOJ,GAAOK,GAAOJ,EAOtD,SAASnJ,EAASwJ,GACrB,IAAMC,EAAQD,EAAKjM,MAAM,KACzB,QAASkM,EAAM,IAAMA,EAAM,MAAQA,EAAM,IAAMA,EAAM,IASlD,SAASC,EAAUpE,EAAQpC,EAAOyG,GACrC,IAD2C,cAGtBrE,EAHsB,GAGnCW,EAHmC,KAG9BC,EAH8B,mBAIjByD,EAJiB,GAInChK,EAJmC,KAI5BC,EAJ4B,KAMrC6F,EAAYxF,KAAKyF,IAAI,EAAGxC,GAOxB0G,EANQ,IAAMnE,GAGD9F,EATE,KAafkK,EANQ,IAAMpE,GAGD7F,EAVE,KAerB,MAAO,CAAEqG,EAAM2D,EAAM1D,EAAM2D,EAAM5D,EAAM2D,EAAM1D,EAAM2D,GAAOnO,KAAI,SAAAqH,GAAC,OAAIA,EAAE+G,QAAQ,MAAIjO,KAAK,KC5DnF,SAASkO,EAAgB/I,EAAK7C,EAAMmH,EAAQpC,EAAOvD,EAAOC,EAAQoK,GACrE,IAAMC,EAAW9L,EAAKpC,SAASV,cAAc6O,MAAK,SAAAnH,GAAC,MAAe,aAAXA,EAAE5D,QACnDgL,EAAahM,EAAKpC,SAASV,cAAc6O,MAAK,SAAAnH,GAAC,MAAe,eAAXA,EAAE5D,QAGrDsK,EADOC,EAASpE,EAAQpC,EAAO,CAACvD,EAAOC,IAC1BrC,MAAM,KAEzB,GAAI0M,EAYA,IAXA,IAAMG,EAAOxH,WAAWqH,EAAShL,OAAO,IAElCoL,EAAQ,EAAID,EAEZE,EAAUrK,KAAKsK,KAAKtK,KAAKuK,MAAMH,IAE/BI,EAAOxK,KAAKwG,OAAOgD,EAAM,GAAKY,GAASA,EACvCK,EAAOzK,KAAKsK,MAAMd,EAAM,GAAKY,GAASA,EACtCM,EAAO1K,KAAKwG,OAAOgD,EAAM,GAAKY,GAASA,EACvCO,EAAO3K,KAAKsK,MAAMd,EAAM,GAAKY,GAASA,EAEnCzM,EAAI6M,EAAM7M,GAAK8M,EAAM9M,GAAKwM,EAAM,CAErCzB,EAAW3H,EAAK7C,EADD,CAAE6L,EAAWpM,EAAG+M,GAAQX,EAAWpM,GAAI+M,EAAOC,GAAQ,GAAIZ,EAAWpM,EAAGgN,IACzD,CAAEzP,KAAM,MAAO0P,GAAI,EAAGC,MAAO,GAAI1P,KAAM,CAAE+D,KAAMvB,EAAEkM,QAAQQ,MAI/F,GAAIH,EAYA,IAXA,IAAMC,EAAOxH,WAAWuH,EAAWlL,OAAO,IAEpCoL,EAAQ,EAAID,EAEZE,EAAUrK,KAAKsK,KAAKtK,KAAKuK,MAAMH,IAE/BI,EAAOxK,KAAKwG,OAAOgD,EAAM,GAAKY,GAASA,EACvCK,EAAOzK,KAAKsK,MAAMd,EAAM,GAAKY,GAASA,EACtCM,EAAO1K,KAAKwG,OAAOgD,EAAM,GAAKY,GAASA,EACvCO,EAAO3K,KAAKsK,MAAMd,EAAM,GAAKY,GAASA,EAEnCU,EAAIJ,EAAMI,GAAKH,EAAMG,GAAKX,EAAM,CAErCzB,EAAW3H,EAAK7C,EADD,CAAE6L,EAAWS,EAAMM,GAAIf,GAAYS,EAAOC,GAAQ,EAAGK,GAAIf,EAAWU,EAAMK,IAC3D,CAAE5P,KAAM,MAAO0P,GAAI,EAAGC,MAAO,GAAI1P,KAAM,CAAE+D,KAAM4L,EAAEjB,QAAQQ,OC5B5F,SAASU,EAAoBhK,EAAK7C,EAAMnC,EAAS8O,EAAOhL,GAC3D,GAAoC,WAAhC3B,EAAKpC,SAAST,eAA8D,WAAhC6C,EAAKpC,SAAST,cAG1DgI,EAAYtC,EAAK7C,EADGkI,EAAevG,GACC9D,QAEnC,GAAoC,cAAhCmC,EAAKpC,SAAST,cAA+B,CAGlDgI,EAAYtC,EAAK7C,EADAqI,EAAY1G,GACI9D,QAEhC,GAAoC,kBAAhCmC,EAAKpC,SAAST,cAAmC,CAGtDgI,EAAYtC,EAAK7C,EP+BlB,SAAyB2B,GAI5B,OAHYA,EAAO6G,QAAO,SAAC5G,EAAKgD,GAAN,MAAY,CAAChD,EAAI,GAAKgD,EAAE,GAAIhD,EAAI,GAAKgD,EAAE,MAAK,CAAC,EAAG,IAEzDrH,KAAI,SAAA4D,GAAC,OAAIA,EAAIQ,EAAOhD,UOnChBmO,CAAgBnL,GACA9D,QAEhC,GAAoC,UAAhCmC,EAAKpC,SAAST,cAEnBgI,EAAYtC,EAAK7C,EAAM2B,EAAO,GAAI9D,QAEjC,GAAoC,QAAhCmC,EAAKpC,SAAST,cAEnBgI,EAAYtC,EAAK7C,EAAM2B,EAAOA,EAAOhD,OAAS,GAAId,QAEjD,GAAoC,mBAAhCmC,EAAKpC,SAAST,oBAKlB,GAAoC,iBAAhC6C,EAAKpC,SAAST,cAAkC,CACrD,IAAM4P,EAAW3E,EAAezG,GAIhC8I,EAAW5H,EAAK7C,EAFOsB,EAAY,WAAZ,cAAgByL,IAEDlP,QAErC,GAAoC,gBAAhCmC,EAAKpC,SAAST,cAAiC,CACpDwG,EAAQd,EAAK7C,GACb,IAAMyD,EAAUC,EAAW1D,EAAMnC,GAC3B2N,EAAO3I,EAAIgB,YAAYJ,GAHuB,cAIrC9B,EAAO,GAJ8B,GAI9CR,EAJ8C,KAI3CI,EAJ2C,KAK5CC,EAAwEgK,EAAxEhK,MAAiCwL,EAAuCxB,EAAjEyB,yBAAyDC,EAAQ1B,EAAjC2B,wBACzCC,EAAUpN,EAAKb,aAAL,QAA+BsF,WAAWzE,EAAKb,aAAL,SAAgCmE,iBAAmB,EAErE,WAApCtD,EAAKb,aAAa,eAAkE,WAApCa,EAAKb,aAAa,cAClEgC,GAAKK,EAAQ,EAE4B,UAApCxB,EAAKb,aAAa,gBACvBgC,GAAKK,GAIT,IAAM6L,EAAc,CAChB,CAAElM,EAAIiM,EAAmB7L,EAAI2L,EAAME,GACnC,CAAEjM,EAAIiM,EAAmB7L,EAAIyL,EAAOI,GACpC,CAAEjM,EAAIK,EAAQ4L,EAAW7L,EAAIyL,EAAOI,GACpC,CAAEjM,EAAIK,EAAQ4L,EAAW7L,EAAI2L,EAAME,IAIvCC,EAAYtO,KAAKsO,EAAY,IAE7BtD,EAAelH,EAAK7C,EAAMqN,GAAa,kBAAM1L,EAAO,KAAI9D,IChEzD,SAASyP,EAAmBtN,EAAMnC,GAAuC,IAA9B8O,EAA6B,uDAArB,KAAMhL,EAAe,uDAAN,KAC7D/D,EAAaoC,EAAbpC,SAER,GAAI2P,EAAoB3P,EAAU,KAAM,YAC/BqE,EAASN,GACV,OAAO,EAGf,GAAI4L,EAAoB3P,EAAU,KAAM,YAChCqE,EAASN,GACT,OAAO,EAGf,GAAI4L,EAAoB3P,EAAU,KAAM,cAChCoE,EAAgBL,GAChB,OAAO,EAGf,GAAI4L,EAAoB3P,EAAU,KAAM,oBAC/BoE,EAAgBL,GACjB,OAAO,EAGf,GAAI4L,EAAoB3P,EAAU,KAAM,iBAChC+O,EAAM,KAAOA,EAAMhL,EAAOhD,OAAS,GACnC,OAAO,EAGf,IA5B2E,EA4BrE6O,EAAmB5P,EAASV,cAAcqC,QAAO,SAAA6C,GAAC,MAAe,QAAXA,EAAEpB,QA5Ba,cA8B1DwM,GA9B0D,IA8B3E,2BAAmC,CAAC,IAAzBC,EAAwB,QAC/B,GAA4B,kBAAjBA,EAAG3M,OAAO,GACjB,OAAO,EAEX,IAAMrC,EAAYgP,EAAG3M,OAAO,GAGtBf,EAAU,CACZ2N,KAAM,kBAAM7L,EAAQF,IACpBhD,OAAQ,kBAAM6D,EAAUb,IACxBH,MAAO,kBAAM4G,EAAezG,GAAQ,IACpCF,OAAQ,kBAAM2G,EAAezG,GAAQ,KAGnC7D,EAAQmC,EAAcxB,EAAWsB,GAEvC,IAAKjC,EAAO,OAAO,GA9CoD,8BAiD3E,OAAO,EASX,SAASyP,EAAqB3P,EAAUoD,GAAkB,IAAD,uBAARF,EAAQ,iCAARA,EAAQ,kBACrD,OAAOlD,EAASV,cAAcyQ,MAAK,SAAAvL,GAAC,OAAIA,EAAEpB,OAASA,GAAQoB,EAAEtB,OAAO,KAAOA,EAAO,MC7D/E,SAAS8M,GAAe/K,EAAK7C,EAAMnC,EAASgQ,EAAQC,EAASjC,GAChEhJ,EAAIE,UAAY/C,EAAKb,aAAL,KAChB0D,EAAIG,YAAchD,EAAKb,aAAL,OAClB0D,EAAIC,WAAa9C,EAAKb,aAAa,gBAAkBmE,iBAKrDT,EAAIwC,YAEJ,IAV4E,EAUtE0I,EAAYlQ,EAAQmQ,QAAQzO,QAAO,SAAAkB,GAAC,MAAe,QAAXA,EAAEzD,MAA6B,UAAXyD,EAAEwN,QAAkB1Q,KAAI,SAAAkD,GAAC,OAAIoN,EAAOpN,EAAEyN,QAClGC,EAAYtQ,EAAQmQ,QAAQzO,QAAO,SAAAkB,GAAC,MAAe,QAAXA,EAAEzD,MAA6B,UAAXyD,EAAEwN,QAAkB1Q,KAAI,SAAAkD,GAAC,OAAIoN,EAAOpN,EAAEyN,QAEpGE,GAAU,EAb8D,cAc1DL,GAd0D,IAc5E,2BAA6B,CAAC,IACpBpB,EADmB,QACPA,MAAMpP,KAAI,SAAAmP,GAAE,OAAIoB,EAAQpB,MAErC0B,IACDvL,EAAIiE,OAAJ,MAAAjE,EAAG,YAAWgJ,EAAWc,EAAM,GAAG7E,IAAK6E,EAAM,GAAG5E,OAChDqG,GAAU,GAEd,IAAK,IAAI3O,EAAI,EAAGA,EAAIkN,EAAMhO,OAAQc,IAC9BoD,EAAIkE,OAAJ,MAAAlE,EAAG,YAAWgJ,EAAWc,EAAMlN,GAAGqI,IAAK6E,EAAMlN,GAAGsI,QAtBoB,8BA0B5EqG,GAAU,EA1BkE,oBA2B1DD,GA3B0D,IA2B5E,2BAA6B,CAAC,IACpBxB,EADmB,QACPA,MAAMpP,KAAI,SAAAmP,GAAE,OAAIoB,EAAQpB,MAErC0B,IACDvL,EAAIiE,OAAJ,MAAAjE,EAAG,YAAWgJ,EAAWc,EAAM,GAAG7E,IAAK6E,EAAM,GAAG5E,OAChDqG,GAAU,GAEd,IAAK,IAAI3O,EAAI,EAAGA,EAAIkN,EAAMhO,OAAQc,IAC9BoD,EAAIkE,OAAJ,MAAAlE,EAAG,YAAWgJ,EAAWc,EAAMlN,GAAGqI,IAAK6E,EAAMlN,GAAGsI,QAnCoB,8BAyC5E/H,EAAKb,aAAL,MAA6B0D,EAAI0C,OACjCvF,EAAKb,aAAL,QAA+B0D,EAAI2C,SCtChC,SAAS6I,GAAUC,GAAS,IACvBC,EAA8BD,EAA9BC,YAAaC,EAAiBF,EAAjBE,aAEfhN,EAAQ+M,EAAcjL,iBACtB7B,EAAS+M,EAAelL,iBAE9BgL,EAAO9M,MAAQA,EACf8M,EAAO7M,OAASA,EAcb,SAASgN,GAAWtH,EAAQpC,GAA4C,IAArC2J,EAAoC,uDAA3B,GAAIJ,EAAuB,uCAAftO,EAAe,uCAATD,EAAS,uCAGpE+N,EAAU,GAChBY,EAASlP,SAAQ,SAAAmP,GAAC,MAAe,SAAXA,EAAE3R,OAAoB8Q,EAAQa,EAAEjC,IAAMiC,MAG5D,IAAMd,EAAS,GACfa,EAASlP,SAAQ,SAAAmP,GAAC,MAAe,QAAXA,EAAE3R,OAAmB6Q,EAAOc,EAAEjC,IAAMiC,MAE1D,IAAM9L,EAAMyL,EAAOM,WAAW,MACtBL,EAA8BD,EAA9BC,YAAaC,EAAiBF,EAAjBE,aAEfhN,EAAQ+M,EAAcjL,iBACtB7B,EAAS+M,EAAelL,iBAGxBuI,EAAa3E,EAAmBC,EAAQpC,EAAOvD,EAAOC,GAE5DoB,EAAIuC,OAGJc,GAAYrD,EAAK7C,GAtByD,IAwBlEhD,EAASgD,EAAKpC,SAAdZ,KAGR,OAAQA,GACJ,IAAK,MACD,IAAM2E,EAASL,EAAa,EAAG,EAAGE,EAAOC,GACrCzB,EAAKpC,SAAST,cACd0P,EAAoBhK,EAAK7C,EAAM,KAAM,EAAM2B,GAE3C8I,EAAW5H,EAAK7C,EAAM2B,GAC1B,MAEJ,IAAK,UACD,GAAI5B,EAAQ8O,QAAS,CAAC,IACVC,EAAW/O,EAAQ8O,QAAnBC,OACR3J,EAAYtC,EAAK7C,EAAM6L,EAAWiD,EAAOC,UAAWD,EAAOE,WAE/D,MAEJ,IAAK,YACDpD,EAAgB/I,EAAK7C,EAAMmH,EAAQpC,EAAOvD,EAAOC,EAAQoK,GACzD,MAEJ,IAAK,QACD1G,EAAYtC,EAAK7C,EAAM,CAAC,EAAG,IAC3B,MAEJ,4BAEqB0O,GAFrB,IAEI,2BAA2B,CAAC,IAAjBO,EAAgB,QACvB,OAAQjS,GACJ,IAAK,OACD,GAAgB,SAAZiS,EAAGjS,KAAiB,SAExB,IAAMyL,EAAQoD,EAAWoD,EAAGnH,IAAKmH,EAAGlH,KAEhC/H,EAAKpC,SAAST,cACd0P,EAAoBhK,EAAK7C,EAAMiP,EAAI,EAAM,CAACxG,IAG1CtD,EAAYtC,EAAK7C,EAAMyI,EAAOwG,GAElC,MAEJ,IAAK,MACL,IAAK,OACD,GAAgB,QAAZA,EAAGjS,KAAgB,SAGvB,IAAM2P,EAAQsC,EAAGtC,MAAMpP,KAAI,SAAAmP,GAAE,OAAIoB,EAAQpB,MACnC/K,EAASgL,EAAMpP,KAAI,SAAAoR,GAAC,OAAI9C,EAAW8C,EAAE7G,IAAK6G,EAAE5G,QAElD,IAAKuF,EAAmBtN,EAAMiP,EAAItC,EAAOhL,GAAS,SAE9C3B,EAAKpC,SAAST,cACd0P,EAAoBhK,EAAK7C,EAAMiP,EAAItC,EAAOhL,GAI7B,SAAT3E,EACAyN,EAAW5H,EAAK7C,EAAM2B,EAAQsN,GAE9BzE,EAAW3H,EAAK7C,EAAM2B,EAAQsN,GAGtC,MAEJ,IAAK,WACD,GAAgB,aAAZA,EAAGjS,KAAqB,SAE5B4Q,GAAe/K,EAAK7C,EAAMiP,EAAIpB,EAAQC,EAASjC,KA3C/D,+BAkDJhJ,EAAIwD,UAGD,SAASH,GAAYrD,EAAK7C,GAI7B,GAHIA,EAAKb,aAAL,UACA0D,EAAIqM,aAAelP,EAAKb,aAAL,SAEe,aAAlCa,EAAKb,aAAL,SAA8C,CAC9C,IAAMgQ,GAAO1K,WAAWzE,EAAKb,aAAL,MAA6B,GAAKmE,iBACpDpD,GAAQuE,WAAWzE,EAAKb,aAAL,OAA8B,GAAKmE,iBAE5DT,EAAImC,UAAU9E,EAAMiP,I,aCjJPC,G,WACjB,aAAuC,IAA1BpO,EAAyB,uDAApB,mBAAoB,oBAClC,IAAMqO,EAAUC,UAAUC,KAAKvO,GAE/BqO,EAAQpJ,iBAAiB,iBAAiB,SAAAuJ,GAEtC,IACMC,EADWD,EAAGE,OACDC,OACnBF,EAAGG,kBAAkB,QAAS,CAAEC,QAAS,OAE3BJ,EAAGG,kBAAkB,YAC7BE,YAAY,gBAAiB,CAAC,WAAY,OAAQ,QAAS,CAAEC,QAAQ,OAI/E3S,KAAKqS,GAAK,IAAIO,SAAQ,SAACC,EAASC,GAC5Bb,EAAQpJ,iBAAiB,WAAW,SAAAuJ,GAEhC,IAAMH,EAAWG,EAAGE,OACpBO,EAAQZ,EAAQM,WAGpBN,EAAQpJ,iBAAiB,QAASiK,M,+FAKzBvD,G,+FACIvP,KAAKqS,G,OAAhBA,E,OACAU,EAAQV,EAAGW,YAAY,QAAS,aAAaC,YAAY,S,cAC/C1D,G,IAAhB,2BAAWgC,EAAY,QACnBwB,EAAMG,IAAI3B,G,4MAIHjC,G,uFACMtP,KAAKqS,G,cAAhBA,E,yBAEC,IAAIO,SAAQ,SAACC,EAASC,GACzB,IACMb,EADQI,EAAGW,YAAY,QAAS,YAAYC,YAAY,SACxCE,IAAI7D,GAC1B2C,EAAQpJ,iBAAiB,WAAW,SAAAxJ,GAAC,OAAIwT,EAAQZ,EAAQM,WACzDN,EAAQpJ,iBAAiB,SAAS,SAAAxJ,GAAC,OAAIyT,EAAOzT,U,sIAQ5C+T,GAAM,IAAD,OACX,OAAOR,QAAQS,IAAID,EAAIjT,KAAI,SAAAmP,GAAE,OAAI,EAAKgE,QAAQhE,S,kCASrCrB,EAAMzN,GACf,IAAM5B,EAAM2U,GAAQtF,EAAMzN,GAC1B,OAAOR,KAAKwT,iBAAiB5U,K,gFAQTA,G,uFACHoB,KAAKqS,G,cAAhBA,E,yBACC,IAAIO,SAAQ,SAACC,EAASC,GACzB,IACMb,EADcI,EAAGW,YAAY,WAAY,YAAYC,YAAY,YAC3CE,IAAIvU,GAChCqT,EAAQpJ,iBAAiB,WAAW,SAAAxJ,GAAC,OAAIwT,EAAQZ,EAAQM,WACzDN,EAAQpJ,iBAAiB,QAASiK,O,qLAUpB7E,EAAMzN,G,uFACPR,KAAKqS,G,cAAhBA,E,yBAEC,IAAIO,SAAQ,SAACC,EAASC,GACzB,IACM5R,EADcmR,EAAGW,YAAY,WAAY,YAAYC,YAAY,YAC7C/R,MAAM,iBAC1BuS,EAAQC,YAAYC,MAAM,CAACnT,EAAS,EAAE,KAAM,CAACA,EAASgL,OAAOoI,UAAU,uBACvE3B,EAAU/Q,EAAM2S,cAAcJ,GAChCK,EAAQ,EACZ7B,EAAQpJ,iBAAiB,WAAW,SAAAxJ,GAChC,IAAM0U,EAAS9B,EAAQM,OAEvB,GAAIwB,EAAQ,CAAC,IACDnV,EAAoBmV,EAApBnV,IAAKoV,EAAeD,EAAfC,WACPC,EAAUrV,EAAI,GAEpB,GADAkV,IACIxG,EAAS2G,EAAShG,GAGlB,OAFArM,QAAQsS,MAAR,UAAiB1T,EAAjB,iCAAkDsT,EAAlD,kBACAjB,EAAQmB,GAGZD,EAAOI,gBAGPvS,QAAQsS,MAAR,UAAiB1T,EAAjB,qCAAsDsT,EAAtD,aACAjB,EAAQ,SAGhBZ,EAAQpJ,iBAAiB,QAASiK,O,qLAUtB7E,EAAMzN,EAAU4T,G,2FACfpU,KAAKqS,G,cAAhBA,E,OACAzT,EAAM2U,GAAQtF,EAAMzN,GACpB8P,EAAO7L,EAAQwJ,G,kBAEd,IAAI2E,SAAQ,SAACC,EAASC,GACzB,IACMb,EADcI,EAAGW,YAAY,WAAY,aAAaC,YAAY,YAC5CC,IAAZ,cAAkB1S,WAAUyN,OAAMqC,QAAS8D,GAAUxV,GACrEqT,EAAQpJ,iBAAiB,WAAW,WAChCjH,QAAQsS,MAAR,gBAAuB1T,EAAvB,YAAmCyN,EAAnC,6BAA4DmG,EAAO9C,SAAS/P,OAA5E,cACAsR,OAEJZ,EAAQpJ,iBAAiB,QAASiK,O,kHAK9C,SAASS,GAAStF,EAAMzN,GACpB,IAAM6T,EAAOpG,EAAKjM,MAAM,KAAK7B,KAAI,SAAAqH,GAAC,QAAMA,GAAG+G,QAAQ,MAAIjO,KAAK,KAC5D,MAAM,GAAN,OAAUE,EAAV,YAAsB6T,GCjJnB,SAASC,GAASC,GACrB,OAAO,IAAI3B,SAAQ,SAAAC,GAAO,OAAI2B,WAAW3B,EAAS0B,MCMtD,IAAM7V,GAAW+V,EAAQ,IAAW/V,SAE9BgW,GAAa,iCACbC,GAAU,4BAEHC,GAAb,WACI,WAAa3G,GAAO,oBAEhBjO,KAAKsR,SAAW,IAAIuD,IACpB7U,KAAKiO,KAAOA,EACZjO,KAAK8U,SAAW,IAAI9C,GAEpBhS,KAAK+U,SAAW,GAPxB,oDAUa9G,GAGAX,EAAStN,KAAKiO,KAAMA,IACrBjO,KAAKsR,SAAS0D,QAElBhV,KAAKiO,KAAOA,IAhBpB,+EAuB2BzL,GAvB3B,sGAkCQ,IAVQyL,EAASjO,KAATiO,KAIFpC,EAAM,GACZrJ,EAAUJ,SAAQ,SAAAH,GAAC,OAAI4J,EAAIoJ,GAAYhT,IAAMA,KAE7CL,QAAQsS,MAAR,+BAAsC1R,EAAUjB,OAAhD,uBAAqEtB,OAAOiV,KAAKrJ,GAAKtK,OAAtF,aAGA,MAA8BtB,OAAOC,QAAQ2L,GAA7C,eAAoD,EAAD,oBAAvCjN,EAAuC,KAAlC4B,EAAkC,KAC1CkU,GAAW/Q,KAAKnD,EAASZ,cAAciM,EAAIjN,GAKpD,IAHAgD,QAAQsS,MAAR,+BAAsCjU,OAAOiV,KAAKrJ,GAAKtK,OAAvD,2BAGA,MAAkBtB,OAAOiV,KAAKrJ,GAA9B,eAAWjN,EAAyB,KAC5BoB,KAAKsR,SAAS6D,IAAIvW,WAAaiN,EAAIjN,GAzCnD,OA2CQgD,QAAQsS,MAAR,+BAAsCjU,OAAOiV,KAAKrJ,GAAKtK,OAAvD,oBA3CR,UA8CcqR,QAAQS,IAAIpT,OAAOiV,KAAKrJ,GAAK1L,KAAI,SAAA8B,GACnC,OAAO,EAAK6S,SAASM,eAAenH,EAAMhM,GACrCoT,MAAK,SAAAC,GACEA,UAAYzJ,EAAI5J,UAjDxC,WAoDQL,QAAQsS,MAAR,+BAAsCjU,OAAOiV,KAAKrJ,GAAKtK,OAAvD,qBAEgC,IAA5BtB,OAAOiV,KAAKrJ,GAAKtK,OAtD7B,oEAwD+BvB,KAAKuV,SAAStV,OAAOuV,OAAO3J,IAxD3D,eAwDcyF,EAxDd,OA0DQ1P,QAAQC,IAAR,uCAA4CyP,EAAS/P,OAArD,0BAIMmP,EAAU,GAChBY,EAASlP,SAAQ,SAAAmP,GAAC,MAAe,SAAXA,EAAE3R,OAAoB8Q,EAAQa,EAAEjC,IAAMiC,MAGtDd,EAAS,GACfa,EAASlP,SAAQ,SAAAmP,GAAC,MAAe,QAAXA,EAAE3R,OAAmB6Q,EAAOc,EAAEjC,IAAMiC,MAnElE,kBAqEeqB,QAAQS,IAAIpT,OAAOuV,OAAO3J,GAAK1L,KAAI,SAAAK,GACtC,IAAMQ,EAAMsQ,EAASnP,QAAO,SAAA0P,GAAE,OAAItR,EAAcC,EAAUqR,MAE1D,GAAsB,aAAlBrR,EAASZ,KAAqB,CAE9B,IAF8B,EAExB6V,EAAQzU,EAAI0U,QAGZC,EAAO,GALiB,cAOZF,GAPY,IAO9B,2BAAwB,CAAC,IACfG,EADc,QACHhF,QAAQzQ,KAAI,SAAAkD,GAAC,OAAIA,EAAEyN,OACpC6E,EAAKhU,KAAL,MAAAgU,EAAI,YAASC,EAAKzV,KAAI,SAAAmP,GAAE,OAAImB,EAAOnB,SATT,8BAY9BtO,EAAIW,KAAJ,MAAAX,EAAY2U,GAEZ,cAAkBA,EAAlB,eAAwB,CAAnB,IAAME,EAAG,KACV7U,EAAIW,KAAJ,MAAAX,EAAG,YAAS6U,EAAItG,MAAMpP,KAAI,SAAAmP,GAAE,OAAIoB,EAAQpB,cAGzC,GAAsB,QAAlB9O,EAASZ,MAAoC,SAAlBY,EAASZ,KAAiB,CAE5D,IAF4D,EAEtD+V,EAAQ3U,EAAI0U,QAF0C,cAI1CC,GAJ0C,IAI5D,2BAAwB,CAAC,IAAdE,EAAa,QACpB7U,EAAIW,KAAJ,MAAAX,EAAG,YAAS6U,EAAItG,MAAMpP,KAAI,SAAAmP,GAAE,OAAIoB,EAAQpB,SALgB,+BAUhE,OADA,EAAKgC,SAASzF,IAAIoJ,GAAYzU,GAAWoS,QAAQC,QAAQ7R,IAClD,EAAK8T,SAASgB,aAAa7H,EAAMgH,GAAYzU,GAAW,CAAE8Q,SAAUtQ,EAAK+U,OAAQC,KAAKC,aApGzG,oIA6GWzT,GAAY,IAAD,OACd,GAAIxC,KAAKiO,KAAKjM,MAAM,KAAK7B,KAAI,SAAAqH,GAAC,OAAKA,KAAG+I,KAAKxH,OAAQ,MAAMmN,MAAM,gBAE/D,IAAMC,EAAO3T,EAAUrC,IAAIiW,IACrBC,EAAK,8BAA0BF,EAAK7V,KAAK,IAApC,cACLiI,EAAG,UAAM7J,GAAN,iBAAuB2X,EAAMvQ,QAAQ,KAAK,IAA1C,iBAyHjB,SAAoBmI,GAChB,IAAMzG,EAAIyG,EAAKjM,MAAM,KAAK7B,KAAI,SAAAqH,GAAC,OAAKA,KACpC,MAAM,GAAN,OAAU8O,GAAM9O,EAAE,IAAK,IAAK,KAA5B,YAAoC8O,GAAM9O,EAAE,IAAK,GAAI,IAArD,YAA4D8O,GAAM9O,EAAE,IAAK,IAAK,KAA9E,YAAsF8O,GAAM9O,EAAE,IAAK,GAAI,KA3HpC+O,CAAUvW,KAAKiO,OAQ9E,OANKjO,KAAK+U,SAASxM,KACfvI,KAAK+U,SAASxM,GAAOiO,MAAMjO,EAAIkO,YAAYpB,MAAK,SAAAnO,GAAC,OAAIA,EAAEwP,GAAKxP,EAAEyP,OAAS/D,QAAQE,OAAO5L,EAAE0P,WAASvB,MAAK,SAAAnO,GAAC,OAAIA,EAAEoK,YAE7GtR,KAAK+U,SAASxM,GAAKsO,SAAQ,yBAAa,EAAK9B,SAASxM,OAGnDvI,KAAK+U,SAASxM,KA1H7B,+BAmIc/F,GAAsB,IAAD,OAAVsU,EAAU,uDAAJ,GACvB,OAAO9W,KAAKqW,MAAM7T,GAAWuU,OAAM,SAAA1X,GAC/B,GAAU,MAANA,EAAW,MAAM6W,MAAM,gBAE3B,GAAIY,EAAQ,EACR,OAAOxC,GAAQ,KAAOe,MAAK,kBAAM,EAAKE,SAAS/S,EAAWsU,EAAQ,MAGtE,MAAMZ,MAAM,uCA3IxB,2EAmJuB1V,GAnJvB,2FAoJakU,GAAW/Q,KAAKnD,EAASZ,MApJtC,oDAsJcqC,EAAIgT,GAAYzU,IAClBR,KAAKsR,SAAS6D,IAAIlT,GAvJ9B,yCAuJyCjC,KAAKsR,SAAS6B,IAAIlR,IAvJ3D,uBAyJ+BjC,KAAK8U,SAASkC,YAAYhX,KAAKiO,KAAMhM,GAzJpE,YAyJcgV,EAzJd,gCA4JoB3F,EAAa2F,EAAb3F,SACRtR,KAAKsR,SAASzF,IAAI5J,EAAG2Q,QAAQC,QAAQvB,IA7JjD,kBA8JmBA,GA9JnB,yBAiKqCtR,KAAK8U,SAASM,eAAepV,KAAKiO,KAAMhM,GAjK7E,aAiKciV,EAjKd,gCAoKkB5F,EAAWtR,KAAK8U,SAAStB,iBAAiB0D,GAAgB7B,MAAK,SAAAnO,GAAC,OAAIA,EAAEoK,YAC5EtR,KAAKsR,SAASzF,IAAI5J,EAAGqP,GArKjC,kBAsKmBA,GAtKnB,eAyKc9J,EAAIxH,KAAKuV,SAAS,CAAC/U,IAEzBR,KAAKsR,SAASzF,IAAI5J,EAAGuF,GAErBA,EAAEuP,OAAM,kBAAM,EAAKzF,SAAS6F,OAAOlV,MAEnCuF,EAAE6N,MAAK,SAAA/D,GACH,EAAKwD,SAASgB,aAAa,EAAK7H,KAAMhM,EAAG,CAAEqP,WAAUyE,OAAQC,KAAKC,WAhL9E,kBAmLezO,GAnLf,+GAwLA,SAAS4O,GAAqB5V,GAC1B,IAAM4W,EAAQzC,GAAQhR,KAAKnD,EAASZ,MAAQ,KAAO,GACnD,MAAM,GAAN,OAAUqV,GAAYzU,GAAtB,YAAmC4W,GAIvC,SAASnC,GAAazU,GAClB,IAAMZ,EAAyB,SAAlBY,EAASZ,KAAkB,MAAQY,EAASZ,KACnDC,EAAOI,OAAOC,QAAQM,EAASX,MAAMM,KAAI,mCAAEC,EAAF,KAAIC,EAAJ,sBAAeD,EAAf,YAAoBC,EAApB,QAC/C,MAAM,GAAN,OAAUT,GAAV,OAAiBC,EAAKS,KAAK,KA+C/B,SAASgW,GAAOjW,EAAGiL,EAAKC,GACpB,OAAO7G,KAAK6G,IAAID,EAAK5G,KAAK4G,IAAIjL,EAAGkL,ICtP9B,SAAS8L,GAAY1W,EAAO2W,GAAO,MAEMvY,mBAAS4B,GAFf,mBAE/B4W,EAF+B,KAEfC,EAFe,KAqBtC,OAjBAC,qBACE,WAEE,IAAMC,EAAUlD,YAAW,WACzBgD,EAAkB7W,KACjB2W,GAKH,OAAO,WACLK,aAAaD,MAGjB,CAAC/W,EAAO2W,IAGHC,E,aCtBI,SAASK,GAAT,GAAwD,IAAnCjX,EAAkC,EAAlCA,MAAOkX,EAA2B,EAA3BA,SAAaC,EAAc,qCA+ClE,OAAO,4CAAUnX,MAAOA,EAAOkX,SAAU,SAAAxY,GAAC,OAAIwY,EAASxY,EAAEiT,OAAO3R,QAAQoX,UA3CxE,SAAwBC,GAAQ,IACpBpZ,EAAiCoZ,EAAjCpZ,IAAKqZ,EAA4BD,EAA5BC,cAAeC,EAAaF,EAAbE,SAE5B,GAAY,QAARtZ,EAAe,CACfoZ,EAAMG,iBAEN,IAAM9V,EAAI4V,EAAcG,eAClBC,EAAY1X,EAAM2X,YAAY,KAAMjW,EAAE,GAAK,EAEjD,GAAI6V,GACA,GAAmC,SAA/BvX,EAAM4X,OAAOF,EAAW,GAAe,CACvC,IAAMG,EAAW7X,EAAMc,UAAU,EAAE4W,GAAa1X,EAAMc,UAAU4W,EAAY,GAC5ER,EAASW,GAEThE,YAAW,kBAAMyD,EAAcQ,kBAAkBpW,EAAI,EAAGA,EAAI,KAAI,SAEjE,CACH,IACM0B,EAAI,GADM1B,EAAIgW,GACI,EAElBG,EAAW7X,EAAMc,UAAU,EAAEY,GAAK,OAAOZ,UAAU,EAAEsC,GAAKpD,EAAMc,UAAUY,GAChFwV,EAASW,GAEThE,YAAW,kBAAMyD,EAAcQ,kBAAkBpW,EAAI0B,EAAG1B,EAAI0B,KAAI,UAInE,GAAY,UAARnF,EAAiB,CACtBoZ,EAAMG,iBAEN,IAAM9V,EAAI4V,EAAcG,eAClBM,EAA2B,MAAf/X,EAAM0B,EAAE,GACpBgW,EAAY1X,EAAM2X,YAAY,KAAMjW,EAAE,GAAK,EAC3C3B,EAAQC,EAAMc,UAAU4W,EAAWhW,GAAG3B,MAAM,OAC5CiY,EAAStW,EAAI3B,EAAM,GAAGa,OAAS,GAAKmX,EAAY,EAAI,GAEpDF,EAAW7X,EAAMc,UAAU,EAAEY,GAAK,MAAQqW,EAAY,OAAS,IAAMhY,EAAM,GAAKC,EAAMc,UAAUY,GACtGwV,EAASW,GAEThE,YAAW,kBAAMyD,EAAcQ,kBAAkBE,EAAQA,KAAS,OAI4Bb,I,aCgE3Fc,OAxGf,WAAgB,IAAD,EACeja,EAAc,aAAc,2DAD3C,mBACLka,EADK,KACEC,EADF,OAEiBna,EAAc,cAAe,YAF9C,mBAELoL,EAFK,KAEGgP,EAFH,OAGepa,EAAc,aAAc,IAH3C,mBAGLgJ,EAHK,KAGEqR,EAHF,KAIPvH,ECfO,WAA2B,MAEd3S,IAAMC,WAFQ,mBAE9Bka,EAF8B,KAEzBC,EAFyB,KAYtC,OARApa,IAAM2Y,WAAU,WAAQ0B,UAAUC,YAAYC,mBAAmBH,KAAW,IAE5Epa,IAAM2Y,WAAU,WACZ,IAAMnI,EAAK6J,UAAUC,YAAYE,cAAcJ,GAE/C,OAAO,kBAAMC,UAAUC,YAAYG,WAAWjK,MAC/C,IAEI2J,EDGOO,GAEVC,EAAY3a,IAAM4a,SAElBC,EAAc7a,IAAM4a,SARb,EASqB5a,IAAMC,UAAS,GATpC,mBASL6a,EATK,KASKC,EATL,OAUe/a,IAAMC,SAAS,IAV9B,mBAUL+a,EAVK,KAUEC,EAVF,OAYwCN,EAAUhI,SAAW,CAAEN,YAAa,IAAMC,aAAc,KAAxFhN,EAZR,EAYL+M,YAAkC9M,EAZ7B,EAYe+M,aAEtB4I,EAAkB3C,GAAYtN,EAAQ,KACtCkQ,EAAiB5C,GAAY1P,EAAO,KAEpCsG,EAAOnP,IAAMob,SAAQ,kBAAM/L,EAAS6L,EAAgBhY,MAAM,KAAK7B,KAAI,SAAAqH,GAAC,OAAKA,KAAIyS,EAAgB,CAAC7V,EAAOC,MAAU,CAAC2V,EAAiBC,EAAgB7V,EAAOC,IAEzJsV,EAAYlI,UACfkI,EAAYlI,QAAU,IAAImD,GAAS3G,IAGrC,IAAMkM,EAAiB9C,GAAYwB,EAAO,KAEpCuB,EAActb,IAAMob,SAAQ,kBtBoH7B,SAAqBG,GAM1B,IAJA,IAAMrZ,EAAM,CAAEU,MAAO,IAEjBH,EAAS8Y,EAAU9Y,OAEhBA,EAAS,GAAG,CAAC,IAAD,IAGX+Y,EAAc9Y,EAAW6Y,IAC/B,EAAArZ,EAAIU,OAAMC,KAAV,oBAAkB2Y,EAAY5Y,QAI9B,IAAM6Y,EAAc3Z,EAHpByZ,EAAYA,EAAU5Y,UAAU6Y,EAAYpZ,OAAOgB,QAOnD,IAHA,EAAAlB,EAAIU,OAAMC,KAAV,oBAAkB4Y,EAAYtZ,gBAC9BoZ,EAAYA,EAAU5Y,UAAU8Y,EAAYrZ,OAAOgB,QAErCX,SAAWA,EAAQ,CAC/BK,QAAQC,IAAI,+BAAiCwY,GAC7C,MAGF9Y,EAAS8Y,EAAU9Y,OAGrB,OAAOP,EsB9IiCwZ,CAAWL,KAAiB,CAACA,IA8CrE,SAASM,EAAMC,EAAIC,GAEjB,IAAMC,EAAeZ,EAAgBhY,MAAM,KAAK7B,KAAI,SAAAqH,GAAC,OAAKA,KACpDqT,EAAK5M,EAAKjM,MAAM,KAAK7B,KAAI,SAAAqH,GAAC,OAAKA,KAC/BsT,GAAaD,EAAG,GAAKA,EAAG,IAAM,EAC9BE,GAAaF,EAAG,GAAKA,EAAG,IAAM,EAC9BG,EAAY,CAAEJ,EAAY,GAAKF,EAAKI,EAAWF,EAAY,GAAKD,EAAKI,GAC3EhC,EAAUiC,EAAU1a,KAAK,MAG3B,OAtDAxB,IAAM2Y,WAAU,kBAAMkC,EAAYlI,QAAQwJ,QAAQhN,KAAO,CAACA,IAG1DiN,cAAqB,WAAM,4CACzB,0CAAAlX,EAAA,6DACE6V,GAAY,GACZE,EAAS,IAFX,SAKUpX,EAAU,CAAEwY,KAAMlB,EAAgBxI,UAASrN,QAAOC,UAClD3C,EAAQgB,EAAY0X,EAAY1Y,MAAOiB,GANjD,SAOUgX,EAAYlI,QAAQ2J,gBAAgB1Z,EAAMvB,KAAI,SAAA+G,GAAC,OAAIA,EAAE1G,aAP/D,UASUL,EAAMuB,EAAMvB,KAAI,SAAAyC,GACpB,MAAO,CACLA,OACAyY,QAAS1B,EAAYlI,QAAQuF,YAAYpU,EAAKpC,eAI9CiZ,EAAUhI,QAhBlB,iBAiBMR,GAASwI,EAAUhI,SAEnB9F,EAAgBmB,qBAAqBkI,QAG/B4F,EAAeZ,EAAgBhY,MAAM,KAAK7B,KAAI,SAAAqH,GAAC,OAAKA,KAtBhE,cAwByBrH,GAxBzB,kEAwBiBmb,EAxBjB,kBAyB+BA,EAAKD,QAzBpC,QAyBc/J,EAzBd,OA0BQD,GAAUuJ,EAAaX,EAAgB3I,EAAUmI,EAAUhI,QAAS6J,EAAK1Y,KAAMD,GA1BvF,mMA8BIoX,EAAS,kBACTnY,QAAQC,IAAR,MA/BJ,yBAiCIgY,GAAY,GAjChB,4FADyB,uBAAC,WAAD,wBAsCzB0B,KACC,CAACvB,EAAiBC,EAAgBG,EAAa3I,IAahD,yBAAK+J,UAAU,OACb,yBAAKA,UAAU,WACb,yBAAKA,UAAU,YACb,4BAAQC,QAAS,kBAAMhB,GAAM,EAAE,KAA/B,UACA,4BAAQgB,QAAS,kBAAMhB,EAAK,EAAE,KAA9B,UACA,4BAAQgB,QAAS,kBAAMhB,EAAK,EAAE,KAA9B,UACA,4BAAQgB,QAAS,kBAAMhB,EAAK,GAAG,KAA/B,UACA,4BAAQgB,QAAS,kBAAMzC,EAASrR,EAAQ,KAAxC,UACA,4BAAQ8T,QAAS,kBAAMzC,EAASrR,EAAQ,KAAxC,UACE8J,GAAW,4BAAQgK,QAAS,kBAAM1C,EAAU,GAAD,OAAItH,EAAQC,OAAOC,UAAnB,YAAgCF,EAAQC,OAAOE,aAA/E,iBAEf,yCAAc,2BAAOjR,MAAOoJ,EAAQ8N,SAAU,SAAAxY,GAAC,OAAI0Z,EAAU1Z,EAAEiT,OAAO3R,WACtE,uCAAY,2BAAOf,KAAK,SAASe,MAAOgH,EAAOkQ,SAAU,SAAAxY,GAAC,OAAI2Z,GAAU3Z,EAAEiT,OAAO3R,WACjF,kBAACiX,GAAD,CAAUjX,MAAOkY,EAAOhB,SAAUiB,EAAUD,MAAO,CAAC6C,KAAK,GAAIC,YAAY,IACvE/B,GAAY,yCACZE,GAAS,uBAAGjB,MAAO,CAAC+C,MAAM,QAAS9B,IAEvC,4BAAQhJ,IAAK2I,MEpGCoC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAAStb,MACvB,2DCZNub,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,GAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBlD,WACrBA,UAAUmD,cAAcC,MACrBlH,MAAK,SAAAmH,GACJA,EAAaC,gBAEd1F,OAAM,SAAA+C,GACLlY,QAAQkY,MAAMA,EAAM4C,c","file":"static/js/main.f53bf1f7.chunk.js","sourcesContent":["\r\nexport const API_ROOT = \"https://lz4.overpass-api.de/api/interpreter\";","import React from 'react';\r\n\r\n/**\r\n * @template T\r\n * @param {string} key \r\n * @param {T} initalState \r\n * @returns {[ T, (newState: T) => void ]}\r\n */\r\nexport default function useSavedState (key, initalState) {\r\n    const [ state, setState ] = React.useState(() => {\r\n        const saved = localStorage.getItem(key);\r\n    \r\n        if (saved) {\r\n            try {\r\n                initalState = JSON.parse(saved);\r\n            } catch (e) {}\r\n        }\r\n\r\n        return initalState;\r\n    });\r\n\r\n    return [\r\n        state,\r\n        newState => {\r\n            localStorage.setItem(key, JSON.stringify(newState));\r\n            setState(newState);\r\n        }\r\n    ]\r\n}","/** \r\n * @typedef StyleRule\r\n * @property {\"rule\"} type\r\n * @property {StyleSelector} [selector]\r\n * @property {StyleSelector[]} [selectors]\r\n * @property {{ [key: string]: string }} declarations\r\n */\r\n\r\n/**\r\n * @typedef MediaQuery\r\n * @property {\"query\"} type\r\n * @property {Predicate} predicate \r\n * @property {StyleRule[]} rules\r\n */\r\n\r\n/**\r\n * @typedef Predicate\r\n * @property {string|number|Predicate} left\r\n * @property {string} operator\r\n * @property {string|number|Predicate} right\r\n */\r\n\r\nexport class StyleSelector {\r\n    /**\r\n     * @param {string} type\r\n     * @param {{ [key: string]: string }} tags\r\n     * @param {{ name: string, params: (string|Predicate)[] }[]} pseudoClasses\r\n     * @param {string} [pseudoElement]\r\n     */\r\n    constructor (type, tags, pseudoClasses=[], pseudoElement=null) {\r\n      this.type = type;\r\n      this.tags = tags;\r\n      this.pseudoClasses = pseudoClasses;\r\n      this.pseudoElement = pseudoElement;\r\n    }\r\n  \r\n    toString () {\r\n      return `${this.type}${Object.entries(this.tags).map(([k,v]) => `[${k}=${v}]`).join(\"\")}`;\r\n    }\r\n}\r\n  \r\nStyleSelector.parse = /**\r\n * @param {string} text\r\n */\r\nfunction (text) {\r\n    const re = /^\\s*([a-z]+)/;\r\n    const m = re.exec(text);\r\n  \r\n    if (!m) return null;\r\n\r\n    let type = m[1];\r\n\r\n    if (type === \"rel\") {\r\n      type = \"relation\";\r\n    }\r\n\r\n    /** @type {{ [key: string]: string }} */\r\n    const tags = {};\r\n  \r\n    let tagText = text.substring(m[0].length).trim();\r\n  \r\n    const re2 = /^\\[([^[\\]=]+)=([^[\\]=]+)\\]/;\r\n\r\n    while (true) {\r\n      const m2 = re2.exec(tagText);\r\n\r\n      if (!m2) break;\r\n\r\n      tags[m2[1]] = m2[2];\r\n\r\n      tagText = tagText.substring(m2[0].length);\r\n    }\r\n\r\n    /** @type {{ name: string, params: (string|Predicate)[] }[]} */\r\n    const pseudoClasses = [];\r\n  \r\n    const re3 = /^:([a-z-]+)(?:\\(([^)]+)\\))?/;\r\n\r\n    while (true) {\r\n      const m3 = re3.exec(tagText);\r\n\r\n      if (!m3) break;\r\n\r\n      const re = /^\\s*([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?/;\r\n      const params = m3[2] ? m3[2].split(\",\").map(s => re.test(s) ? makePredicate(re.exec(s)) : s) : [];\r\n      pseudoClasses.push({ name: m3[1], params });\r\n\r\n      tagText = tagText.substring(m3[0].length);\r\n    }\r\n\r\n    let pseudoElement = null;\r\n  \r\n    const re4 = /^::([a-z-]+)?/;\r\n\r\n    if (re4.test(tagText)) {\r\n      const m4 = re4.exec(tagText);\r\n\r\n      pseudoElement = m4[1];\r\n\r\n      tagText = tagText.substring(m4[0].length);\r\n    }\r\n\r\n    if (tagText.length) {\r\n      console.log(`Invalid selector: ${text} unexpected part: '${tagText}'`);\r\n      return null;\r\n    }\r\n  \r\n    return new StyleSelector(type, tags, pseudoClasses, pseudoElement);\r\n};\r\n  \r\n/**\r\n * \r\n * @param {string} text \r\n */\r\nStyleSelector.parseMultiple = function (text) {\r\n    return text.split(\",\").map(StyleSelector.parse).filter(x => x);\r\n}\r\n\r\n/**\r\n * \r\n * @param {{ rules: StyleRule[] }} style \r\n * @param {import(\"./Overpass\").OverpassElement} element \r\n * @returns {StyleRule}\r\n */\r\nexport function matchRule (style, element) {\r\n    for (const rule of style.rules) {\r\n      for (const selector of rule.selectors) {\r\n        if (matchSelector(selector, element))  return rule;\r\n      }\r\n    }\r\n}\r\n\r\n/**\r\n * @param {StyleSelector} selector\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n */\r\nexport function matchSelector (selector, element) {\r\n  if (element.type !== selector.type && !(selector.type === \"area\" && element.type === \"way\")) return false;\r\n\r\n  let match = true;\r\n\r\n  for (const [key, value] of Object.entries(selector.tags)) {\r\n    if (!element.tags || element.tags[key] !== value) {\r\n      match = false;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return match;\r\n}\r\n\r\n/**\r\n * @param {string} styleText\r\n */\r\nexport function parseStyle (styleText) {\r\n  /** @type {{ rules: (StyleRule|MediaQuery)[] }} */\r\n  const out = { rules: [] };\r\n\r\n  let length = styleText.length;\r\n\r\n  while (length > 0) {\r\n\r\n    // Try parsing rule list\r\n    const rulesResult = parseRules(styleText);\r\n    out.rules.push(...rulesResult.rules);\r\n    styleText = styleText.substring(rulesResult.index).trim();\r\n\r\n    // Try parsing media query\r\n    const mediaResult = parseMedia(styleText);\r\n    out.rules.push(...mediaResult.mediaQueries);\r\n    styleText = styleText.substring(mediaResult.index).trim();\r\n\r\n    if (styleText.length === length) {\r\n      console.log(\"Got stuck parsing style at: \" + styleText);\r\n      break;\r\n    }\r\n\r\n    length = styleText.length;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * @param {string} mediaText\r\n */\r\nfunction parseMedia (mediaText) {\r\n  const re = /^\\s*@match\\s*\\(([^\\s)]+)\\s*(:|=|<=|>=|<|>|and|or)\\s*([^\\s)]+)(?:\\s*(=|<=|>=|<|>)\\s*([^\\s)]+))?\\)\\s*{/;\r\n  /** @type {{ mediaQueries: MediaQuery[], index: number }} */\r\n  const out = { mediaQueries: [], index: 0 };\r\n  let match;\r\n\r\n  const re2 = /^\\s*}/;\r\n  let match2;\r\n\r\n  while (match = re.exec(mediaText)) {\r\n    const predicate = makePredicate(match);\r\n\r\n    out.index += match[0].length;\r\n\r\n    mediaText = mediaText.substring(match[0].length);\r\n\r\n    const { rules, index } = parseRules(mediaText);\r\n\r\n    out.index += index;\r\n\r\n    mediaText = mediaText.substring(index);\r\n\r\n    match2 = re2.exec(mediaText);\r\n    \r\n    if (match2) {\r\n      out.mediaQueries.push({\r\n        type: \"query\",\r\n        predicate,\r\n        rules,\r\n      });\r\n\r\n      out.index += match2[0].length;\r\n\r\n    } else {\r\n      console.log(\"Unterminated media query\");\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nfunction parseRules (ruleText) {\r\n  const re = /^\\s*([^{}]+)\\s*{([^{}]*)}/;\r\n  let match;\r\n  /** @type {{ rules: StyleRule[], index: number }} */\r\n  const out = { rules: [], index: 0 };\r\n\r\n  while(match = re.exec(ruleText)) {\r\n    /** @type {{ [key: string]: string }} */\r\n    const declarations = {};\r\n    \r\n    match[2].split(\";\").map(s => s.trim()).filter(s => s).forEach(s => {\r\n      // s.split(\":\", 2) is not the same as PHP\r\n      const i = s.indexOf(\":\");\r\n      const property = s.substring(0,i).trim();\r\n      const value = s.substring(i+1).trim();\r\n      declarations[property] = value;\r\n    });\r\n\r\n    const selectors = StyleSelector.parseMultiple(match[1]);\r\n\r\n    if (selectors.length) {\r\n      out.rules.push({\r\n        type: \"rule\",\r\n        selectors,\r\n        declarations,\r\n      });\r\n    }\r\n\r\n    out.index += match[0].length;\r\n\r\n    ruleText = ruleText.substring(match[0].length);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * \r\n * @param {(StyleRule|MediaQuery)[]} rules \r\n * @param {object} context \r\n */\r\nexport function expandRules (rules, context) {\r\n  const out = [];\r\n  for (const rule of rules) {\r\n    if (rule.type === \"rule\") {\r\n      const { declarations } = rule;\r\n      for (const selector of rule.selectors) {\r\n        out.push({ selector, declarations });\r\n      }\r\n    } else {\r\n      if (testPredicate(rule.predicate, context)) {\r\n        out.push(...expandRules(rule.rules, context));\r\n      }\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction makePredicate(match) {\r\n  let predicate;\r\n\r\n  if (match[4]) {\r\n    // MediaQueries4 syntax:\r\n    //  @match (10 < zoom <= 14)\r\n    predicate = {\r\n      left: { left: match[1], operator: match[2], right: match[3] },\r\n      operator: \"and\",\r\n      right: { left: match[3], operator: match[4], right: match[5] },\r\n    };\r\n  }\r\n  else {\r\n    // MediaQueries4 syntax:\r\n    //  @match (zoom <= 14)\r\n    // MediaQueries3 syntax:\r\n    //  @match (max-zoom: 14) [TODO - it's parsed just not handled correctly]\r\n    predicate = {\r\n      left: match[1],\r\n      operator: match[2],\r\n      right: match[3],\r\n    };\r\n  }\r\n  return predicate;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Predicate} predicate \r\n * @param {object} [context] \r\n * @returns {boolean}\r\n */\r\nexport function testPredicate (predicate, context={}) {\r\n  let left = typeof predicate.left === \"string\" || typeof predicate.left === \"number\" ? \r\n    predicate.left : testPredicate(predicate.left, context);\r\n  let right = typeof predicate.right === \"string\" || typeof predicate.right === \"number\"  ? \r\n    predicate.right : testPredicate(predicate.right, context);\r\n\r\n  if (typeof left === \"string\" && left in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[left] instanceof Function)\r\n      context[left] = context[left]();\r\n\r\n    left = context[left];\r\n  }\r\n\r\n  if (typeof right === \"string\" && right in context) {\r\n    // Lazily evaluate and replace context value\r\n    if (context[right] instanceof Function)\r\n      context[right] = context[right]();\r\n\r\n    right = context[right];\r\n  }\r\n    \r\n  const op = COMPARE[predicate.operator];\r\n\r\n  if (!op) return false;\r\n  \r\n  return op(left, right);\r\n}\r\n\r\nconst COMPARE = {\r\n  \":\": (a,b) => a == b,\r\n  \"=\": (a,b) => a == b,\r\n  \">\": (a,b) => a > b,\r\n  \"<\": (a,b) => a < b,\r\n  \">=\": (a,b) => a >= b,\r\n  \"<=\": (a,b) => a <= b,\r\n  \"and\": (a,b) => a && b,\r\n  \"or\": (a,b) => a || b,\r\n}","\r\n/**\r\n * \r\n * @param {number} x \r\n * @param {number} y \r\n * @param {number} width \r\n * @param {number} height \r\n * @returns {[number, number][]}\r\n */\r\nexport function rectToPoints(x, y, width, height) {\r\n    /** @type {[number, number][]} */\r\n    return [\r\n        [x, y],\r\n        [x, y + height],\r\n        [x + width, y + height],\r\n        [x + width, y],\r\n    ];\r\n}\r\n\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points \r\n */\r\nexport function getCrossProductArea (points) {\r\n    let sum = 0;\r\n    for (let i = 0; i < points.length - 1; i++) {\r\n        sum += points[i][0] * points[i+1][1] - points[i+1][0] * points[i][1];\r\n    }\r\n    return sum / 2;\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getArea (points) {\r\n    return Math.abs(getCrossProductArea(points));\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isAntiClockwise (points) {\r\n    return getCrossProductArea(points) > 0;\r\n}\r\n\r\n/**\r\n * @see http://paulbourke.net/geometry/polygonmesh/#clockwise\r\n * @param {[number, number][]} points\r\n */\r\nexport function isConvex (points) {\r\n    const l = points.length;\r\n    if (l < 3) return;\r\n\r\n    let sign = 0;\r\n    for (let i = 1; i < l; i++) {\r\n        const a = points[i-1];\r\n        const b = points[i];\r\n        const c = points[(i+1) % l];\r\n        \r\n        const next = Math.sign((b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]));\r\n\r\n        if (sign === 0) sign = next;\r\n        else if (next !== 0 && sign !== next) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function isSelfClosing (points) {\r\n    const f = points[0];\r\n    const l = points[points.length - 1]; \r\n    return f[0] === l[0] && f[1] === l[1];\r\n}\r\n\r\n/**\r\n * @param {[number, number][]} points\r\n */\r\nexport function getLength (points) {\r\n    let sum = 0;\r\n\r\n    for (let i = 1; i < points.length; i++) {\r\n        const dx = points[i][0] - points[i-1][0];\r\n        const dy = points[i][1] - points[i-1][1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    return sum;\r\n}","export function parseStrokeFill(rule) {\r\n    const fillStyle = rule.declarations[\"fill\"];\r\n    let strokeStyle = rule.declarations[\"stroke\"];\r\n    let lineWidth;\r\n\r\n    if (strokeStyle) {\r\n        // Numbers in e.g. rgba(128,64,0,0.2) confuse it\r\n        let mutedStyle = strokeStyle.replace(/\\([^)]*\\)/g, ss => \" \".repeat(ss.length));\r\n\r\n        // So would hex colour strings\r\n        mutedStyle = mutedStyle.replace(/#[0-9a-f]{3}/, \"    \");\r\n        mutedStyle = mutedStyle.replace(/#[0-9a-f]{6}/, \"       \");\r\n\r\n        /**\r\n         * @todo A better parser would probably be nice\r\n         */\r\n        const swRe = /(\\d+(?:\\.\\d+)?)\\s*(?:px)?/;\r\n        const sm = swRe.exec(mutedStyle);\r\n        if (sm) {\r\n            lineWidth = +sm[1] * devicePixelRatio;\r\n            strokeStyle = strokeStyle.replace(sm[0], \"\");\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"stroke-width\"]) {\r\n        lineWidth = +rule.declarations[\"stroke-width\"] * devicePixelRatio;\r\n    }\r\n\r\n    return {\r\n        fillStyle,\r\n        strokeStyle,\r\n        lineWidth,\r\n    };\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {import(\"../Style\").StyleRule} rule\r\n */\r\nexport function setStrokeFill (ctx, rule) {\r\n    const { fillStyle, strokeStyle, lineWidth } = parseStrokeFill(rule);\r\n\r\n    ctx.fillStyle = fillStyle;\r\n    ctx.strokeStyle = strokeStyle;\r\n    ctx.lineWidth = lineWidth;\r\n}","/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\nimport { setStrokeFill } from \"./parseStrokeFill\";\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} param2\r\n * @param {OverpassElement} [element]\r\n */\r\nexport function renderText(ctx, rule, [x, y], element = null) {\r\n    setStrokeFill(ctx, rule);\r\n\r\n    let content = getContent(rule, element);\r\n\r\n    setFont(ctx, rule);\r\n\r\n    if (rule.declarations[\"text-align\"]) {\r\n        const textWidth = ctx.measureText(content).width;\r\n\r\n        if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n            x -= textWidth / 2;\r\n        }\r\n        else if (rule.declarations[\"text-align\"] === \"right\") {\r\n            x -= textWidth;\r\n        }\r\n    }\r\n\r\n    if (rule.declarations[\"text-stroke\"]) {\r\n        ctx.strokeStyle = rule.declarations[\"text-stroke\"];\r\n        ctx.strokeText(content, x, y);\r\n    }\r\n\r\n    if (rule.declarations[\"text-color\"]) {\r\n        ctx.fillStyle = rule.declarations[\"text-color\"];\r\n        ctx.fillText(content, x, y);\r\n    }\r\n    else {\r\n        if (rule.declarations[\"stroke\"])\r\n            ctx.strokeText(content, x, y);\r\n        if (rule.declarations[\"fill\"] || !rule.declarations[\"stroke\"])\r\n            ctx.fillText(content, x, y);\r\n    }\r\n}\r\n\r\nexport function setFont(ctx, rule) {\r\n    let fontSize = `${10 * devicePixelRatio}px`;\r\n    let fontWeight = \"normal\";\r\n    let fontFamily = \"sans-serif\";\r\n\r\n    if (rule.declarations[\"font-size\"]) {\r\n        fontSize = rule.declarations[\"font-size\"].replace(/^\\d[\\d.]*/, m => `${+m * devicePixelRatio}`);\r\n    }\r\n\r\n    if (rule.declarations[\"font-weight\"]) {\r\n        fontWeight = rule.declarations[\"font-weight\"];\r\n    }\r\n\r\n    if (rule.declarations[\"font-family\"]) {\r\n        fontFamily = rule.declarations[\"font-family\"];\r\n    }\r\n\r\n    ctx.font = rule.declarations[\"font\"] || `${fontWeight} ${fontSize} ${fontFamily}`;\r\n}\r\n\r\n/**\r\n * @param {StyleRule} rule\r\n * @param {import(\"../Overpass\").OverpassElement} element\r\n */\r\nexport function getContent(rule, element) {\r\n    let content = rule.declarations[\"content\"];\r\n\r\n    if (!content) return \"\";\r\n\r\n    if (content.match(/^\".*\"$/g)) {\r\n        content = content.replace(/^\"|\"$/g, \"\");\r\n    }\r\n    else if (content.match(/tag\\(([^)]+)\\)/)) {\r\n        const m = content.match(/tag\\(([^)]+)\\)/);\r\n        content = element.tags[m[1]] || \"\";\r\n    }\r\n    else {\r\n        content = \"?\";\r\n    }\r\n    return content;\r\n}\r\n\r\n","/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n */\r\nexport function applyTransform(ctx, rule) {\r\n    const dpr = devicePixelRatio;\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        const r = /\\s*([a-z]+)\\(([^)]*)\\)\\s*/g;\r\n        const t = rule.declarations[\"transform\"];\r\n        let m;\r\n        while (m = r.exec(t)) {\r\n            const trans = m[1];\r\n            const params = m[2].split(\",\").map(s => ({ value: parseFloat(s) * dpr, unit: s.replace(/[-\\d.\\s]/g, \"\") }));\r\n            switch (trans) {\r\n                case \"matrix\":\r\n                    // @ts-ignore\r\n                    ctx.transform(...params.map(p => p.value));\r\n                    break;\r\n                case \"rotate\": {\r\n                    let { value, unit } = params[0];\r\n\r\n                    if (unit === \"deg\") {\r\n                        value *= Math.PI / 180;\r\n                    } else if (unit === \"turn\") {\r\n                        value *= Math.PI * 2;\r\n                    }\r\n\r\n                    ctx.rotate(value);\r\n                    break;\r\n                }\r\n                case \"scale\":\r\n                    const x = params[0].value;\r\n                    const y = params[1] ? params[1].value : x;\r\n                    ctx.scale(x, y);\r\n                    break;\r\n                case \"translate\":\r\n                    // @ts-ignore\r\n                    ctx.translate(...params.map(p => p.value));\r\n                    break;\r\n                case \"skew\":\r\n                    let { value, unit } = params[0];\r\n\r\n                    if (unit === \"rad\")\r\n                        value = Math.tan(value);\r\n                    else if (unit === \"deg\")\r\n                        value = Math.tan(value * Math.PI / 180);\r\n\r\n                    let valueY = 0;\r\n\r\n                    if (params[1]) {\r\n                        let { value, unit } = params[1];\r\n\r\n                        if (unit === \"rad\")\r\n                            value = Math.tan(value);\r\n                        else if (unit === \"deg\")\r\n                            value = Math.tan(value * Math.PI / 180);\r\n\r\n                        valueY = value;\r\n                    }\r\n\r\n                    ctx.transform(1, valueY, value, 1, 0, 0);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { renderText } from \"./renderText\";\r\nimport { globalSetup } from \".\";\r\nimport { applyTransform } from \"./transform\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number]} position\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderPoint(ctx, rule, [x, y], element = null) {\r\n    ctx.save();\r\n\r\n    ctx.fillStyle = rule.declarations[\"fill\"];\r\n    ctx.strokeStyle = rule.declarations[\"stroke\"];\r\n    ctx.lineWidth = +rule.declarations[\"stroke-width\"] * devicePixelRatio;\r\n\r\n    if (rule.declarations[\"position\"] === \"absolute\") {\r\n        x = (parseFloat(rule.declarations[\"left\"]) || 0) * devicePixelRatio;\r\n        y = (parseFloat(rule.declarations[\"top\"]) || 0) * devicePixelRatio;\r\n    }\r\n    ctx.translate(x, y);\r\n\r\n    applyTransform(ctx, rule);\r\n\r\n    if (rule.declarations[\"size\"]) {\r\n        ctx.beginPath();\r\n\r\n        const r = +rule.declarations[\"size\"] * devicePixelRatio;\r\n\r\n        ctx.ellipse(0, 0, r, r, 0, 0, Math.PI * 2);\r\n\r\n        rule.declarations[\"fill\"] && ctx.fill();\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    if (rule.declarations[\"path\"]) {\r\n        ctx.beginPath();\r\n\r\n        drawPath(ctx, rule.declarations[\"path\"]);\r\n\r\n        rule.declarations[\"fill\"] && ctx.fill();\r\n        rule.declarations[\"stroke\"] && ctx.stroke();\r\n    }\r\n\r\n    // Syntax:\r\n    //  url(<URL>) [<width> [<height>]]\r\n    //  url(https://ijmacd.github.io/map-maker/logo192.png) 90px 120px;\r\n    const urlRe = /url\\(([^)]+)\\)(?:\\s+([^\\s]+)(?:\\s+([^\\s]+))?)?/;\r\n    if (urlRe.test(rule.declarations[\"icon\"])) {\r\n        const m = urlRe.exec(rule.declarations[\"icon\"]);\r\n        const url = m[1];\r\n        const img = new Image();\r\n        img.src = url;\r\n        const w = parseFloat(m[2]);\r\n        const h = parseFloat(m[3]);\r\n\r\n\r\n        img.addEventListener(\"load\", () => {\r\n            // The image is drawn in a callback so the render context state is lost\r\n            ctx.save();\r\n            globalSetup(ctx, rule);\r\n\r\n            ctx.translate(x, y);\r\n\r\n            applyTransform(ctx, rule);\r\n\r\n            const dpr = devicePixelRatio;\r\n            if (w) {\r\n                const height = !isNaN(h) ? h : img.height * (w / img.width);\r\n                ctx.drawImage(img, 0, 0, w * dpr, height * dpr);\r\n            }\r\n            else {\r\n                ctx.drawImage(img, 0, 0);\r\n            }\r\n\r\n            ctx.restore();\r\n        });\r\n    }\r\n\r\n    if (rule.declarations[\"content\"]) {\r\n        renderText(ctx, rule, [0, 0], element);\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {string} pathSpec\r\n */\r\nfunction drawPath (ctx, pathSpec) {\r\n    const segs = /([MLQCVHZ])\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?\\s*(-?\\d+(?:\\.\\d+)?)?/ig;\r\n    let match;\r\n    /** @type {[number, number]} */\r\n    let first;\r\n    /** @type {[number, number]} */\r\n    let prev;\r\n\r\n    while (match = segs.exec(pathSpec)) {\r\n        const x = parseFloat(match[2]) * devicePixelRatio;\r\n        const y = parseFloat(match[3]) * devicePixelRatio;\r\n        const x2 = parseFloat(match[4]) * devicePixelRatio;\r\n        const y2 = parseFloat(match[5]) * devicePixelRatio;\r\n        const x3 = parseFloat(match[6]) * devicePixelRatio;\r\n        const y3 = parseFloat(match[7]) * devicePixelRatio;\r\n\r\n        if (!first) first = [x,y];\r\n\r\n        if (match[1] === \"M\") {\r\n            prev = [x,y];\r\n            ctx.moveTo(x, y);\r\n        }\r\n        else if (match[1] === \"L\") {\r\n            prev = [x,y];\r\n            ctx.lineTo(x, y);\r\n        }\r\n        else if (match[1] === \"Q\") {\r\n            prev = [x2,y2];\r\n            ctx.quadraticCurveTo(x, y, x2, y2);\r\n        }\r\n        else if (match[1] === \"C\") {\r\n            prev = [x3,y3];\r\n            ctx.bezierCurveTo(x, y, x2, y2, x3, y3);\r\n        }\r\n        else if (match[1] === \"Z\") {\r\n            prev = first;\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"V\") {\r\n            prev = [prev[0], x];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"H\") {\r\n            prev = [x, prev[1]];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"m\") {\r\n            prev = [prev[0] + x, prev[1] + y];\r\n            ctx.moveTo(...prev);\r\n        }\r\n        else if (match[1] === \"l\") {\r\n            prev = [prev[0] + x, prev[1] + y];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"q\") {\r\n            ctx.quadraticCurveTo(prev[0] + x, prev[1] + y, prev[0] + x2, prev[1] + y2);\r\n            prev = [prev[0] + x2, prev[1] + y2];\r\n        }\r\n        else if (match[1] === \"c\") {\r\n            prev = [x3,y3];\r\n            ctx.bezierCurveTo(prev[0] + x, prev[1] + y, prev[0] + x2, prev[1] + y2, prev[0] + x3, prev[1] + y3);\r\n            prev = [prev[0] + x3, prev[1] + y3];\r\n        }\r\n        else if (match[1] === \"z\") {\r\n            prev = first;\r\n            ctx.lineTo(...first);\r\n        }\r\n        else if (match[1] === \"v\") {\r\n            prev = [prev[0], prev[1] + x];\r\n            ctx.lineTo(...prev);\r\n        }\r\n        else if (match[1] === \"h\") {\r\n            prev = [prev[0] + x, prev[1]];\r\n            ctx.lineTo(...prev);\r\n        }\r\n    }\r\n}","/**\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n * @param {number} minLon\r\n * @param {number} minLat\r\n * @param {number} maxLon\r\n * @param {number} maxLat\r\n * @param {number} width\r\n * @param {number} height\r\n */\r\nexport function flatProjection(minLon, minLat, maxLon, maxLat, width, height) {\r\n    const xScale = width / (maxLon - minLon);\r\n    const yScale = height / (maxLat - minLat);\r\n    const scale = Math.max(xScale, yScale);\r\n    return ((lon, lat) => [(lon - minLon) * scale, height - (lat - minLat) * scale]);\r\n}\r\n/**\r\n * @param {[number, number]} centre\r\n * @param {number} scale\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {(lon: number, lat: number) => [number, number]}\r\n */\r\nexport function mercatorProjection(centre, scale, width, height) {\r\n    const baseTileSize = 256;\r\n\r\n    const [cLon, cLat] = centre;\r\n\r\n    const tileCount = Math.pow(2, scale);\r\n    const degPerTileH = 180 / tileCount;\r\n    const degPerTileV = 180 / tileCount;\r\n\r\n    const hPixelsPerDeg = baseTileSize / degPerTileH;\r\n    const vPixelsPerDeg = baseTileSize / degPerTileV;\r\n\r\n    const QUARTER_PI = Math.PI / 4;\r\n\r\n    const cX = width / 2;\r\n    const cY = height / 2;\r\n\r\n    const cLatPrime = Math.log(Math.tan(QUARTER_PI + (cLat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n    return (lon, lat) => {\r\n        const E = lon;\r\n        const N = Math.log(Math.tan(QUARTER_PI + (lat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n        const dLon = E - cLon;\r\n        const dLat = N - cLatPrime;\r\n\r\n        const dX = dLon * hPixelsPerDeg;\r\n        const dY = dLat * vPixelsPerDeg;\r\n\r\n        return [cX + dX, cY - dY];\r\n    };\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n */\r\n\r\nexport function getAveragePoint(points) {\r\n    const sum = points.reduce((sum, p) => [sum[0] + p[0], sum[1] + p[1]], [0, 0]);\r\n    /** @type {[number, number]} */\r\n    const avg = (sum.map(x => x / points.length));\r\n    return avg;\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n * @returns {[number, number]}\r\n */\r\n\r\nexport function getCentrePoint(points) {\r\n    const boundingBox = getBoundingBox(points);\r\n\r\n    return [\r\n        boundingBox[0] + boundingBox[2] / 2,\r\n        boundingBox[1] + boundingBox[3] / 2,\r\n    ];\r\n}\r\n/**\r\n *\r\n * @param {[number, number][]} points\r\n * @returns {[number, number]}\r\n */\r\n\r\nexport function getMidPoint(points) {\r\n    return points[Math.floor((points.length - 1) / 2)];\r\n}\r\n/**\r\n * @param {[number, number][]} points\r\n * @returns {[number, number, number, number]} (x, y, width, height)\r\n */\r\n\r\nexport function getBoundingBox(points) {\r\n    const minMax = points.reduce((minMax, point) => {\r\n        return [\r\n            Math.min(minMax[0], point[0]),\r\n            Math.min(minMax[1], point[1]),\r\n            Math.max(minMax[2], point[0]),\r\n            Math.max(minMax[3], point[1]),\r\n        ];\r\n    }, [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]);\r\n\r\n    return [\r\n        minMax[0],\r\n        minMax[1],\r\n        minMax[2] - minMax[0],\r\n        minMax[3] - minMax[1],\r\n    ];\r\n}\r\n","export default class CollisionSystem {\r\n    /** @type {CollisionSystem} */\r\n    static singleton;\r\n\r\n    constructor () {\r\n        /** @type {{ [name: string]: [number, number, number, number][] }} */\r\n        this.sets = {}\r\n    }\r\n\r\n    clear () {\r\n        this.sets = {};\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} set\r\n     * @param {[number, number, number, number]} box\r\n     */\r\n    add (set, box) {\r\n        if (!this.sets[set]) this.sets[set] = [];\r\n\r\n        for (const other of this.sets[set]) {\r\n            if (intersects(box, other)) return false;\r\n        }\r\n\r\n        this.sets[set].push(box);\r\n\r\n        return true;\r\n    }\r\n\r\n    static getCollisionSystem () {\r\n        if (!this.singleton) {\r\n            this.singleton = new CollisionSystem();\r\n        }\r\n\r\n        return this.singleton;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * [x , y, width, height]\r\n * @param {[number, number, number, number]} boxA\r\n * @param {[number, number, number, number]} boxB\r\n */\r\nfunction intersects (boxA, boxB) {\r\n    const ax1 = boxA[0];\r\n    const ay1 = boxA[1];\r\n    const ax2 = boxA[0] + boxA[2];\r\n    const ay2 = boxA[1] + boxA[3];\r\n    const bx1 = boxB[0];\r\n    const by1 = boxB[1];\r\n    const bx2 = boxB[0] + boxB[2];\r\n    const by2 = boxB[1] + boxB[3];\r\n    return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;\r\n}","import { renderPoint } from \"./renderPoint\";\r\nimport { applyTransform } from \"./transform\";\r\nimport { setStrokeFill } from \"./parseStrokeFill\";\r\nimport { getBoundingBox } from \"./util\";\r\nimport CollisionSystem from \"../CollisionSystem\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {(points: [number, number][]) => [number, number]} getPoint\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderAreaLine(ctx, rule, points, getPoint, element = null) {\r\n    if (points.length === 0)\r\n        return;\r\n\r\n\r\n    if (rule.declarations[\"collision-set\"]) {\r\n        const box = getBoundingBox(points);\r\n\r\n        const collisionSystem = CollisionSystem.getCollisionSystem();\r\n\r\n        if (!collisionSystem.add(rule.declarations[\"collision-set\"], box)) {\r\n            const policy = rule.declarations[\"collision-policy\"] || \"hide\";\r\n\r\n            if (policy === \"hide\") {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    ctx.save();\r\n\r\n    setStrokeFill(ctx, rule);\r\n\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n\r\n    if (rule.declarations[\"transform\"]) {\r\n        // Extra work required if we're transforming\r\n\r\n        // First get transform origin;\r\n        const cp = getPoint(points);\r\n\r\n        // Set offset to adjust all points later\r\n        offsetX = cp[0];\r\n        offsetY = cp[1];\r\n\r\n        // Translate the canvas\r\n        ctx.translate(offsetX, offsetY);\r\n\r\n        // Apply the transformation\r\n        applyTransform(ctx, rule);\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(points[0][0] - offsetX, points[0][1] - offsetY);\r\n    for (let i = 1; i < points.length; i++) {\r\n        ctx.lineTo(points[i][0] - offsetX, points[i][1] - offsetY);\r\n    }\r\n\r\n    rule.declarations[\"fill\"] && ctx.fill();\r\n    rule.declarations[\"stroke\"] && ctx.stroke();\r\n\r\n    ctx.restore();\r\n\r\n    // Text Handling, Icons etc.\r\n    if (rule.declarations[\"content\"] || rule.declarations[\"size\"] || rule.declarations[\"path\"] || rule.declarations[\"icon\"]) {\r\n        ctx.save();\r\n        renderPoint(ctx, rule, getPoint(points), element);\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\n\r\n","import { getMidPoint } from \"./util\";\r\nimport { renderAreaLine } from \"./renderAreaLine\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderLine(ctx, rule, points, element = null) {\r\n    renderAreaLine(ctx, rule, points, getMidPoint, element);\r\n}\r\n","import { isSelfClosing } from \"../geometry\";\r\nimport { getCentrePoint } from \"./util\";\r\nimport { renderAreaLine } from \"./renderAreaLine\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {StyleRule} rule\r\n * @param {[number, number][]} points\r\n * @param {OverpassElement} element\r\n */\r\nexport function renderArea(ctx, rule, points, element = null) {\r\n    if (points.length === 0)\r\n        return;\r\n\r\n    if (!isSelfClosing(points)) {\r\n        points = [ ...points, points[0] ];\r\n    }\r\n\r\n    renderAreaLine(ctx, rule, points, getCentrePoint, element);\r\n}\r\n","\r\n/**\r\n * Can the string be considered a valid bbox?\r\n * - Are there four parts?\r\n * - Are they all numberic?\r\n * - Are they in the correct order?\r\n * @param {string} bbox \r\n */\r\nexport function isValid (bbox) {\r\n    const parts = bbox.split(\",\");\r\n    \r\n    if (parts.length !== 4) return false;\r\n  \r\n    if (parts.some(p => isNaN(+p))) return false;\r\n  \r\n    return +parts[0] < +parts[2] && +parts[1] < +parts[3];\r\n}\r\n\r\n/**\r\n * Determines whether or not areaB is entirely contained\r\n * within areaA\r\n * @param {string} areaA \r\n * @param {string} areaB \r\n * @returns {boolean}\r\n */\r\nexport function contains (areaA, areaB) {\r\n    const [Ax1,Ay1,Ax2,Ay2] = areaA.split(\",\");\r\n    const [Bx1,By1,Bx2,By2] = areaB.split(\",\");\r\n\r\n    return (Bx1 >= Ax1 && By1 >= Ay1 && Bx2 <= Ax2 && By2 <= Ay2);\r\n}\r\n\r\n/**\r\n * Compute simple area\r\n * @param {string} bbox \r\n */\r\nexport function getArea (bbox) {\r\n    const parts = bbox.split(\",\");\r\n    return (+parts[2] - +parts[0]) * (+parts[3] - +parts[1]);\r\n}\r\n\r\n/**\r\n * \r\n * @param {[number, number]} centre \r\n * @param {number} scale \r\n * @param {[number, number]} size \r\n */\r\nexport function makeBBox (centre, scale, size) {\r\n    const baseTileSize = 256;\r\n\r\n    const [ lon, lat ] = centre;\r\n    const [ width, height ] = size;\r\n\r\n    const tileCount = Math.pow(2, scale)\r\n    const xSpan = 180 / tileCount;\r\n    const ySpan = 180 / tileCount;\r\n    \r\n    const hTileCount = width / baseTileSize;\r\n    const vTileCount = height / baseTileSize;\r\n\r\n    const dLon = xSpan * hTileCount;\r\n    const dLat = ySpan * vTileCount;\r\n\r\n    return [ lon - dLon, lat - dLat, lon + dLon, lat + dLat ].map(p => p.toFixed(3)).join(\",\");\r\n}","import { makeBBox } from \"../bbox\";\r\nimport { renderLine } from \"./renderLine\";\r\n\r\nexport function renderGridlines(ctx, rule, centre, scale, width, height, projection) {\r\n    const vertical = rule.selector.pseudoClasses.find(p => p.name === \"vertical\");\r\n    const horizontal = rule.selector.pseudoClasses.find(p => p.name === \"horizontal\");\r\n\r\n    const bbox = makeBBox(centre, scale, [width, height]);\r\n    const parts = bbox.split(\",\");\r\n\r\n    if (vertical) {\r\n        const step = parseFloat(vertical.params[0]);\r\n\r\n        const round = 1 / step;\r\n\r\n        const sigFigs = Math.ceil(Math.log10(round));\r\n\r\n        const xmin = Math.floor(+parts[0] * round) / round;\r\n        const xmax = Math.ceil(+parts[2] * round) / round;\r\n        const ymin = Math.floor(+parts[1] * round) / round;\r\n        const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n        for (let i = xmin; i <= xmax; i += step) {\r\n            const points = [ projection(i, ymin),  projection(i, (ymin + ymax) / 2), projection(i, ymax) ];\r\n            renderLine(ctx, rule, points, { type: \"way\", id: 0, nodes: [], tags: { name: i.toFixed(sigFigs) }});\r\n        }\r\n    }\r\n\r\n    if (horizontal) {\r\n        const step = parseFloat(horizontal.params[0]);\r\n\r\n        const round = 1 / step;\r\n\r\n        const sigFigs = Math.ceil(Math.log10(round));\r\n\r\n        const xmin = Math.floor(+parts[0] * round) / round;\r\n        const xmax = Math.ceil(+parts[2] * round) / round;\r\n        const ymin = Math.floor(+parts[1] * round) / round;\r\n        const ymax = Math.ceil(+parts[3] * round) / round;\r\n\r\n        for (let j = ymin; j <= ymax; j += step) {\r\n            const points = [ projection(xmin, j), projection((xmin + xmax) / 2, j), projection(xmax, j) ];\r\n            renderLine(ctx, rule, points, { type: \"way\", id: 0, nodes: [], tags: { name: j.toFixed(sigFigs) }});\r\n        }\r\n    }\r\n}\r\n","import { rectToPoints } from \"../geometry\";\r\nimport { renderPoint } from \"./renderPoint\";\r\nimport { renderArea } from \"./renderArea\";\r\nimport { getCentrePoint, getMidPoint, getAveragePoint, getBoundingBox } from \"./util\";\r\nimport { setFont, getContent } from \"./renderText\";\r\nimport { renderAreaLine } from \"./renderAreaLine\";\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {import(\"../Style\").StyleRule} rule\r\n * @param {import(\"../Overpass\").OverpassElement} element\r\n * @param {import(\"../Overpass\").OverpassNodeElement[]} nodes\r\n * @param {[number, number][]} points\r\n */\r\nexport function renderPsuedoElement(ctx, rule, element, nodes, points) {\r\n    if (rule.selector.pseudoElement === \"centre\" || rule.selector.pseudoElement === \"center\") {\r\n        // Centre of bounding box\r\n        const centrePoint = getCentrePoint(points);\r\n        renderPoint(ctx, rule, centrePoint, element);\r\n    }\r\n    else if (rule.selector.pseudoElement === \"mid-point\") {\r\n        // N/2th point (median point)\r\n        const midPoint = getMidPoint(points);\r\n        renderPoint(ctx, rule, midPoint, element);\r\n    }\r\n    else if (rule.selector.pseudoElement === \"average-point\") {\r\n        // Average of all points\r\n        const avgPoint = getAveragePoint(points);\r\n        renderPoint(ctx, rule, avgPoint, element);\r\n    }\r\n    else if (rule.selector.pseudoElement === \"start\") {\r\n        // First point\r\n        renderPoint(ctx, rule, points[0], element);\r\n    }\r\n    else if (rule.selector.pseudoElement === \"end\") {\r\n        // Last point\r\n        renderPoint(ctx, rule, points[points.length - 1], element);\r\n    }\r\n    else if (rule.selector.pseudoElement === \"centre-of-mass\") {\r\n        // TODO: calculate centre-of-mass\r\n        // const avgPoint = getCOMPoint(points);\r\n        // renderPoint(ctx, rule, avgPoint, element);\r\n    }\r\n    else if (rule.selector.pseudoElement === \"bounding-box\") {\r\n        const bounding = getBoundingBox(points);\r\n\r\n        const boundingPoints = rectToPoints(...bounding);\r\n\r\n        renderArea(ctx, rule, boundingPoints, element);\r\n    }\r\n    else if (rule.selector.pseudoElement === \"content-box\") {\r\n        setFont(ctx, rule);\r\n        const content = getContent(rule, element);\r\n        const size = ctx.measureText(content);\r\n        let [ x, y ] = points[0];\r\n        const { width, actualBoundingBoxDescent: desc, actualBoundingBoxAscent: asc } = size;\r\n        const padding = rule.declarations[\"padding\"] ? parseFloat(rule.declarations[\"padding\"]) * devicePixelRatio : 0;\r\n\r\n        if (rule.declarations[\"text-align\"] === \"center\" || rule.declarations[\"text-align\"] === \"centre\") {\r\n            x -= width / 2;\r\n        }\r\n        else if (rule.declarations[\"text-align\"] === \"right\") {\r\n            x -= width;\r\n        }\r\n\r\n        /** @type {[number, number][]} */\r\n        const boundPoints = [\r\n            [ x - padding,           y - asc - padding ],     // Top Left\r\n            [ x - padding,           y + desc + padding ],    // Bottom left\r\n            [ x + width + padding,   y + desc + padding ],    // Bottom right\r\n            [ x + width + padding,   y - asc - padding ],     // Top Right\r\n        ];\r\n\r\n        // Close self\r\n        boundPoints.push(boundPoints[0]);\r\n\r\n        renderAreaLine(ctx, rule, boundPoints, () => points[0], element);\r\n    }\r\n}\r\n","import { getArea, isConvex, isAntiClockwise, getLength } from \"../geometry\";\r\nimport { testPredicate } from \"../Style\";\r\nimport { getBoundingBox } from \"./util\";\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n\r\n/**\r\n * @param {StyleRule} rule\r\n * @param {import(\"../Overpass\").OverpassElement} element\r\n */\r\nexport function matchPsuedoClasses(rule, element, nodes = null, points = null) {\r\n    const { selector } = rule;\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"convex\")) {\r\n        if (!isConvex(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"concave\")) {\r\n        if (isConvex(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"clockwise\")) {\r\n        if (isAntiClockwise(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"anti-clockwise\")) {\r\n        if (!isAntiClockwise(points))\r\n            return false;\r\n    }\r\n\r\n    if (includesPseudoClass(selector, \"is\", \"self-closing\")) {\r\n        if (nodes[0] !== nodes[points.length - 1])\r\n            return false;\r\n    }\r\n\r\n    const hasPseudoClasses = selector.pseudoClasses.filter(c => c.name === \"has\");\r\n\r\n    for (const pc of hasPseudoClasses) {\r\n        if (typeof pc.params[0] === \"string\")\r\n            return false;\r\n\r\n        const predicate = pc.params[0];\r\n\r\n        // Functions for lazy evaluation\r\n        const context = {\r\n            area: () => getArea(points),\r\n            length: () => getLength(points),\r\n            width: () => getBoundingBox(points)[2],\r\n            height: () => getBoundingBox(points)[3],\r\n        };\r\n\r\n        const match = testPredicate(predicate, context);\r\n\r\n        if (!match) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * @todo Add support for more than one paramater\r\n * @param {import(\"../Overpass\").StyleSelector} selector\r\n * @param {string} name\r\n * @param  {...string} params\r\n */\r\nfunction includesPseudoClass (selector, name, ...params) {\r\n    return selector.pseudoClasses.some(c => c.name === name && c.params[0] === params[0]);\r\n}","\r\n\r\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {import(\"../Style\").StyleRule} rule\r\n * @param {import(\"../Overpass\").OverpassRelElement} element\r\n * @param {{ [id: string]: import(\"../Overpass\").OverpassWayElement; }} wayMap\r\n * @param {{ [id: string]: import(\"../Overpass\").OverpassNodeElement; }} nodeMap\r\n * @param { (lon: number, lat: number) => [number, number] } projection\r\n */\r\nexport function renderRelation(ctx, rule, element, wayMap, nodeMap, projection) {\r\n    ctx.fillStyle = rule.declarations[\"fill\"];\r\n    ctx.strokeStyle = rule.declarations[\"stroke\"];\r\n    ctx.lineWidth = +rule.declarations[\"stroke-width\"] * devicePixelRatio;\r\n\r\n    // As long as outer ways go anti-clockwise and inner rings go clockwise\r\n    // (or possibly vice-versa) then the CanvasRenderingContext2D can handle\r\n    // rending \"holes\".\r\n    ctx.beginPath();\r\n\r\n    const outerWays = element.members.filter(m => m.type === \"way\" && m.role === \"outer\").map(m => wayMap[m.ref]);\r\n    const innerWays = element.members.filter(m => m.type === \"way\" && m.role === \"inner\").map(m => wayMap[m.ref]);\r\n\r\n    let started = false;\r\n    for (const way of outerWays) {\r\n        const nodes = way.nodes.map(id => nodeMap[id]);\r\n\r\n        if (!started) {\r\n            ctx.moveTo(...projection(nodes[0].lon, nodes[0].lat));\r\n            started = true;\r\n        }\r\n        for (let i = 1; i < nodes.length; i++) {\r\n            ctx.lineTo(...projection(nodes[i].lon, nodes[i].lat));\r\n        }\r\n    }\r\n\r\n    started = false;\r\n    for (const way of innerWays) {\r\n        const nodes = way.nodes.map(id => nodeMap[id]);\r\n\r\n        if (!started) {\r\n            ctx.moveTo(...projection(nodes[0].lon, nodes[0].lat));\r\n            started = true;\r\n        }\r\n        for (let i = 1; i < nodes.length; i++) {\r\n            ctx.lineTo(...projection(nodes[i].lon, nodes[i].lat));\r\n        }\r\n    }\r\n\r\n    // ctx.closePath();\r\n\r\n    rule.declarations[\"fill\"] && ctx.fill();\r\n    rule.declarations[\"stroke\"] && ctx.stroke();\r\n}\r\n","import { rectToPoints } from \"../geometry\";\r\nimport { renderPoint } from \"./renderPoint\";\r\nimport { renderLine } from \"./renderLine\";\r\nimport { renderArea } from \"./renderArea\";\r\nimport { renderText } from \"./renderText\";\r\nimport { renderGridlines } from \"./renderGridlines\";\r\nimport { renderPsuedoElement } from \"./renderPsuedoElement\";\r\nimport { mercatorProjection, getCentrePoint, getMidPoint } from \"./util\";\r\nimport { matchPsuedoClasses } from \"./matchPsuedoClasses\";\r\nimport { renderRelation } from \"./renderRelation\";\r\n\r\n/**\r\n * @param {HTMLCanvasElement} canvas\r\n */\r\nexport function clearMap (canvas) {\r\n    const { clientWidth, clientHeight } = canvas;\r\n\r\n    const width = clientWidth * devicePixelRatio;\r\n    const height = clientHeight * devicePixelRatio;\r\n\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n}\r\n\r\n/** @typedef {import(\"../Style\").StyleRule} StyleRule */\r\n/** @typedef {import(\"../Overpass\").OverpassElement} OverpassElement */\r\n\r\n/**\r\n * @param {[number,number]} centre\r\n * @param {number} scale\r\n * @param {import(\"../Overpass\").OverpassElement[]} elements\r\n * @param {HTMLCanvasElement} canvas\r\n * @param {import(\"../Style\").StyleRule} rule\r\n * @param {{ zoom: number, current: Position }} context\r\n */\r\nexport function renderMap (centre, scale, elements=[], canvas, rule, context) {\r\n    // Prepare node map\r\n    /** @type {{ [id: number]: import(\"../Overpass\").OverpassNodeElement }} */\r\n    const nodeMap = {};\r\n    elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n    // Prepare way map\r\n    /** @type {{ [id: number]: import(\"../Overpass\").OverpassWayElement }} */\r\n    const wayMap = {};\r\n    elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    const { clientWidth, clientHeight } = canvas;\r\n\r\n    const width = clientWidth * devicePixelRatio;\r\n    const height = clientHeight * devicePixelRatio;\r\n\r\n    /** @type {(lon: number, lat: number) => [number, number]} */\r\n    const projection = mercatorProjection(centre, scale, width, height);\r\n\r\n    ctx.save();\r\n\r\n    // Set up global context options\r\n    globalSetup(ctx, rule);\r\n\r\n    const { type } = rule.selector;\r\n\r\n    // Non-Overpass Types first\r\n    switch (type) {\r\n        case \"map\": {\r\n            const points = rectToPoints(0, 0, width, height);\r\n            if (rule.selector.pseudoElement)\r\n                renderPsuedoElement(ctx, rule, null, null, points);\r\n            else\r\n                renderArea(ctx, rule, points);\r\n            break;\r\n        }\r\n        case \"current\": {\r\n            if (context.current) {\r\n                const { coords } = context.current;\r\n                renderPoint(ctx, rule, projection(coords.longitude, coords.latitude));\r\n            }\r\n            break;\r\n        }\r\n        case \"gridlines\": {\r\n            renderGridlines(ctx, rule, centre, scale, width, height, projection);\r\n            break;\r\n        }\r\n        case \"dummy\": {\r\n            renderPoint(ctx, rule, [0, 0]);\r\n            break;\r\n        }\r\n        default:\r\n            // Then iterate all elements\r\n            for (const el of elements) {\r\n                switch (type) {\r\n                    case \"node\": {\r\n                        if (el.type !== \"node\") continue;\r\n\r\n                        const point = projection(el.lon, el.lat);\r\n\r\n                        if (rule.selector.pseudoElement) {\r\n                            renderPsuedoElement(ctx, rule, el, [el], [point]);\r\n                        }\r\n                        else {\r\n                            renderPoint(ctx, rule, point, el);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"way\":\r\n                    case \"area\": {\r\n                        if (el.type !== \"way\") continue;\r\n\r\n                        /** @type {import(\"../Overpass\").OverpassNodeElement[]} */\r\n                        const nodes = el.nodes.map(id => nodeMap[id]);\r\n                        const points = nodes.map(n => projection(n.lon, n.lat));\r\n\r\n                        if (!matchPsuedoClasses(rule, el, nodes, points)) continue;\r\n\r\n                        if (rule.selector.pseudoElement) {\r\n                            renderPsuedoElement(ctx, rule, el, nodes, points);\r\n                        }\r\n                        else {\r\n                            // Render actual way/area\r\n                            if (type === \"area\") {\r\n                                renderArea(ctx, rule, points, el);\r\n                            } else {\r\n                                renderLine(ctx, rule, points, el);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"relation\": {\r\n                        if (el.type !== \"relation\") continue;\r\n\r\n                        renderRelation(ctx, rule, el, wayMap, nodeMap, projection);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n    }\r\n\r\n    ctx.restore();\r\n}\r\n\r\nexport function globalSetup(ctx, rule) {\r\n    if (rule.declarations[\"opacity\"])\r\n        ctx.globalAlpha = +rule.declarations[\"opacity\"];\r\n\r\n    if (rule.declarations[\"position\"] === \"relative\") {\r\n        const top = (parseFloat(rule.declarations[\"top\"]) || 0) * devicePixelRatio;\r\n        const left = (parseFloat(rule.declarations[\"left\"]) || 0) * devicePixelRatio;\r\n\r\n        ctx.translate(left, top);\r\n    }\r\n}\r\n","import { contains, getArea } from \"./bbox\";\r\n\r\nexport default class IDBElementDatabase {\r\n    constructor (name=\"OverpassElements\") {\r\n        const request = indexedDB.open(name);\r\n\r\n        request.addEventListener(\"upgradeneeded\", ev => {\r\n            /** @type {IDBOpenDBRequest} */\r\n            const request = (ev.target);\r\n            const db = request.result;\r\n            db.createObjectStore(\"nodes\", { keyPath: \"id\" });\r\n\r\n            const store = db.createObjectStore(\"elements\");\r\n            store.createIndex(\"selectorIndex\", [\"selector\", \"area\", \"bbox\"], { unique: false });\r\n        });\r\n\r\n        /** @type {Promise<IDBDatabase>} */\r\n        this.db = new Promise((resolve, reject) => {\r\n            request.addEventListener(\"success\", ev => {\r\n                /** @type {IDBOpenDBRequest} */\r\n                const request = (ev.target);\r\n                resolve(request.result);\r\n            });\r\n\r\n            request.addEventListener(\"error\", reject);\r\n        })\r\n\r\n    }\r\n\r\n    async saveNodes (nodes) {\r\n        const db = await this.db;\r\n        const store = db.transaction(\"nodes\", \"readwrite\").objectStore(\"nodes\");\r\n        for (const n of nodes) {\r\n            store.put(n);\r\n        }\r\n    }\r\n\r\n    async getNode (id) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const store = db.transaction(\"nodes\", \"readonly\").objectStore(\"nodes\");\r\n            const request = store.get(id);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", e => reject(e));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number[]} ids \r\n     */\r\n    getNodes (ids) {\r\n        return Promise.all(ids.map(id => this.getNode(id)));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} bbox \r\n     * @param {string} selector \r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    getElements (bbox, selector) {\r\n        const key = makeKey(bbox, selector);\r\n        return this.getElementsByKey(key);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} key \r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    async getElementsByKey (key) {\r\n        const db = await this.db;\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const request = objectStore.get(key);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} bbox \r\n     * @param {string} selector \r\n     * @returns {Promise<string>}\r\n     */\r\n    async searchElements (bbox, selector) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const index = objectStore.index(\"selectorIndex\");\r\n            const range = IDBKeyRange.bound([selector,0,\"0\"], [selector,Number.MAX_VALUE,\"999999999999999999\"]);\r\n            const request = index.openKeyCursor(range);\r\n            let count = 0;\r\n            request.addEventListener(\"success\", e => {\r\n                const cursor = request.result;\r\n                \r\n                if (cursor) {\r\n                    const { key, primaryKey } = cursor;\r\n                    const keyBBox = key[2];\r\n                    count++;\r\n                    if (contains(keyBBox, bbox)) {\r\n                        console.debug(`${selector} found after checking ${count} records`);\r\n                        resolve(primaryKey);\r\n                        return;\r\n                    }\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    console.debug(`${selector} not found after checking ${count} records`);\r\n                    resolve(null);\r\n                }\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} bbox \r\n     * @param {string} selector \r\n     * @param {{ elements: import(\"./Overpass\").OverpassElement[], cached: number }} record \r\n     */\r\n    async saveElements (bbox, selector, record) {\r\n        const db = await this.db;\r\n        const key = makeKey(bbox, selector);\r\n        const area = getArea(bbox);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readwrite\").objectStore(\"elements\");\r\n            const request = objectStore.put({ selector, bbox, area, ...record }, key);\r\n            request.addEventListener(\"success\", () => {\r\n                console.debug(`Saved ${selector}/${bbox} to database with ${record.elements.length} elements`);\r\n                resolve();\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n}\r\n\r\nfunction makeKey (bbox, selector) {\r\n    const bkey = bbox.split(\",\").map(p => (+p).toFixed(3)).join(\",\");\r\n    return `${selector}/${bkey}`;\r\n}\r\n","export function timeout (duration) {\r\n    return new Promise(resolve => setTimeout(resolve, duration));\r\n}","import IDBElementDatabase from \"./database.idb\";\r\nimport { contains } from \"./bbox\";\r\nimport { matchSelector } from \"./Style\";\r\nimport { timeout } from './util';\r\n\r\n/** @typedef {import(\"./Style\").StyleSelector} StyleSelector */\r\n\r\nconst API_ROOT = require(\"./const\").API_ROOT;\r\n\r\nconst overpassRe = /^(node|way|rel(?:ation)?|area)/;\r\nconst recurRe = /^(way|rel(?:ation)?|area)/;\r\n\r\nexport class Overpass {\r\n    constructor (bbox) {\r\n        /** @type {Map<string, Promise<OverpassElement[]>>} */\r\n        this.elements = new Map();\r\n        this.bbox = bbox;\r\n        this.database = new IDBElementDatabase();\r\n        /** @type {{ [url: string]: Promise<OverpassElement[]> }} */\r\n        this.fetchMap = {};\r\n    }\r\n\r\n    setBBox (bbox) {\r\n        // If the new bbox is completely contained within the\r\n        // old one then we don't need to clear our cache\r\n        if (!contains(this.bbox, bbox)) {\r\n            this.elements.clear();\r\n        }\r\n        this.bbox = bbox;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     */\r\n    async preLoadElements (selectors) {\r\n        const { bbox } = this;\r\n\r\n        // Create set of selectors\r\n        /** @type {{ [key: string]: StyleSelector }} */\r\n        const set = {};\r\n        selectors.forEach(s => set[mapSelector(s)] = s);\r\n\r\n        console.debug(`Preloading Elements: ${selectors.length} requested (${Object.keys(set).length} unique)`);\r\n\r\n        // Remove non-overpass selectors\r\n        for (const [key, selector] of Object.entries(set)) {\r\n            if (!overpassRe.test(selector.type)) delete set[key];\r\n        }\r\n        console.debug(`Preloading Elements: ${Object.keys(set).length} are Overpass Elements`);\r\n\r\n        // Remove selectors found in local hash map cache\r\n        for (const key of Object.keys(set)) {\r\n            if (this.elements.has(key)) delete set[key];\r\n        }\r\n        console.debug(`Preloading Elements: ${Object.keys(set).length} not in HashMap`);\r\n\r\n        // Remove selectors which were found in database\r\n        await Promise.all(Object.keys(set).map(s => {\r\n            return this.database.searchElements(bbox, s)\r\n                .then(els => {\r\n                    if (els) delete set[s];\r\n                });\r\n        }));\r\n        console.debug(`Preloading Elements: ${Object.keys(set).length} not in Database`);\r\n\r\n        if (Object.keys(set).length === 0) return;\r\n\r\n        const elements = await this.tryQuery(Object.values(set));\r\n\r\n        console.log(`Preloading Elements: Fetched ${elements.length} elements from Server`);\r\n\r\n        // Prepare node map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n        const nodeMap = {};\r\n        elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n        // Prepare way map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n        const wayMap = {};\r\n        elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n        return Promise.all(Object.values(set).map(selector => {\r\n            const out = elements.filter(el => matchSelector(selector, el));\r\n\r\n            if (selector.type === \"relation\") {\r\n                /** @type {OverpassRelElement[]} */\r\n                const rels = (out.slice());\r\n\r\n                /** @type {OverpassWayElement[]} */\r\n                const ways = [];\r\n\r\n                for (const rel of rels) {\r\n                    const refs = rel.members.map(m => m.ref);\r\n                    ways.push(...refs.map(id => wayMap[id]));\r\n                }\r\n\r\n                out.push(...ways);\r\n\r\n                for (const way of ways) {\r\n                    out.push(...way.nodes.map(id => nodeMap[id]));\r\n                }\r\n\r\n            } else if (selector.type === \"way\" || selector.type === \"area\") {\r\n                /** @type {OverpassWayElement[]} */\r\n                const ways = (out.slice());\r\n\r\n                for (const way of ways) {\r\n                    out.push(...way.nodes.map(id => nodeMap[id]));\r\n                }\r\n            }\r\n\r\n            this.elements.set(mapSelector(selector), Promise.resolve(out));\r\n            return this.database.saveElements(bbox, mapSelector(selector), { elements: out, cached: Date.now() });\r\n        }));\r\n        }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    query (selectors) {\r\n        if (this.bbox.split(\",\").map(p => +p).some(isNaN)) throw Error(\"Invalid BBox\");\r\n\r\n        const sMap = selectors.map(mapSelectorForQuery);\r\n        const query = `[out:json][bbox];\\n(${sMap.join(\"\")}\\n);\\nout;`\r\n        const url = `${API_ROOT}?data=${query.replace(/\\s/,\"\")}&bbox=${clampBBox(this.bbox)}`;\r\n\r\n        if (!this.fetchMap[url]) {;\r\n            this.fetchMap[url] = fetch(url.toString()).then(r => r.ok ? r.json() : Promise.reject(r.status)).then(r => r.elements);\r\n\r\n            this.fetchMap[url].finally(() => delete this.fetchMap[url]);\r\n        }\r\n\r\n        return this.fetchMap[url];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {StyleSelector[]} selectors\r\n     * @param {number} tries\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    tryQuery (selectors, tries=10) {\r\n        return this.query(selectors).catch(e => {\r\n            if (e !== 429) throw Error(\"Bad Response\");\r\n\r\n            if (tries > 0) {\r\n                return timeout(10000).then(() => this.tryQuery(selectors, tries - 1))\r\n            }\r\n\r\n            throw Error(\"Too many retries fetching data\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {import(\"./Style\").StyleSelector} selector\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    async getElements (selector) {\r\n        if (!overpassRe.test(selector.type)) return;\r\n\r\n        const s = mapSelector(selector);\r\n        if (this.elements.has(s)) return this.elements.get(s);\r\n\r\n        const dbResult = await this.database.getElements(this.bbox, s);\r\n\r\n        if (dbResult) {\r\n            const { elements } = dbResult;\r\n            this.elements.set(s, Promise.resolve(elements));\r\n            return elements;\r\n        }\r\n\r\n        const dbSearchResult = await this.database.searchElements(this.bbox, s);\r\n\r\n        if (dbSearchResult) {\r\n            const elements = this.database.getElementsByKey(dbSearchResult).then(r => r.elements);\r\n            this.elements.set(s, elements);\r\n            return elements;\r\n        }\r\n\r\n        const p = this.tryQuery([selector]);\r\n\r\n        this.elements.set(s, p);\r\n\r\n        p.catch(() => this.elements.delete(s));\r\n\r\n        p.then(elements => {\r\n            this.database.saveElements(this.bbox, s, { elements, cached: Date.now() });\r\n        });\r\n\r\n        return p;\r\n    }\r\n}\r\n\r\n/** @param {StyleSelector} selector */\r\nfunction mapSelectorForQuery (selector) {\r\n    const recur = recurRe.test(selector.type) ? \">;\" : \"\";\r\n    return `${mapSelector(selector)};${recur}`;\r\n}\r\n\r\n/** @param {StyleSelector} selector */\r\nfunction mapSelector (selector) {\r\n    const type = selector.type === \"area\" ? \"way\" : selector.type;\r\n    const tags = Object.entries(selector.tags).map(([k,v]) => `[${k}=${v}]`);\r\n    return `${type}${tags.join(\"\")}`;\r\n}\r\n\r\n/** @typedef {import('./Style.js').StyleRule} StyleRule */\r\n\r\n/**\r\n * @typedef {OverpassNodeElement|OverpassWayElement|OverpassAreaElement|OverpassRelElement} OverpassElement\r\n */\r\n\r\n/**\r\n * @typedef OverpassNodeElement\r\n * @property {number} id\r\n * @property {\"node\"} type\r\n * @property {number} lon\r\n * @property {number} lat\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassWayElement\r\n * @property {number} id\r\n * @property {\"way\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassAreaElement\r\n * @property {number} id\r\n * @property {\"area\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassRelElement\r\n * @property {number} id\r\n * @property {\"relation\"} type\r\n * @property {{ ref: number, role: \"inner\"|\"outer\", type: \"node\"|\"way\"|\"relation\" }[]} members\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\nfunction clampBBox (bbox) {\r\n    const p = bbox.split(\",\").map(p => +p);\r\n    return `${clamp(p[0], -180, 180)},${clamp(p[1], -90, 90)},${clamp(p[2], -180, 180)},${clamp(p[3], -90, 90)}`;\r\n}\r\n\r\nfunction clamp (v, min, max) {\r\n    return Math.max(min, Math.min(v, max));\r\n}","import { useState, useEffect } from 'react';\r\n\r\n/**\r\n * @link https://usehooks.com/useDebounce/\r\n * @param {any} value \r\n * @param {number} delay \r\n */\r\nexport function useDebounce(value, delay) {\r\n    // State and setters for debounced value\r\n    const [debouncedValue, setDebouncedValue] = useState(value);\r\n  \r\n    useEffect(\r\n      () => {\r\n        // Update debounced value after delay\r\n        const handler = setTimeout(() => {\r\n          setDebouncedValue(value);\r\n        }, delay);\r\n  \r\n        // Cancel the timeout if value changes (also on delay change or unmount)\r\n        // This is how we prevent debounced value from updating if value is changed ...\r\n        // .. within the delay period. Timeout gets cleared and restarted.\r\n        return () => {\r\n          clearTimeout(handler);\r\n        };\r\n      },\r\n      [value, delay] // Only re-call effect if value or delay changes\r\n    );\r\n  \r\n    return debouncedValue;\r\n  }","import React from 'react';\r\n\r\n/**\r\n * \r\n * @param {{ value: string, onChange: (event) => void, [key: string]: any }} param0 \r\n */\r\nexport default function Textarea ({ value, onChange, ...otherProps }) {\r\n    /**\r\n     * @param {React.KeyboardEvent<HTMLTextAreaElement>} event\r\n     */\r\n    function handleKeyDown (event) {\r\n        const { key, currentTarget, shiftKey } = event;\r\n    \r\n        if (key === \"Tab\") {\r\n            event.preventDefault();\r\n    \r\n            const i = currentTarget.selectionStart;\r\n            const lineStart = value.lastIndexOf(\"\\n\", i-1) + 1;\r\n\r\n            if (shiftKey) {\r\n                if (value.substr(lineStart, 4) === \"    \") {\r\n                    const newValue = value.substring(0,lineStart) + value.substring(lineStart + 4);\r\n                    onChange(newValue);\r\n                    \r\n                    setTimeout(() => currentTarget.setSelectionRange(i - 4, i - 4), 10);\r\n                }\r\n            } else {\r\n                const linePos = i - lineStart;\r\n                const x = 4 - linePos % 4;\r\n\r\n                const newValue = value.substring(0,i) + \"    \".substring(0,x) + value.substring(i);\r\n                onChange(newValue);\r\n                \r\n                setTimeout(() => currentTarget.setSelectionRange(i + x, i + x), 10);\r\n            }\r\n        }\r\n    \r\n        else if (key === \"Enter\") {\r\n            event.preventDefault();\r\n\r\n            const i = currentTarget.selectionStart;\r\n            const addIndent = value[i-1] === \"{\";\r\n            const lineStart = value.lastIndexOf(\"\\n\", i-1) + 1;\r\n            const match = value.substring(lineStart, i).match(/^ */);\r\n            const newPos = i + match[0].length + 1 + (addIndent ? 4 : 0);\r\n\r\n            const newValue = value.substring(0,i) + \"\\n\" + (addIndent ? \"    \" : \"\") + match[0] + value.substring(i);\r\n            onChange(newValue);\r\n\r\n            setTimeout(() => currentTarget.setSelectionRange(newPos, newPos), 10);\r\n        }\r\n    }\r\n\r\n    return <textarea value={value} onChange={e => onChange(e.target.value)} onKeyDown={handleKeyDown} {...otherProps} />;\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport useSavedState from './useSavedState';\r\nimport { parseStyle, expandRules } from './Style';\r\nimport { renderMap, clearMap } from './render';\r\nimport { Overpass } from './Overpass';\r\nimport { useDebounce } from './useDebounce';\r\nimport { makeBBox } from './bbox';\r\nimport useGeolocation from './useGeolocation';\r\nimport Textarea from './Textarea';\r\nimport useDeepCompareEffect from 'use-deep-compare-effect';\r\nimport CollisionSystem from './CollisionSystem';\r\n\r\nfunction App() {\r\n  const [ style, setStyle ] = useSavedState(\"USER_STYLE\", \"node[amenity=post_box] {\\n\\tfill: black;\\n\\tsize: 2;\\n}\");\r\n  const [ centre, setCentre ] = useSavedState(\"USER_CENTRE\", \"7.1,50.7\");\r\n  const [ scale, setScale ] = useSavedState(\"USER_SCALE\", 14);\r\n  const current = useGeolocation();\r\n  /** @type {React.MutableRefObject<HTMLCanvasElement>} */\r\n  const canvasRef = React.useRef();\r\n  /** @type {React.MutableRefObject<Overpass>} */\r\n  const overpassRef = React.useRef();\r\n  const [ fetching, setFetching ] = React.useState(false);\r\n  const [ error, setError ] = React.useState(\"\");\r\n\r\n  const { clientWidth: width, clientHeight: height } = canvasRef.current || { clientWidth: 1000, clientHeight: 1000 };\r\n\r\n  const debouncedCentre = useDebounce(centre, 500);\r\n  const debouncedScale = useDebounce(scale, 500);\r\n\r\n  const bbox = React.useMemo(() => makeBBox(debouncedCentre.split(\",\").map(p => +p), debouncedScale, [width, height]), [debouncedCentre, debouncedScale, width, height]);\r\n\r\n  if (!overpassRef.current) {\r\n    overpassRef.current = new Overpass(bbox);\r\n  }\r\n\r\n  const debouncedStyle = useDebounce(style, 500);\r\n\r\n  const parsedStyle = React.useMemo(() => parseStyle(debouncedStyle), [debouncedStyle]);\r\n\r\n  React.useEffect(() => overpassRef.current.setBBox(bbox), [bbox]);\r\n\r\n  // Refetch/Render map when bbox, or style change\r\n  useDeepCompareEffect(() => {\r\n    async function run () {\r\n      setFetching(true);\r\n      setError(\"\");\r\n\r\n      try {\r\n        const context = { zoom: debouncedScale, current, width, height };\r\n        const rules = expandRules(parsedStyle.rules, context);\r\n        await overpassRef.current.preLoadElements(rules.map(r => r.selector));\r\n\r\n        const map = rules.map(rule => {\r\n          return {\r\n            rule,\r\n            promise: overpassRef.current.getElements(rule.selector),\r\n          }\r\n        });\r\n\r\n        if (canvasRef.current) {\r\n          clearMap(canvasRef.current);\r\n\r\n          CollisionSystem.getCollisionSystem().clear();\r\n\r\n          /** @type {[number, number]} */\r\n          const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\r\n\r\n          for (const item of map) {\r\n            const elements = await item.promise;\r\n            renderMap(centrePoint, debouncedScale, elements, canvasRef.current, item.rule, context);\r\n          }\r\n        }\r\n      } catch (e) {\r\n        setError(\"Error Fetching\");\r\n        console.log(e);\r\n      } finally {\r\n        setFetching(false);\r\n      }\r\n    }\r\n\r\n    run();\r\n  }, [debouncedCentre, debouncedScale, parsedStyle, current]);\r\n\r\n  function move (dX, dY) {\r\n    /** @type {[number, number]} */\r\n    const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\r\n    const bb = bbox.split(\",\").map(p => +p);\r\n    const stepSizeX = (bb[2] - bb[0]) / 2;\r\n    const stepSizeY = (bb[3] - bb[1]) / 2;\r\n    const newCentre = [ centrePoint[0] + dX * stepSizeX, centrePoint[1] + dY * stepSizeY ];\r\n    setCentre(newCentre.join(\",\"));\r\n  }\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"sidebar\">\r\n        <div className=\"controls\">\r\n          <button onClick={() => move(-1,0)}>⏴</button>\r\n          <button onClick={() => move(1,0)}>⏵</button>\r\n          <button onClick={() => move(0,1)}>⏶</button>\r\n          <button onClick={() => move(0,-1)}>⏷</button>\r\n          <button onClick={() => setScale(scale + 1)}>➕</button>\r\n          <button onClick={() => setScale(scale - 1)}>➖</button>\r\n          { current && <button onClick={() => setCentre(`${current.coords.longitude},${current.coords.latitude}`)}>📍</button> }\r\n        </div>\r\n        <label>Centre <input value={centre} onChange={e => setCentre(e.target.value)} /></label>\r\n        <label>Zoom <input type=\"number\" value={scale} onChange={e => setScale(+e.target.value)} /></label>\r\n        <Textarea value={style} onChange={setStyle} style={{flex:1}} spellCheck={false} />\r\n        { fetching && <p>Loading...</p> }\r\n        { error && <p style={{color:\"red\"}}>{error}</p> }\r\n      </div>\r\n      <canvas ref={canvasRef} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\n\r\nexport default function useGeolocation () {\r\n    /** @type {[Position, (newPos: Position) => void]} */\r\n    const [ loc, setLoc ] = React.useState();\r\n\r\n    React.useEffect(() => { navigator.geolocation.getCurrentPosition(setLoc) }, []);\r\n\r\n    React.useEffect(() => {\r\n        const id = navigator.geolocation.watchPosition(setLoc);\r\n\r\n        return () => navigator.geolocation.clearWatch(id);\r\n    }, []);\r\n\r\n    return loc;\r\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}