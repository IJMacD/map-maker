{"version":3,"sources":["const.js","useSavedState.js","Style.js","bbox.js","render.js","database.idb.js","Overpass.js","useDebounce.js","App.js","useLocation.js","serviceWorker.js","index.js"],"names":["API_ROOT","useSavedState","key","initalState","React","useState","saved","localStorage","getItem","JSON","parse","e","state","setState","newState","setItem","stringify","StyleSelector","type","tags","pseudoClasses","this","Object","entries","map","k","v","join","matchSelector","selector","element","match","value","parseMedia","mediaText","match2","re","out","mediaQueries","index","re2","exec","predicate","left","trim","operator","right","length","parseRules","substring","rules","push","console","log","ruleText","declarations","split","s","filter","forEach","i","indexOf","property","selectors","parseMultiple","expandRules","context","rule","testPredicate","COMPARE","zoom","text","m","tagText","m2","re3","m3","name","params","x","a","b","contains","areaA","areaB","Ax1","Ay1","Ax2","Ay2","Bx1","By1","Bx2","By2","getArea","bbox","parts","makeBBox","centre","scale","size","lon","lat","width","height","tileCount","Math","pow","dLon","dLat","p","toFixed","clearMap","canvasRef","current","clientWidth","clientHeight","devicePixelRatio","renderMap","elements","nodeMap","n","id","wayMap","ctx","getContext","projection","mercatorProjection","save","fillStyle","strokeStyle","lineWidth","globalAlpha","beginPath","rect","fill","stroke","coords","r","longitude","latitude","y","ellipse","PI","el","nodes","moveTo","lineTo","closePath","members","ways","ref","content","replace","fontSize","fontWeight","fontFamily","font","strokeText","fillText","vertical","find","horizontal","step","parseFloat","round","xmin","floor","xmax","ceil","ymin","ymax","j","restore","cLon","cLat","hPixelsPerDeg","vPixelsPerDeg","QUARTER_PI","cX","cY","cLatPrime","tan","E","N","IDBElementDatabase","request","indexedDB","open","addEventListener","ev","db","target","result","createObjectStore","keyPath","createIndex","unique","Promise","resolve","reject","store","transaction","objectStore","put","get","ids","all","getNode","makeKey","getElementsByKey","range","IDBKeyRange","bound","Number","MAX_VALUE","openKeyCursor","count","cursor","primaryKey","keyBBox","debug","continue","record","area","bkey","require","overpassRe","recurRe","Overpass","Map","database","clear","set","toString","keys","test","has","searchElements","then","els","query","values","rels","slice","refs","way","saveElements","cached","Date","now","sMap","url","fetch","ok","json","status","tries","d","setTimeout","tryElements","getElements","dbResult","dbSearchResult","catch","delete","useDebounce","delay","debouncedValue","setDebouncedValue","useEffect","handler","clearTimeout","App","style","setStyle","setCentre","setScale","geolocation","navigator","loc","setLoc","getCurrentPosition","watchPosition","clearWatch","useLocation","useRef","overpassRef","fetching","setFetching","error","setError","debouncedCentre","debouncedScale","useMemo","debouncedStyle","parsedStyle","styleText","rulesResult","mediaResult","parseStyle","move","dX","dY","centrePoint","stepSize","newCentre","setBBox","preLoadElements","promise","item","run","className","onChange","onClick","readOnly","color","Boolean","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.f18f124e.chunk.js","sourcesContent":["\r\nexport const API_ROOT = \"https://lz4.overpass-api.de/api/interpreter\";","import React from 'react';\r\n\r\n/**\r\n * @template T\r\n * @param {string} key \r\n * @param {T} initalState \r\n * @returns {[ T, (newState: T) => void ]}\r\n */\r\nexport default function useSavedState (key, initalState) {\r\n    const [ state, setState ] = React.useState(() => {\r\n        const saved = localStorage.getItem(key);\r\n    \r\n        if (saved) {\r\n            try {\r\n                initalState = JSON.parse(saved);\r\n            } catch (e) {}\r\n        }\r\n\r\n        return initalState;\r\n    });\r\n\r\n    return [\r\n        state,\r\n        newState => {\r\n            localStorage.setItem(key, JSON.stringify(newState));\r\n            setState(newState);\r\n        }\r\n    ]\r\n}","\r\n/** \r\n * @typedef StyleRule\r\n * @property {\"rule\"} type\r\n * @property {StyleSelector} [selector]\r\n * @property {StyleSelector[]} [selectors]\r\n * @property {{ [key: string]: string }} declarations\r\n */\r\n\r\n/**\r\n * @typedef MediaQuery\r\n * @property {\"query\"} type\r\n * @property {{ left: string, operator: string, right: string }} predicate \r\n * @property {StyleRule[]} rules\r\n */\r\n\r\n\r\nexport class StyleSelector {\r\n    /**\r\n     * @param {string} type\r\n     * @param {{ [key: string]: string }} tags\r\n     * @param {{ name: string, params: string[] }[]} pseudoClasses\r\n     */\r\n    constructor (type, tags, pseudoClasses=[]) {\r\n      this.type = type;\r\n      this.tags = tags;\r\n      this.pseudoClasses = pseudoClasses;\r\n    }\r\n  \r\n    toString () {\r\n      return `${this.type}${Object.entries(this.tags).map(([k,v]) => `[${k}=${v}]`).join(\"\")}`;\r\n    }\r\n}\r\n  \r\nStyleSelector.parse = /**\r\n * @param {string} text\r\n */\r\nfunction (text) {\r\n    const re = /^\\s*([a-z]+)/;\r\n    const m = re.exec(text);\r\n  \r\n    if (!m) return null;\r\n\r\n    let type = m[1];\r\n\r\n    if (type === \"rel\") {\r\n      type = \"relation\";\r\n    }\r\n\r\n    /** @type {{ [key: string]: string }} */\r\n    const tags = {};\r\n  \r\n    let tagText = text.substring(m[0].length).trim();\r\n  \r\n    const re2 = /^\\[([^[\\]=]+)=([^[\\]=]+)\\]/;\r\n\r\n    while (true) {\r\n      const m2 = re2.exec(tagText);\r\n\r\n      if (!m2) break;\r\n\r\n      tags[m2[1]] = m2[2];\r\n\r\n      tagText = tagText.substring(m2[0].length);\r\n    }\r\n\r\n    /** @type {{ name: string, params: string[] }[]} */\r\n    const pseudoClasses = [];\r\n  \r\n    const re3 = /^:([a-z]+)(?:\\(([^)]+)\\))?/;\r\n\r\n    while (true) {\r\n      const m3 = re3.exec(tagText);\r\n\r\n      if (!m3) break;\r\n\r\n      pseudoClasses.push({ name: m3[1], params: m3[2] ? m3[2].split(\",\") : [] });\r\n\r\n      tagText = tagText.substring(m3[0].length);\r\n    }\r\n\r\n    if (tagText.length) {\r\n      console.log(`Invalid selector: ${text} unexpected part: '${tagText}'`);\r\n      return null;\r\n    }\r\n  \r\n    return new StyleSelector(type, tags, pseudoClasses);\r\n};\r\n  \r\n/**\r\n * \r\n * @param {string} text \r\n */\r\nStyleSelector.parseMultiple = function (text) {\r\n    return text.split(\",\").map(StyleSelector.parse).filter(x => x);\r\n}\r\n\r\n/**\r\n * \r\n * @param {{ rules: StyleRule[] }} style \r\n * @param {import(\"./Overpass\").OverpassElement} element \r\n * @returns {StyleRule}\r\n */\r\nexport function matchRule (style, element) {\r\n    for (const rule of style.rules) {\r\n      for (const selector of rule.selectors) {\r\n        if (matchSelector(selector, element))  return rule;\r\n      }\r\n    }\r\n}\r\n\r\n/**\r\n * @param {StyleSelector} selector\r\n * @param {import(\"./Overpass\").OverpassElement} element\r\n */\r\nexport function matchSelector (selector, element) {\r\n  if (element.type !== selector.type) return false;\r\n\r\n  let match = true;\r\n\r\n  for (const [key, value] of Object.entries(selector.tags)) {\r\n    if (!element.tags || element.tags[key] !== value) {\r\n      match = false;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return match;\r\n}\r\n\r\n/**\r\n * @param {string} styleText\r\n */\r\nexport function parseStyle (styleText) {\r\n  /** @type {{ rules: (StyleRule|MediaQuery)[] }} */\r\n  const out = { rules: [] };\r\n\r\n  let length = styleText.length;\r\n\r\n  while (length > 0) {\r\n\r\n    // Try parsing rule list\r\n    const rulesResult = parseRules(styleText);\r\n    out.rules.push(...rulesResult.rules);\r\n    styleText = styleText.substring(rulesResult.index).trim();\r\n\r\n    // Try parsing media query\r\n    const mediaResult = parseMedia(styleText);\r\n    out.rules.push(...mediaResult.mediaQueries);\r\n    styleText = styleText.substring(mediaResult.index).trim();\r\n\r\n    if (styleText.length === length) {\r\n      console.log(\"Got stuck parsing style at: \" + styleText);\r\n      break;\r\n    }\r\n\r\n    length = styleText.length;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * @param {string} mediaText\r\n */\r\nfunction parseMedia (mediaText) {\r\n  const re = /^\\s*@media\\s+\\(([a-z-]+)\\s*(:|=|<=|>=|<|>)\\s*([^)]+)\\)\\s*{/;\r\n  /** @type {{ mediaQueries: MediaQuery[], index: number }} */\r\n  const out = { mediaQueries: [], index: 0 };\r\n  let match;\r\n\r\n  const re2 = /^\\s*}/;\r\n  let match2;\r\n\r\n  while (match = re.exec(mediaText)) {\r\n    const predicate = {\r\n      left: match[1].trim(),\r\n      operator: match[2].trim(),\r\n      right: match[3].trim(),\r\n    };\r\n\r\n    out.index += match[0].length;\r\n\r\n    mediaText = mediaText.substring(match[0].length);\r\n\r\n    const { rules, index } = parseRules(mediaText);\r\n\r\n    out.index += index;\r\n\r\n    mediaText = mediaText.substring(index);\r\n\r\n    match2 = re2.exec(mediaText);\r\n    \r\n    if (match2) {\r\n      out.mediaQueries.push({\r\n        type: \"query\",\r\n        predicate,\r\n        rules,\r\n      });\r\n\r\n      out.index += match2[0].length;\r\n\r\n    } else {\r\n      console.log(\"Unterminated media query\");\r\n    }\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nfunction parseRules (ruleText) {\r\n  const re = /^\\s*([^{}]+)\\s*{([^{}]*)}/;\r\n  let match;\r\n  /** @type {{ rules: StyleRule[], index: number }} */\r\n  const out = { rules: [], index: 0 };\r\n\r\n  while(match = re.exec(ruleText)) {\r\n    /** @type {{ [key: string]: string }} */\r\n    const declarations = {};\r\n    \r\n    match[2].split(\";\").map(s => s.trim()).filter(s => s).forEach(s => {\r\n      // s.split(\":\", 2) is not the same as PHP\r\n      const i = s.indexOf(\":\");\r\n      const property = s.substring(0,i).trim();\r\n      const value = s.substring(i+1).trim();\r\n      declarations[property] = value;\r\n    });\r\n\r\n    const selectors = StyleSelector.parseMultiple(match[1]);\r\n\r\n    if (selectors.length) {\r\n      out.rules.push({\r\n        type: \"rule\",\r\n        selectors,\r\n        declarations,\r\n      });\r\n    }\r\n\r\n    out.index += match[0].length;\r\n\r\n    ruleText = ruleText.substring(match[0].length);\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * \r\n * @param {(StyleRule|MediaQuery)[]} rules \r\n * @param {object} context \r\n */\r\nexport function expandRules (rules, context) {\r\n  const out = [];\r\n  for (const rule of rules) {\r\n    if (rule.type === \"rule\") {\r\n      const { declarations } = rule;\r\n      for (const selector of rule.selectors) {\r\n        out.push({ selector, declarations });\r\n      }\r\n    } else {\r\n      if (testPredicate(rule.predicate, context)) {\r\n        out.push(...expandRules(rule.rules, context));\r\n      }\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * \r\n * @param {{ left: string, operator: string, right: string }} predicate \r\n * @param {object} context \r\n * @returns {boolean}\r\n */\r\nfunction testPredicate (predicate, context) {\r\n  if (predicate.left === \"zoom\") {\r\n    return COMPARE[predicate.operator](context.zoom, predicate.right);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nconst COMPARE = {\r\n  \":\": (a,b) => a == b,\r\n  \"=\": (a,b) => a == b,\r\n  \">\": (a,b) => a > b,\r\n  \"<\": (a,b) => a < b,\r\n  \">=\": (a,b) => a >= b,\r\n  \"<=\": (a,b) => a <= b,\r\n}","\r\n/**\r\n * Can the string be considered a valid bbox?\r\n * - Are there four parts?\r\n * - Are they all numberic?\r\n * - Are they in the correct order?\r\n * @param {string} bbox \r\n */\r\nexport function isValid (bbox) {\r\n    const parts = bbox.split(\",\");\r\n    \r\n    if (parts.length !== 4) return false;\r\n  \r\n    if (parts.some(p => isNaN(+p))) return false;\r\n  \r\n    return +parts[0] < +parts[2] && +parts[1] < +parts[3];\r\n}\r\n\r\n/**\r\n * Determines whether or not areaB is entirely contained\r\n * within areaA\r\n * @param {string} areaA \r\n * @param {string} areaB \r\n * @returns {boolean}\r\n */\r\nexport function contains (areaA, areaB) {\r\n    const [Ax1,Ay1,Ax2,Ay2] = areaA.split(\",\");\r\n    const [Bx1,By1,Bx2,By2] = areaB.split(\",\");\r\n\r\n    return (Bx1 >= Ax1 && By1 >= Ay1 && Bx2 <= Ax2 && By2 <= Ay2);\r\n}\r\n\r\n/**\r\n * Compute simple area\r\n * @param {string} bbox \r\n */\r\nexport function getArea (bbox) {\r\n    const parts = bbox.split(\",\");\r\n    return (+parts[2] - +parts[0]) * (+parts[3] - +parts[1]);\r\n}\r\n\r\n/**\r\n * \r\n * @param {[number, number]} centre \r\n * @param {number} scale \r\n * @param {[number, number]} size \r\n */\r\nexport function makeBBox (centre, scale, size) {\r\n    const baseTileSize = 256;\r\n\r\n    const [ lon, lat ] = centre;\r\n    const [ width, height ] = size;\r\n\r\n    const tileCount = Math.pow(2, scale)\r\n    const xSpan = 180 / tileCount;\r\n    const ySpan = 180 / tileCount;\r\n    \r\n    const hTileCount = width / baseTileSize;\r\n    const vTileCount = height / baseTileSize;\r\n\r\n    const dLon = xSpan * hTileCount;\r\n    const dLat = ySpan * vTileCount;\r\n\r\n    return [ lon - dLon, lat - dLat, lon + dLon, lat + dLat ].map(p => p.toFixed(3)).join(\",\");\r\n}","import { makeBBox } from \"./bbox\";\r\n\r\nexport function clearMap (canvasRef) {\r\n    const { clientWidth, clientHeight } = canvasRef.current;\r\n\r\n    const width = clientWidth * devicePixelRatio;\r\n    const height = clientHeight * devicePixelRatio;\r\n\r\n    canvasRef.current.width = width;\r\n    canvasRef.current.height = height;\r\n}\r\n\r\nconst debugBox = false;\r\nconst debugLines = false;\r\n\r\n/**\r\n * @param {[number,number]} centre\r\n * @param {number} scale\r\n * @param {import(\"./Overpass\").OverpassElement[]} elements\r\n * @param {React.MutableRefObject<HTMLCanvasElement>} canvasRef\r\n * @param {import(\"./Style\").StyleRule} rule\r\n * @param {{ zoom: number, current: Position }} context\r\n */\r\nexport function renderMap (centre, scale, elements=[], canvasRef, rule, context) {\r\n    if (canvasRef.current) {\r\n\r\n        // Prepare node map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n        const nodeMap = {};\r\n        elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n        // Prepare way map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n        const wayMap = {};\r\n        elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n        \r\n        const ctx = canvasRef.current.getContext(\"2d\");\r\n        const { clientWidth, clientHeight } = canvasRef.current;\r\n\r\n        const width = clientWidth * devicePixelRatio;\r\n        const height = clientHeight * devicePixelRatio;\r\n\r\n        /** @type {(lon: number, lat: number) => [number, number]} */\r\n        const projection = mercatorProjection(centre, scale, width, height);\r\n\r\n        if (debugBox) {\r\n            const bbox = makeBBox(centre, scale, [width, height]);\r\n            const parts = bbox.split(\",\");\r\n            const [ x1, y1 ] = projection(+parts[0], +parts[1]);\r\n            const [ x2, y2 ] = projection(+parts[2], +parts[3]);\r\n            ctx.beginPath();\r\n            ctx.rect(x1, y1, x2 - x1, y2 - y1);\r\n            ctx.strokeStyle = \"black\";\r\n            ctx.stroke();\r\n        }\r\n\r\n        if (debugLines) {\r\n            const xmin = 6.5;\r\n            const xmax = 7.5;\r\n            const xstep = 0.1;\r\n            const ymin = 50;\r\n            const ymax = 51;\r\n            const ystep = 0.1;\r\n            ctx.beginPath();\r\n            for (let i = xmin; i < xmax; i += xstep) {\r\n                ctx.moveTo(...projection(i, ymin));\r\n                for (let j = ymin; j < ymax; j += ystep) {\r\n                    ctx.lineTo(...projection(i, j));\r\n                }\r\n            }\r\n            for (let j = ymin; j < ymax; j += ystep) {\r\n                ctx.moveTo(...projection(xmin, j));\r\n                for (let i = ymin; i < ymax; i += ystep) {\r\n                    ctx.lineTo(...projection(i, j));\r\n                }\r\n            }\r\n            ctx.strokeStyle = \"black\";\r\n            ctx.stroke();\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        ctx.fillStyle = rule.declarations[\"fill\"];\r\n        ctx.strokeStyle = rule.declarations[\"stroke\"];\r\n        ctx.lineWidth = +rule.declarations[\"stroke-width\"] * devicePixelRatio;\r\n        \r\n        if (rule.declarations[\"opacity\"]) \r\n            ctx.globalAlpha = +rule.declarations[\"opacity\"];\r\n\r\n        // Special rules first\r\n        if (rule.selector.type === \"map\") {\r\n            ctx.beginPath();\r\n            ctx.rect(0,0,width, height);\r\n            \r\n            rule.declarations[\"fill\"] && ctx.fill();\r\n            rule.declarations[\"stroke\"] && ctx.stroke();\r\n        }\r\n        else if (rule.selector.type === \"current\") {\r\n            if (context.current) {\r\n                const { coords } = context.current;\r\n\r\n                ctx.beginPath();\r\n\r\n                const r = +rule.declarations[\"size\"] * devicePixelRatio;\r\n                const [x, y] = projection(coords.longitude, coords.latitude);\r\n\r\n                ctx.ellipse(x, y, r, r, 0, 0, Math.PI * 2);\r\n                \r\n                rule.declarations[\"fill\"] && ctx.fill();\r\n                rule.declarations[\"stroke\"] && ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Then iterate all elements\r\n        for (const el of elements) {\r\n            if (el.type !== rule.selector.type) continue;\r\n\r\n            // Paths\r\n            ctx.beginPath();\r\n\r\n            if (el.type === \"node\") {\r\n\r\n                const r = +rule.declarations[\"size\"] * devicePixelRatio;\r\n                const [x, y] = projection(el.lon, el.lat);\r\n\r\n                ctx.ellipse(x, y, r, r, 0, 0, Math.PI * 2);\r\n\r\n            }\r\n            else if (el.type === \"way\") {\r\n                if (!el.nodes) continue;\r\n\r\n                const nodes = el.nodes.map(id => nodeMap[id]);\r\n\r\n                ctx.moveTo(...projection(nodes[0].lon, nodes[0].lat));\r\n                for (let i = 1; i < nodes.length; i++) {\r\n                    ctx.lineTo(...projection(nodes[i].lon, nodes[i].lat));\r\n                }\r\n            }\r\n            else if (el.type === \"area\") {\r\n                if (!el.nodes) continue;\r\n\r\n                const nodes = el.nodes.map(id => nodeMap[id]);\r\n\r\n                ctx.moveTo(...projection(nodes[0].lon, nodes[0].lat));\r\n                for (let i = 1; i < nodes.length; i++) {\r\n                    ctx.lineTo(...projection(nodes[i].lon, nodes[i].lat));\r\n                }\r\n                ctx.closePath();\r\n            }\r\n            else if (el.type === \"relation\") {\r\n                if (!el.members) continue;\r\n\r\n                // As long as outer ways go anti-clockwise and inner rings go clockwise\r\n                // (or possibly vice-versa) then the CanvasRenderingContext2D can handle\r\n                // rending \"holes\".\r\n\r\n                const ways = el.members.filter(m => m.type === \"way\").map(m => wayMap[m.ref]);\r\n\r\n                for (const way of ways) {\r\n                    const nodes = way.nodes.map(id => nodeMap[id]);\r\n\r\n                    ctx.moveTo(...projection(nodes[0].lon, nodes[0].lat));\r\n                    for (let i = 1; i < nodes.length; i++) {\r\n                        ctx.lineTo(...projection(nodes[i].lon, nodes[i].lat));\r\n                    }\r\n                }\r\n                ctx.closePath();\r\n            }\r\n\r\n            rule.declarations[\"fill\"] && ctx.fill();\r\n            rule.declarations[\"stroke\"] && ctx.stroke();\r\n\r\n            // Text Handling \r\n            \r\n            if (rule.declarations[\"content\"] && el.type === \"node\") {\r\n                const [x, y] = projection(el.lon, el.lat);\r\n\r\n                let content = rule.declarations[\"content\"];\r\n                \r\n                if (content.match(/^\".*\"$/g)) {\r\n                    content = content.replace(/^\"|\"$/g, \"\");\r\n                } else if (content.match(/tag\\(([^)]+)\\)/)) {\r\n                    const m = content.match(/tag\\(([^)]+)\\)/);\r\n                    content = el.tags[m[1]] || \"\";\r\n                } else {\r\n                    content = \"?\";\r\n                }\r\n\r\n                let fontSize = `${10 * devicePixelRatio}px`;\r\n                let fontWeight = \"normal\";\r\n                let fontFamily = \"sans-serif\";\r\n\r\n                if (rule.declarations[\"font-size\"]) {\r\n                    fontSize = rule.declarations[\"font-size\"].replace(/^\\d[\\d.]*/, m => `${+m * devicePixelRatio}`);\r\n                }\r\n\r\n                if (rule.declarations[\"font-weight\"]) {\r\n                    fontWeight = rule.declarations[\"font-weight\"];\r\n                }\r\n\r\n                if (rule.declarations[\"font-family\"]) {\r\n                    fontFamily = rule.declarations[\"font-family\"];\r\n                }\r\n\r\n                ctx.font = rule.declarations[\"font\"] || `${fontWeight} ${fontSize} ${fontFamily}`;\r\n\r\n                if (rule.declarations[\"stroke\"]) \r\n                    ctx.strokeText(content, x, y);\r\n                if (rule.declarations[\"fill\"] || !rule.declarations[\"stroke\"]) \r\n                    ctx.fillText(content, x, y);\r\n            }\r\n\r\n        }\r\n\r\n        if (rule.selector.type === \"gridlines\") {\r\n            const vertical = rule.selector.pseudoClasses.find(p => p.name === \"vertical\");\r\n            const horizontal = rule.selector.pseudoClasses.find(p => p.name === \"horizontal\");\r\n            \r\n            if (vertical) {\r\n                const bbox = makeBBox(centre, scale, [width, height]);\r\n                const parts = bbox.split(\",\");\r\n\r\n                const step = parseFloat(vertical.params[0]);\r\n\r\n                const round = 1 / step;\r\n\r\n                const xmin = Math.floor(+parts[0]*round)/round;\r\n                const xmax = Math.ceil(+parts[2]*round)/round;\r\n                const ymin = Math.floor(+parts[1]*round)/round;\r\n                const ymax = Math.ceil(+parts[3]*round)/round;\r\n\r\n                ctx.beginPath();\r\n                for (let i = xmin; i <= xmax; i += step) {\r\n                    ctx.moveTo(...projection(i, ymin));\r\n                    for (let j = ymin; j <= ymax; j += step) {\r\n                        ctx.lineTo(...projection(i, j));\r\n                    }\r\n                }\r\n                rule.declarations[\"stroke\"] && ctx.stroke();\r\n            }\r\n            \r\n            if (horizontal) {\r\n                const bbox = makeBBox(centre, scale, [width, height]);\r\n                const parts = bbox.split(\",\");\r\n\r\n                const step = parseFloat(horizontal.params[0]);\r\n\r\n                const round = 1 / step;\r\n\r\n                const xmin = Math.floor(+parts[0]*round)/round;\r\n                const xmax = Math.ceil(+parts[2]*round)/round;\r\n                const ymin = Math.floor(+parts[1]*round)/round;\r\n                const ymax = Math.ceil(+parts[3]*round)/round;\r\n\r\n                ctx.beginPath();\r\n                for (let j = ymin; j <= ymax; j += step) {\r\n                    ctx.moveTo(...projection(xmin, j));\r\n                    for (let i = xmin; i <= xmax; i += step) {\r\n                        ctx.lineTo(...projection(i, j));\r\n                    }\r\n                }\r\n                rule.declarations[\"stroke\"] && ctx.stroke();\r\n            }\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\n/**\r\n * @returns {(lon: number, lat: number) => [number, number]} \r\n */\r\nfunction flatProjection (minLon, minLat, maxLon, maxLat, width, height) {\r\n    const xScale = width / (maxLon - minLon);\r\n    const yScale = height / (maxLat - minLat);\r\n    const scale = Math.max(xScale, yScale);\r\n    return ((lon, lat) => [(lon - minLon) * scale, height - (lat - minLat) * scale]);\r\n}\r\n\r\n/**\r\n * @param {[number, number]} centre\r\n * @param {number} scale\r\n * @param {number} width\r\n * @param {number} height\r\n * @returns {(lon: number, lat: number) => [number, number]} \r\n */\r\nfunction mercatorProjection (centre, scale, width, height) {\r\n    const baseTileSize = 256;\r\n\r\n    const [ cLon, cLat ] = centre;\r\n\r\n    const tileCount = Math.pow(2, scale)\r\n    const degPerTileH = 180 / tileCount;\r\n    const degPerTileV = 180 / tileCount;  \r\n\r\n    const hPixelsPerDeg = baseTileSize / degPerTileH;\r\n    const vPixelsPerDeg = baseTileSize / degPerTileV;\r\n\r\n    const QUARTER_PI = Math.PI / 4;\r\n\r\n    const cX = width / 2;\r\n    const cY = height / 2;\r\n\r\n    const cLatPrime = Math.log(Math.tan(QUARTER_PI + (cLat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n    return (lon, lat) => {\r\n        const E = lon;\r\n        const N = Math.log(Math.tan(QUARTER_PI + (lat / 180 * Math.PI) / 2)) * 180 / Math.PI;\r\n\r\n        const dLon = E - cLon;\r\n        const dLat = N - cLatPrime;\r\n\r\n        const dX = dLon * hPixelsPerDeg;\r\n        const dY = dLat * vPixelsPerDeg;\r\n\r\n        return [cX + dX, cY - dY];\r\n    }\r\n}","import { contains, getArea } from \"./bbox\";\r\n\r\nexport default class IDBElementDatabase {\r\n    constructor (name=\"OverpassElements\") {\r\n        const request = indexedDB.open(name);\r\n\r\n        request.addEventListener(\"upgradeneeded\", ev => {\r\n            /** @type {IDBOpenDBRequest} */\r\n            const request = (ev.target);\r\n            const db = request.result;\r\n            db.createObjectStore(\"nodes\", { keyPath: \"id\" });\r\n\r\n            const store = db.createObjectStore(\"elements\");\r\n            store.createIndex(\"selectorIndex\", [\"selector\", \"area\", \"bbox\"], { unique: false });\r\n        });\r\n\r\n        /** @type {Promise<IDBDatabase>} */\r\n        this.db = new Promise((resolve, reject) => {\r\n            request.addEventListener(\"success\", ev => {\r\n                /** @type {IDBOpenDBRequest} */\r\n                const request = (ev.target);\r\n                resolve(request.result);\r\n            });\r\n\r\n            request.addEventListener(\"error\", reject);\r\n        })\r\n\r\n    }\r\n\r\n    async saveNodes (nodes) {\r\n        const db = await this.db;\r\n        const store = db.transaction(\"nodes\", \"readwrite\").objectStore(\"nodes\");\r\n        for (const n of nodes) {\r\n            store.put(n);\r\n        }\r\n    }\r\n\r\n    async getNode (id) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const store = db.transaction(\"nodes\", \"readonly\").objectStore(\"nodes\");\r\n            const request = store.get(id);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", e => reject(e));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number[]} ids \r\n     */\r\n    getNodes (ids) {\r\n        return Promise.all(ids.map(id => this.getNode(id)));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} bbox \r\n     * @param {string} selector \r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    getElements (bbox, selector) {\r\n        const key = makeKey(bbox, selector);\r\n        return this.getElementsByKey(key);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} key \r\n     * @returns {Promise<{ elements: import(\"./Overpass\").OverpassElement[] }>}\r\n     */\r\n    async getElementsByKey (key) {\r\n        const db = await this.db;\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const request = objectStore.get(key);\r\n            request.addEventListener(\"success\", e => resolve(request.result));\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} bbox \r\n     * @param {string} selector \r\n     * @returns {Promise<string>}\r\n     */\r\n    async searchElements (bbox, selector) {\r\n        const db = await this.db;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readonly\").objectStore(\"elements\");\r\n            const index = objectStore.index(\"selectorIndex\");\r\n            const range = IDBKeyRange.bound([selector,0,\"0\"], [selector,Number.MAX_VALUE,\"999999999999999999\"]);\r\n            const request = index.openKeyCursor(range);\r\n            let count = 0;\r\n            request.addEventListener(\"success\", e => {\r\n                const cursor = request.result;\r\n                \r\n                if (cursor) {\r\n                    const { key, primaryKey } = cursor;\r\n                    const keyBBox = key[2];\r\n                    count++;\r\n                    if (contains(keyBBox, bbox)) {\r\n                        console.debug(`${selector} found after checking ${count} records`);\r\n                        resolve(primaryKey);\r\n                        return;\r\n                    }\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    console.debug(`${selector} not found after checking ${count} records`);\r\n                    resolve(null);\r\n                }\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} bbox \r\n     * @param {string} selector \r\n     * @param {{ elements: import(\"./Overpass\").OverpassElement[], cached: number }} record \r\n     */\r\n    async saveElements (bbox, selector, record) {\r\n        const db = await this.db;\r\n        const key = makeKey(bbox, selector);\r\n        const area = getArea(bbox);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const objectStore = db.transaction(\"elements\", \"readwrite\").objectStore(\"elements\");\r\n            const request = objectStore.put({ selector, bbox, area, ...record }, key);\r\n            request.addEventListener(\"success\", () => {\r\n                console.debug(`Saved ${selector}/${bbox} to database with ${record.elements.length} elements`);\r\n                resolve();\r\n            });\r\n            request.addEventListener(\"error\", reject);\r\n        });\r\n    }\r\n}\r\n\r\nfunction makeKey (bbox, selector) {\r\n    const bkey = bbox.split(\",\").map(p => (+p).toFixed(3)).join(\",\");\r\n    return `${bkey}#${selector}`;\r\n}\r\n","import IDBElementDatabase from \"./database.idb\";\r\nimport { contains } from \"./bbox\";\r\nimport { matchSelector } from \"./Style\";\r\n\r\n/** @typedef {import(\"./Style\").StyleSelector} StyleSelector */\r\n\r\nconst API_ROOT = require(\"./const\").API_ROOT;\r\n\r\nconst overpassRe = /(node|way|rel(?:ation)?|area)/;\r\nconst recurRe = /(way|rel(?:ation)?|area)/;\r\n\r\nexport class Overpass {\r\n    constructor (bbox) {\r\n        /** @type {Map<string, Promise<OverpassElement[]>>} */\r\n        this.elements = new Map();\r\n        this.bbox = bbox;\r\n        this.database = new IDBElementDatabase();\r\n    }\r\n\r\n    setBBox (bbox) {\r\n        // If the new bbox is completely contained within the\r\n        // old one then we don't need to clear our cache\r\n        if (!contains(this.bbox, bbox)) {\r\n            this.elements.clear();\r\n        }\r\n        this.bbox = bbox;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {StyleSelector[]} selectors \r\n     */\r\n    async preLoadElements (selectors) {\r\n        const { bbox } = this;\r\n\r\n        // Create set of selectors\r\n        /** @type {{ [key: string]: StyleSelector }} */\r\n        const set = {};\r\n        selectors.forEach(s => set[s.toString()] = s);\r\n\r\n        console.debug(`Preloading Elements: ${selectors.length} requested (${Object.keys(set).length} unique)`);\r\n\r\n        // Remove non-overpass selectors\r\n        for (const [key, selector] of Object.entries(set)) {\r\n            if (!overpassRe.test(selector.type)) delete set[key];\r\n        }\r\n        console.debug(`Preloading Elements: ${Object.keys(set).length} are Overpass Elements`); \r\n\r\n        // Remove selectors in local hash map cache\r\n        for (const key of Object.keys(set)) {\r\n            if (this.elements.has(key)) delete set[key];\r\n        }\r\n        console.debug(`Preloading Elements: ${Object.keys(set).length} not in HashMap`); \r\n        \r\n        // Remove selectors in database\r\n        await Promise.all(Object.keys(set).map(s => {\r\n            return this.database.searchElements(bbox, s)\r\n                .then(els => {\r\n                    if (els) delete set[s];\r\n                });\r\n        }));\r\n        console.debug(`Preloading Elements: ${Object.keys(set).length} not in Database`);\r\n\r\n        if (Object.keys(set).length === 0) return;\r\n\r\n        const { elements } = await this.query(Object.values(set));\r\n\r\n        console.log(`Preloading Elements: Fetched ${elements.length} elements from Server`);\r\n\r\n        // Prepare node map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassNodeElement }} */\r\n        const nodeMap = {};\r\n        elements.forEach(n => n.type === \"node\" && (nodeMap[n.id] = n));\r\n        // Prepare way map\r\n        /** @type {{ [id: number]: import(\"./Overpass\").OverpassWayElement }} */\r\n        const wayMap = {};\r\n        elements.forEach(n => n.type === \"way\" && (wayMap[n.id] = n));\r\n\r\n        return Promise.all(Object.values(set).map(selector => {\r\n            const out = elements.filter(el => matchSelector(selector, el));\r\n\r\n            if (selector.type === \"relation\") {\r\n                /** @type {OverpassRelElement[]} */\r\n                const rels = (out.slice());\r\n\r\n                /** @type {OverpassWayElement[]} */\r\n                const ways = [];\r\n\r\n                for (const rel of rels) {\r\n                    const refs = rel.members.map(m => m.ref);\r\n                    ways.push(...refs.map(id => wayMap[id]));\r\n                }\r\n\r\n                out.push(...ways);\r\n\r\n                for (const way of ways) {\r\n                    out.push(...way.nodes.map(id => nodeMap[id]));\r\n                }\r\n\r\n            } else if (selector.type === \"way\") {\r\n                /** @type {OverpassWayElement[]} */\r\n                const ways = (out.slice());\r\n\r\n                for (const way of ways) {\r\n                    out.push(...way.nodes.map(id => nodeMap[id]));\r\n                }\r\n            }\r\n\r\n            this.elements.set(selector.toString(), Promise.resolve(out));\r\n            return this.database.saveElements(bbox, selector.toString(), { elements: out, cached: Date.now() });\r\n        }));\r\n        }\r\n\r\n    /**\r\n     * \r\n     * @param {StyleSelector[]} selectors \r\n     * @returns {Promise<{ elements: OverpassElement[] }>}\r\n     */\r\n    query (selectors) {\r\n        const sMap = selectors.map(s => recurRe.test(s.type) ? `\\n\\t${s};\\n\\t>;` : s.toString() + \";\");\r\n        const query = `[out:json][bbox];\\n(${sMap.join(\"\")}\\n);\\nout;`\r\n        const url = `${API_ROOT}?data=${query.replace(/\\s/,\"\")}&bbox=${this.bbox}`;\r\n        return fetch(url.toString()).then(r => r.ok ? r.json() : Promise.reject(r.status));\r\n    }\r\n\r\n    tryElements (selector, tries=10) {\r\n        return new Promise ((resolve, reject) => {\r\n            this.query([selector]).then(d => {\r\n                resolve(d.elements);\r\n            }, e => {\r\n                if (e !== 429) reject(\"Bad Response\");\r\n                else if (tries > 0) {\r\n                    setTimeout(() => {\r\n                        this.tryElements(selector, tries - 1).then(resolve, reject);\r\n                    }, 10000);\r\n                }\r\n                else reject(e);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {import(\"./Style\").StyleSelector} selector\r\n     * @returns {Promise<OverpassElement[]>}\r\n     */\r\n    async getElements (selector) {\r\n        if (!overpassRe.test(selector.type)) return;\r\n\r\n        const s = selector.toString();\r\n        if (this.elements.has(s)) return this.elements.get(s);\r\n\r\n        const dbResult = await this.database.getElements(this.bbox, selector.toString());\r\n\r\n        if (dbResult) {\r\n            const { elements } = dbResult;\r\n            this.elements.set(s, Promise.resolve(elements));\r\n            return elements;\r\n        }\r\n\r\n        const dbSearchResult = await this.database.searchElements(this.bbox, selector.toString());\r\n\r\n        if (dbSearchResult) {\r\n            const elements = this.database.getElementsByKey(dbSearchResult).then(r => r.elements);\r\n            this.elements.set(s, elements);\r\n            return elements;\r\n        }\r\n\r\n        const p = this.tryElements(selector);\r\n        \r\n        this.elements.set(s, p);\r\n        \r\n        p.catch(() => this.elements.delete(s));\r\n\r\n        p.then(elements => {\r\n            this.database.saveElements(this.bbox, selector.toString(), { elements, cached: Date.now() });\r\n        });\r\n\r\n        return p;\r\n    }\r\n}\r\n\r\n/** @typedef {import('./Style.js').StyleRule} StyleRule */\r\n\r\n/**\r\n * @typedef {OverpassNodeElement|OverpassWayElement|OverpassAreaElement|OverpassRelElement} OverpassElement\r\n */\r\n\r\n/**\r\n * @typedef OverpassNodeElement\r\n * @property {number} id\r\n * @property {\"node\"} type\r\n * @property {number} lon\r\n * @property {number} lat\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassWayElement\r\n * @property {number} id\r\n * @property {\"way\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassAreaElement\r\n * @property {number} id\r\n * @property {\"area\"} type\r\n * @property {number[]} nodes\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n\r\n/**\r\n * @typedef OverpassRelElement\r\n * @property {number} id\r\n * @property {\"relation\"} type\r\n * @property {{ ref: number, role: \"inner\"|\"outer\", type: \"node\"|\"way\"|\"relation\" }[]} members\r\n * @property {{ [key: string]: string }} [tags]\r\n */\r\n","import { useState, useEffect } from 'react';\r\n\r\n/**\r\n * @link https://usehooks.com/useDebounce/\r\n * @param {any} value \r\n * @param {number} delay \r\n */\r\nexport function useDebounce(value, delay) {\r\n    // State and setters for debounced value\r\n    const [debouncedValue, setDebouncedValue] = useState(value);\r\n  \r\n    useEffect(\r\n      () => {\r\n        // Update debounced value after delay\r\n        const handler = setTimeout(() => {\r\n          setDebouncedValue(value);\r\n        }, delay);\r\n  \r\n        // Cancel the timeout if value changes (also on delay change or unmount)\r\n        // This is how we prevent debounced value from updating if value is changed ...\r\n        // .. within the delay period. Timeout gets cleared and restarted.\r\n        return () => {\r\n          clearTimeout(handler);\r\n        };\r\n      },\r\n      [value, delay] // Only re-call effect if value or delay changes\r\n    );\r\n  \r\n    return debouncedValue;\r\n  }","import React from 'react';\nimport './App.css';\nimport useSavedState from './useSavedState';\nimport { parseStyle, expandRules } from './Style';\nimport { renderMap, clearMap } from './render';\nimport { Overpass } from './Overpass';\nimport { useDebounce } from './useDebounce';\nimport { makeBBox } from './bbox';\nimport useLocation from './useLocation';\n\nfunction App() {\n  const [ style, setStyle ] = useSavedState(\"USER_STYLE\", \"node[amenity=post_box] {\\n\\tfill: black;\\n\\tsize: 2;\\n}\");\n  const [ centre, setCentre ] = useSavedState(\"USER_CENTRE\", \"7.1,50.7\");\n  const [ scale, setScale ] = useSavedState(\"USER_SCALE\", 14);\n  const current = useLocation();\n  /** @type {React.MutableRefObject<HTMLCanvasElement>} */\n  const canvasRef = React.useRef();\n  /** @type {React.MutableRefObject<Overpass>} */\n  const overpassRef = React.useRef();\n  const [ fetching, setFetching ] = React.useState(false);\n  const [ error, setError ] = React.useState(\"\");\n\n  const { clientWidth: width, clientHeight: height } = canvasRef.current || { clientWidth: 1000, clientHeight: 1000 };\n\n  const debouncedCentre = useDebounce(centre, 500);\n  const debouncedScale = useDebounce(scale, 500);\n\n  const bbox = React.useMemo(() => makeBBox(debouncedCentre.split(\",\").map(p => +p), debouncedScale, [width, height]), [debouncedCentre, debouncedScale, width, height]);\n\n  if (!overpassRef.current) {\n    overpassRef.current = new Overpass(bbox);\n  }\n  \n  const debouncedStyle = useDebounce(style, 500);\n  \n  const parsedStyle = React.useMemo(() => parseStyle(debouncedStyle), [debouncedStyle]);\n\n  React.useEffect(() => overpassRef.current.setBBox(bbox), [bbox]);\n  \n  // Refetch/Render map when bbox, or style change\n  React.useEffect(() => {\n    async function run () {\n      setFetching(true);\n      setError(\"\");\n\n      try {\n        const context = { zoom: debouncedScale, current };\n        const rules = expandRules(parsedStyle.rules, context);\n        await overpassRef.current.preLoadElements(rules.map(r => r.selector));\n        \n        const map = rules.map(rule => {\n          return {\n            rule,\n            promise: overpassRef.current.getElements(rule.selector),\n          }\n        });\n\n        clearMap(canvasRef);\n\n        /** @type {[number, number]} */\n        const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\n\n        for (const item of map) {\n          const elements = await item.promise;\n          renderMap(centrePoint, debouncedScale, elements, canvasRef, item.rule, context);\n        }\n      } catch (e) {\n        setError(\"Error Fetching\");\n      } finally {\n        setFetching(false);\n      }\n    }\n\n    run();\n  }, [debouncedCentre, debouncedScale, parsedStyle, current]);\n\n  function move (dX, dY) {\n    /** @type {[number, number]} */\n    const centrePoint = (debouncedCentre.split(\",\").map(p => +p));\n    const stepSize = 360 / Math.pow(2, scale);\n    const newCentre = [ centrePoint[0] + dX * stepSize, centrePoint[1] + dY * stepSize ];\n    setCentre(newCentre.join(\",\"));\n  }\n\n  return (\n    <div className=\"App\">\n      <div className=\"sidebar\">\n        <label>Centre <input value={centre} onChange={e => setCentre(e.target.value)} /></label>\n        <button onClick={() => move(-1,0)}>⏴</button>\n        <button onClick={() => move(1,0)}>⏵</button>\n        <button onClick={() => move(0,1)}>⏶</button>\n        <button onClick={() => move(0,-1)}>⏷</button>\n        <button onClick={() => setScale(scale + 1)}>➕</button>\n        <button onClick={() => setScale(scale - 1)}>➖</button>\n        { current && <button onClick={() => setCentre(`${current.coords.longitude},${current.coords.latitude}`)}>📍</button> }\n        <label>Zoom <input type=\"number\" value={scale} onChange={e => setScale(+e.target.value)} /></label>\n        <label>Bounding Box <input value={bbox} readOnly /></label>\n        <label>Style <textarea value={style} onChange={e => setStyle(e.target.value)} /></label>\n        { fetching && <p>Loading...</p> }\n        { error && <p style={{color:\"red\"}}>{error}</p> }\n      </div>\n      <canvas ref={canvasRef} />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\r\n\r\nexport default function useLocation () {\r\n    const { geolocation } = navigator;\r\n\r\n    /** @type {[Position, (newPos: Position) => void]} */\r\n    const [ loc, setLoc ] = React.useState();\r\n\r\n    React.useEffect(() => { geolocation.getCurrentPosition(setLoc) }, []);\r\n\r\n    React.useEffect(() => {\r\n        const id = geolocation.watchPosition(setLoc);\r\n\r\n        return () => geolocation.clearWatch(id);\r\n    }, []);\r\n\r\n    return loc;\r\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}